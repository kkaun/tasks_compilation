

/*  !This file contains all task and tutorials done for JR course, taken from 2 different machines merged in one piece: 
i did tasks in 2 different places and, because of circumstances, wasn't able to use GIT on one of them).
All code, interesting notes and parts of tutorials are taken from IDE/project's classpath and sequentially merged 
in .TXT file by the order/date of completion.
*/





 
package com.javarush.test.level03.lesson08.task02;

/* Зарплата через 5 лет
Ввести с клавиатуры отдельно Имя, число1, число2. Вывести надпись:
«Имя» получает «число1» через «число2» лет.
Пример: Коля получает 3000 через 5 лет.
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String name = reader.readLine();
     String sAge1 = reader.readLine();
     String sAge2 = reader.readLine();
     int nAge1 = Integer.parseInt(sAge1);
     int nAge2 = Integer.parseInt(sAge2);
     System.out.println(name + " получает " + sAge1 + " через " + sAge2 + " лет.");


    }
}

______
package com.javarush.test.level03.lesson08.task05;

/* Чистая любовь
Ввести с клавиатуры три имени, вывести на экран надпись:
name1 + name2 + name3 = Чистая любовь, да-да!
Пример: Вася + Ева + Анжелика = Чистая любовь, да-да!
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String name1 = reader.readLine();
     String name2 = reader.readLine();
     String name3 = reader.readLine();
     System.out.println(name1 + " + " + name2 + " + " + name3 + " = Чистая любовь, да-да!");

    }
}

______
/* Shadowing variables
Подумайте, что делает программа.
Исправьте ошибку в программе чтобы переменная age объекта person изменила свое значение.
Подсказка: тщательно просмотрите метод adjustAge
*/
public class Solution
{
    public static void main(String[] args) {

        Person person = new Person();
        System.out.println("Age is: " + person.age);
        person.adjustAge(person.age);
        System.out.println("Adjusted Age is: " + person.age);
    }

    public static class Person
    {
        public int age = 20;

        public void adjustAge(int age)
        {
            this.age = age + 20;
            System.out.println("The Age in adjustAge() is " + age);
        }
    }
}


______
/* Реализовать метод addPrice
Реализовать метод addPrice(int applesPrice), чтобы при его вызове суммарная стоимость яблок увеличивалось на переданное значение.
За суммарную стоимость яблок отвечает переменная public static int applesPrice.
*/
public class Solution
{
    public static void main(String[] args) {
        Apple apple = new Apple();
        Apple.addPrice(50);
        Apple apple2 = new Apple();
        Apple.addPrice(100);
        System.out.println("Apples price is " + Apple.applesPrice);
    }

    public static class Apple{
        public static int applesPrice = 0;

        public static void addPrice(int applesPrice){
         Apple.applesPrice = Apple.applesPrice + applesPrice;
        }
    }

______	
	/* Реализовать метод setCatsCount
Реализовать метод setCatsCount так, чтобы с его помощью можно было устанавливать значение переменной catsCount равное переданному параметру.
*/

public class Cat {
    private static int catsCount = 0;

    public static void setCatsCount(int catsCount) {
     Cat.catsCount = catsCount;
    }
}

______
package com.javarush.test.level04.lesson02.task04;

/* Реализовать метод setName
Реализовать метод setName, чтобы с его помощью можно было устанавливать значение переменной private String fullName равное значению локальной переменной String fullName.
*/

public class Cat {
    private String fullName;

    public void setName(String firstName, String lastName) {
        String fullName = firstName + " " + lastName;

        this.fullName = firstName + " " + lastName;
    }
}

______
ckage com.javarush.test.level04.lesson02.task05;

/* Подсчитать количество котов
Написать код, чтобы правильно считалось количество созданных котов (count) и на экран выдавалось правильно их количество.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Cat cat1 = new Cat();
        Cat.count = Cat.count + 1;

        Cat cat2 = new Cat();
        Cat.count = Cat.count + 1;

        System.out.println("Cats count is " + Cat.count);
    }
    public static class Cat
    {
        public static int count = 0;
    }
}




if (a < b)
    System.out.println("А меньше Б");
else
    System.out.println("Б меньше А");
Если a меньше b, то выполнится первая команда, в противном случае – вторая. Команды никогда не выполнятся одновременно.
if (a < b)
{
    System.out.println("А меньше Б");
    System.out.println("Б больше А");
}
else
{
     System.out.println("Б меньше А");
     System.out.println("А больше Б");
}
Вместо одной команды можно подставить блок команд. В остальном - то же самое.
if (a < b)
{
    a = 0;
}
else
{
}
Блок else можно не писать, если он пустой.

Данные три примера абсолютно эквиваленты. 

Можно не писать скобочки, если нужно выполнить только одну команду. Если у нас несколько команд, то скобочки писать обязательно.
if (a < b)
{
    a = 0;
}
if (a < b)
    a = 0;
	
	
______

/* Сортировка трех чисел
Ввести с клавиатуры три числа, и вывести их в порядке убывания.
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String sa = reader.readLine();
     String sb = reader.readLine();
     String sc = reader.readLine();
     int a = Integer.parseInt(sa);
     int b = Integer.parseInt(sb);
     int c = Integer.parseInt(sc);
     
     if (a > b && b > c){

     System.out.println(a + " " + b + " " + c);
     }
     if (a > c && c > b){

     System.out.println(a + " " + c + " " + b);
     }
     if (c > a && a > b){
     
     System.out.println(c + " " + a + " " + b);
     }
     if (c > b && b > a){
    
     System.out.println(c + " " + b + " " + a);
     }
     if (b > a && a > c){

     System.out.println(b + " " + a + " " + c);
     }
     if (b > c && c > a){

     System.out.println(b + " " + c + " " + a);
     }
    }
}


______

package com.javarush.test.level04.lesson06.task04;

/* Сравнить имена
Ввести с клавиатуры два имени, и если имена одинаковые вывести сообщение «Имена идентичны». Если имена разные, но их длины равны – вывести сообщение – «Длины имен равны».
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String name1 = reader.readLine();
     String name2 = reader.readLine();
     
     int a = name1.length();
     int b = name2.length();
     
     if(name1.equals(name2)){
     System.out.println("Имена идентичны");
     } 
     else if(a == b){
     System.out.println("Длины имен равны");
     }
    }
}

______
package com.javarush.test.level04.lesson06.task05;

/* 18+
Ввести с клавиатуры имя и возраст. Если возраст меньше 18 вывести надпись «Подрасти еще».
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String name=reader.readLine();
     String sAge = reader.readLine();
     int nAge = Integer.parseInt(sAge);
     
     if(nAge < 18){
         System.out.println("Подрасти еще");
     }

    }
}


______

/* Координатные четверти
Ввести с клавиатуры два целых числа, которые будут координатами точки, не лежащей на координатных осях OX и OY.
Вывести на экран номер координатной четверти, в которой находится данная точка.
Подсказка:
Принадлежность точки с координатами (a,b) к одной из четвертей определяется следующим образом:
для первой четверти a>0 и b>0;
для второй четверти a<0 и b>0;
для третьей четверти a<0 и b<0;
для четвертой четверти a>0 и b<0.
Пример для чисел 4 6:
1
Пример для чисел -6 -6:
3
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String sa = reader.readLine();
     String sb = reader.readLine();
     int a = Integer.parseInt(sa);
     int b = Integer.parseInt(sb);
     
     if((a>0) && (b>0)){
         System.out.println("1");
     }
     if((a<0) && (b>0)){
         System.out.println("2");
     }
     if((a<0) && (b<0)){
         System.out.println("3");
     }
     if((a>0) && (b<0)){
         System.out.println("4");
     }

    }
}

______
/* Строка - описание
Ввести с клавиатуры целое число. Вывести на экран его строку-описание следующего вида:
«отрицательное четное число» - если число отрицательное и четное,
«отрицательное нечетное число» - если число отрицательное и нечетное,
«нулевое число» - если число равно 0,
«положительное четное число» - если число положительное и четное,
«положительное нечетное число» - если число положительное и нечетное.
Пример для числа 100:
положительное четное число
Пример для числа -51:
отрицательное нечетное число
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String sa = reader.readLine();
     int a = Integer.parseInt(sa);
     
     if((a < 0) && (a % 2 == 0)){
         System.out.println("отрицательное четное число");
     }
     else if((a < 0) && (a % 2 != 0)){
         System.out.println("отрицательное нечетное число");
     }
     else if((a == 0)){
         System.out.println("нулевое число");
     }
     else if((a > 0) && (a % 2 == 0)){
         System.out.println("положительное четное число");
     }
     else if((a > 0) && (a % 2 != 0)){
         System.out.println("положительное нечетное число");
     }
    }
}
______

package com.javarush.test.level04.lesson07.task03;

/* Положительные числа
Ввести с клавиатуры три целых числа. Вывести на экран количество положительных чисел в исходном наборе.
Пример для чисел -4 6 6:
2
Пример для чисел -6 -6 -3:
0
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String sa = reader.readLine();
     String sb = reader.readLine();
     String sc = reader.readLine();
     int a = Integer.parseInt(sa);
     int b = Integer.parseInt(sb);
     int c = Integer.parseInt(sc);
     
     if((a > 0) && (b > 0) && (c > 0)){
         System.out.println("3");
     }
     else if((a > 0) && (b > 0) && (c <= 0)){
         System.out.println("2");
     }
     else if((a > 0) && (b < 0) && (c > 0)){
         System.out.println("2");
     }
     else if((a <= 0) && (b > 0) && (c > 0)){
         System.out.println("2");
     }
     else if((a <= 0) && (b <= 0) && (c > 0)){
         System.out.println("1");
     }
     if((a <= 0) && (b > 0) && (c <= 0)){
         System.out.println("1");
     }
     else if((a > 0) && (b <= 0) && (c <= 0)){
         System.out.println("1");
     }
     else if((a <= 0) && (b <= 0) && (c <= 0)){
         System.out.println("0");
     }
     
    }
}
______

package com.javarush.test.level04.lesson07.task04;

/* Положительные и отрицательные числа
Ввести с клавиатуры три целых числа. Вывести на экран количество положительных и количество отрицательных чисел в исходном наборе,
в следующем виде:
"количество отрицательных чисел: а", "количество положительных чисел: б", где а, б - искомые значения.
Пример для чисел 2 5 6:
количество отрицательных чисел: 0
количество положительных чисел: 3
Пример для чисел -2 -5 6:
количество отрицательных чисел: 2
количество положительных чисел: 1
*/

import java.io.*;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String sa = reader.readLine();
     String sb = reader.readLine();
     String sc = reader.readLine();
     int a = Integer.parseInt(sa);
     int b = Integer.parseInt(sb);
     int c = Integer.parseInt(sc);
     
     if((a > 0) && (b > 0) && (c > 0)){
         System.out.println("количество отрицательных чисел: 0");
         System.out.println("количество положительных чисел: 3");
     }
     else if((a > 0) && (b > 0) && (c < 0)){
         System.out.println("количество отрицательных чисел: 1");
         System.out.println("количество положительных чисел: 2");
     }
     else if((a > 0) && (b < 0) && (c > 0)){
         System.out.println("количество отрицательных чисел: 1");
         System.out.println("количество положительных чисел: 2");
     }
     else if((a < 0) && (b > 0) && (c > 0)){
         System.out.println("количество отрицательных чисел: 1");
         System.out.println("количество положительных чисел: 2");
     }
     else if((a < 0) && (b < 0) && (c > 0)){
         System.out.println("количество отрицательных чисел: 2");
         System.out.println("количество положительных чисел: 1");
     }
     if((a < 0) && (b > 0) && (c < 0)){
         System.out.println("количество отрицательных чисел: 2");
         System.out.println("количество положительных чисел: 1");
     }
     else if((a > 0) && (b < 0) && (c < 0)){
         System.out.println("количество отрицательных чисел: 2");
         System.out.println("количество положительных чисел: 1");
     }
     else if((a < 0) && (b < 0) && (c < 0)){
         System.out.println("количество отрицательных чисел: 3");
         System.out.println("количество положительных чисел: 0");
     }
     
    }
}


______
package com.javarush.test.level04.lesson10.task01;

import java.io.*;

/* 10 чисел
Вывести на экран числа от 1 до 10 используя цикл while.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     int i = 1;
     while(i < 11)
     {
         System.out.println(i);
         i++;
     }

    }
}


______
package com.javarush.test.level04.lesson10.task02;

import java.io.*;

/* 10 чисел наоборот
Вывести на экран числа от 10 до 1 используя цикл while.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     int i = 10;
     while(i > 0)
     {
         System.out.println(i);
         i--;
     }
     

    }
}




BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

String name = reader.readLine();
String sAge = reader.readLine();
int nAge = Integer.parseInt(sAge);


______
public class Solution
{
    public static void main(String[] args) throws Exception
    {
      int sum = 0;
      while (sum < 10) {
        System.out.println("S" + "S" + "S" + "S" + "S" + "S" + "S" + "S" + "S" + "S");
        sum ++;  
      }
      
    }
}




______     ТАБЛ УМНОЖЕНИЯ!!!
public class Solution
{
    public static void main(String[] args) throws Exception
    {
     int allNumbers[] = {1,2,3,4,5,6,7,8,9,10};
     int w = 0;
     int q = 0;
    
     while(w<10){
         System.out.println((allNumbers[w]*1) + " " 
		 + (allNumbers[w]*2) + " " 
		 + (allNumbers[w]*3) + " " + (allNumbers[w]*4) + " " 
		 + (allNumbers[w]*5) + " " + (allNumbers[w]*6) + " " 
		 + (allNumbers[w]*7) + " " + (allNumbers[w]*8) + " " 
		 + (allNumbers[w]*9) + " " + (allNumbers[w]*10));
         w ++;
         }
         System.out.println();
     }
     
}


______
/* Четные числа
Используя цикл for вывести на экран чётные числа от 1 до 100 включительно.
Через пробел либо с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     for(int i = 2; i < 101; i = i + 2)
     {
         System.out.print(i + " ");
     }

    }
}


import java.io.*;

/* Рисуем прямоугольник
Ввести с клавиатуры два числа m и n.
Используя цикл for вывести на экран прямоугольник размером m на n из восьмёрок.
Пример: m=2, n=4
8888
8888
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String a = reader.readLine();
     String b = reader.readLine();
     int m = Integer.parseInt(a);
     int n = Integer.parseInt(b);
     
     for(int c = 1; c <= m; c++) 
     {
         for(int h = 1; h <= n; h++)
         {
         System.out.print(8);
         }
      System.out.println();     
     }
    }
}



package com.javarush.test.level04.lesson13.task03;

import java.io.*;

/* Рисуем треугольник
Используя цикл for вывести на экран прямоугольный треугольник из восьмёрок со сторонами 10 и 10.
Пример:
8
88
888
...
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        
     String row8 = "8";
     for (int i = 1; i <= 10; i++)
     {
        System.out.println(row8);
        row8 = row8 + 8;
     }
    }
}
______
package com.javarush.test.level04.lesson13.task04;

import java.io.*;

/* Рисуем линии
Используя цикл for вывести на экран:
- горизонтальную линию из 10 восьмёрок
- вертикальную линию из 10 восьмёрок.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
     String s = "8";
     String s1 = "8888888888";
     System.out.println(s1);
     for(int a = 1; a <= 10; a++){
         System.out.println("8");
     }

    }
}

______
public class Solution
{
    public static void main(String[] args) throws Exception
    {
     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

     String name = reader.readLine();
     
     for(int a = 1; a <= 10; a++){
         System.out.println(name + " любит меня.");
     }
    }
}


______
package com.javarush.test.level04.lesson16.home02;

import java.io.*;

/* Среднее такое среднее
Ввести с клавиатуры три числа, вывести на экран среднее из них. Т.е. не самое большое и не самое маленькое.
*/

public class Solution
{
    public static void main(String[] args)   throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String a = reader.readLine();
        String b = reader.readLine();
        String c = reader.readLine();
        int a1 = Integer.parseInt(a);
        int b1 = Integer.parseInt(b);
        int c1 = Integer.parseInt(c);

        if(a1 > b1 && b1 > c1){
            System.out.println(b1);
        }
        else if(b1 > a1 && a1> c1){
            System.out.println(a1);
        }
        else if(c1 > a1 && a1 > b1){
            System.out.println(a1);
        }
        else if(b1 > c1 && c1 > a1){
            System.out.println(c1);
        }
        else if(a1 > c1 && c1 > b1){
            System.out.println(c1);
        }
        else if(c1 > b1 && b1 > c1){
            System.out.println(b1);
        }
    }
}



package com.javarush.test.level04.lesson16.home03;

import java.io.*;

/* Посчитать сумму чисел
Вводить с клавиатуры числа и считать их сумму. Если пользователь ввел -1, вывести на экран сумму и завершить программу.  -1 должно учитываться в сумме.
*/

public class Solution
{
    public static void main(String[] args)   throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int sum = 0;
        for(; true; ) {
        String a1 = reader.readLine();
        int a = Integer.parseInt(a1);
        sum = sum + a;
        if (a == -1)
        { System.out.println(sum);
            break;
        }
    }
    }
}
____________________
package com.javarush.test.level05.lesson05.task01;

/* Создать класс Cat
Создать класс Cat. У кота должно быть имя (name, String), возраст (age, int), вес (weight, int), сила (strength, int).
*/

public class Cat
{
    String name;
    int age;
    int weight;
    int strength;

}
____________________
package com.javarush.test.level05.lesson05.task02;

/* Реализовать метод fight
Реализовать метод boolean fight(Cat anotherCat):
реализовать механизм драки котов в зависимости от их веса, возраста и силы.
Зависимость придумать самому. Метод должен определять, выиграли ли мы (this) бой или нет,
т.е. возвращать true, если выиграли и false - если нет.
Должно выполняться условие:
если cat1.fight(cat2) = true , то cat2.fight(cat1) = false
*/

public class Cat
{
    public String name;
    public int age;
    public int weight;
    public int strength;

    public Cat()
    {
    }

    public boolean fight(Cat anotherCat)
    {
    if((this.age > anotherCat.age) && (this.weight > anotherCat.weight) && (this.strength > anotherCat.strength)){
         return true;
         }
    else{
         return false;
         }

    }
}

____________________
/* Геттеры и сеттеры для класса Dog
Создать class Dog. У собаки должна быть кличка String name и возраст int age.
Создайте геттеры и сеттеры для всех переменных класса Dog.
*/

public class Dog {
     String name;
     int age;

    public String getName(){
    return name;
    }
    public int getAge(){
    return age;
    }
    public void setName(String name){
    this.name = name;
    }
    public void setAge(int age){
    this.age = age;
    }
     
}



package com.javarush.test.level05.lesson05.task04;

/* Создать три объекта типа Cat
В методе main создать три объекта типа Cat и заполнить их данными.
Использовать класс Cat из первой задачи. Класс Cat создавать не надо.
*/

public class Solution {
    public static void main(String[] args) {
     Cat catVaska = new Cat("Vaska", 4, 5, 10);
     Cat catBars = new Cat("Bars", 5, 6, 6);
     Cat catMr = new Cat("Mr", 4, 2, 10);
    }

    public static class Cat {

        public static int count = 0;
        private String name;
        private int age;
        private int weight;
        private int strength;

        public Cat(String name, int age, int weight, int strength) {
            count++;

            this.name = name;
            this.age = age;
            this.weight = weight;
            this.strength = strength;
        }
    }
}


package com.javarush.test.level05.lesson05.task05;

/* Провести три боя  попарно между котами
Создать три кота используя класс Cat.
Провести три боя попарно между котами.
Класс Cat создавать не надо. Для боя использовать метод boolean fight(Cat anotherCat).
Результат каждого боя вывести на экран.
*/

public class Solution {
    public static void main(String[] args) {
     
     Cat catVaska = new Cat("Vaska", 4, 5, 10);
     Cat catBars = new Cat("Bars", 5, 6, 9);
     Cat catMr = new Cat("Mr", 4, 2, 11);

     
     System.out.println(catVaska.fight(catBars));

     System.out.println(catBars.fight(catMr));

     System.out.println(catMr.fight(catBars));

     
    }
    public static class Cat {

        public static int count = 0;
        public static int fightCount = 0;

        protected String name;
        protected int age;
        protected int weight;
        protected int strength;

        public Cat(String name, int age, int weight, int strength) {
            count++;

            this.name = name;
            this.age = age;
            this.weight = weight;
            this.strength = strength;
        }

        public boolean fight(Cat anotherCat) {
            fightCount++;

            int agePlus = this.age > anotherCat.age ? 1 : 0;
            int weightPlus = this.weight > anotherCat.weight ? 1 : 0;
            int strengthPlus = this.strength > anotherCat.strength ? 1 : 0;
            
            int score = agePlus + weightPlus + strengthPlus;
            return score > 2;
            
            
        }
    }
}



/* Задача по алгоритмам

Написать программу, которая:

вводит с консоли число N > 0

потом вводит N чисел с консоли

выводит на экран максимальное из введенных N чисел. */

public class Solution

{

public static void main(String[] args) throws Exception
{
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    int N = Integer.parseInt(reader.readLine()); // вводим число
     if (N > 0)    // если оно строго больше 0 то начинаем программу
     {
         int[] list = new int[N]; // объявляю массив на N положительных чисел.
         for (int i = 0; i < list.length; i++)  
         {
             list[i] = Integer.parseInt(reader.readLine());
         }
/* в цикле присваиваю каждому элементу значение, положительное или отрицательное. без ограничений. */
         int maximum = list[0]; // максимуму присваиваю самый первый элемент.
         for (int i = 1; i < list.length; i++)
         {
             if (list[i] > maximum)
             {
                 maximum = list[i];
             }
         }
/ в цикле сверяется, больше ли элемент массива, чем максимум. Взял i=1 т.к. i=0 это и есть максимум. Его с самим с собой сравнивать нет смысла / 
         System.out.println(maximum);
     }
}


public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String sn = reader.readLine();
        int N = Integer.parseInt(sn);
        if(N>0){
            int[] list = new int[N];
            for(int i = 0; i < list.length; i++){
                list[i] = Integer.parseInt(reader.readLine());
            }
            int maximum = list[0];
            for(int i = 1; i < list.length; i++){
                if(list[i] > maximum){
                    maximum = list[i];

                    System.out.println(maximum);
                }

            }
        }
    }
}

____________________
package com.javarush.test.level05.lesson12.home05;

/* Вводить с клавиатуры числа и считать их сумму
Вводить с клавиатуры числа и считать их сумму, пока пользователь не введёт слово «сумма». Вывести на экран полученную сумму.
*/

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int sum = 0;

        while(true){
            String s = reader.readLine();
            if(s.equals("сумма"))
            {
                System.out.println(sum);
                break;
            }
            else{
                int b = Integer.parseInt(s);
                sum = sum + b;
            }

        }
    }
}

____________________
package com.javarush.test.level05.lesson12.home02;

/* Man and Woman
1. Внутри класса Solution создай public static классы Man и Woman.
2. У классов должны быть поля: name(String), age(int), address(String).
3. Создай конструкторы, в которые передаются все возможные параметры.
4. Создай по два объекта каждого класса со всеми данными используя конструктор.
5. Объекты выведи на экран в таком формате [name + " " + age + " " + address].
*/

public class Solution
{
    public static void main(String[] args)
    {


        new Man("Саша", 18, "город");
        new Woman("Даша", 19, "город1");



    }
    public static class Man
    {

        public String name;
        public int age;
        public String address;

        public Man(String name, int age, String address){

            this.name = name;
            this.age = age;
            this.address = address;

          System.out.println(name + " " + age + " " + address);
        }
    }

    public static class Woman
    {
        public String name;
        public int age;
        public String address;

        public Woman(String name, int age, String address){

            this.name = name;
            this.age = age;
            this.address = address;

            System.out.println(name + " " + age + " " + address);
        }
    }
}
____________________
package com.javarush.test.level05.lesson12.home03;

/* Создай классы Dog, Cat, Mouse
Создай классы Dog, Cat, Mouse. Добавь по три поля в каждый класс, на твой выбор. Создай объекты для героев мультика Том и Джерри. Так много, как только вспомнишь.
Пример:
Mouse jerryMouse = new Mouse(“Jerry”, 12 , 5), где 12 - высота в см, 5 - длина хвоста в см.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Mouse jerryMouse = new Mouse("Jerry", 12 , 5);
        Dog goofy = new Dog("Goofy", 12, 4);
        Cat jerry = new Cat("Jerry", 17, 7);

    }

    public static class Mouse
    {
        String name;
        int height;
        int tail;

        public Mouse(String name, int height, int tail)
        {
            this.name = name;
            this.height = height;
            this.tail = tail;
        }
    }

    public static class Cat
    {
        String name;
        int height;
        int tail;

        public Cat(String name, int height, int tail)
        {
            this.name = name;
            this.height = height;
            this.tail = tail;
        }
    }

    public static class Dog
    {
        String name;
        int height;
        int tail;

        public Dog(String name, int height, int tail)
        {
            this.name = name;
            this.height = height;
            this.tail = tail;
        }
    }

}


/**
 * Created by Кира on 17.03.2016.
 */
class Echo {

    int count = 0;

    public void hello() {
        System.out.println("hellooo...");
    }
}

    public class EchoTestDrive {

    public static void main(String[] args) {

        Echo e1 = new Echo();
        Echo e2 = new Echo();


        int x = 0;

        while (x<4) {

            e1.hello();
            e1.count = e1.count + 1;

            if (x > 0) {
                e2.count = e2.count + 1;
            }

            if (x > 1) {
                e2.count = e2.count + e1.count;
            }

            x = x + 1;
        }

        System.out.println(e2.count);
    }
    }

	____________________________________________________________________________________________________________ПРОСМОТРЕТЬ_____ЭХО___СЛОЖНА ______А ВОТ БОЛЕЕ КОРОТКОЕ И ПРАВИЛЬНОЕ РЕШЕНИЕ
	public class EchoTestDrive2 {
    public static void main(String [] args){
        Echo e1 = new Echo();
        Echo e2 = new Echo();
        int x = 0;

        while (x <  4){
            e1.hello();
            e1.count = e1.count + 1;
            if(x == 3){
                e2.count = e2.count + 1;
            }
            if(x > 0){
                e2.count = e2.count + e1.count;
            }
            x = x + 1;
        }
        System.out.println(e2.count);
    }
	
	________OUTPUT: helloooo...
	helloooo...
	helloooo...
	helloooo...
	10
	
____________________


____________________
package com.javarush.test.level06.lesson05.task02;

/* Классы Cat и Dog и метод finalize для каждого
В каждом классе Cat и Dog написать метод finalize, который выводит на экран текст о том, что такой-то объект уничтожен.
*/

 public class Cat
{
    String name;

    protected void finalize(){
        System.out.println(name + " destroyed");
    }
}
class Dog
{
    String name;

    protected void finalize(){
        System.out.println(name + " destroyed");
    }
}


package com.javarush.test.level06.lesson05.task03;

/* По 50 000 объектов Cat и Dog
Создать в цикле по 50 000 объектов Cat и Dog. (Java-машина должна начать уничтожать неиспользуемые, и метод finalize хоть раз да вызовется).
*/

public class Solution
{
    public static void main(String[] args)
    {
        for(int i = 0; i < 50000; i++){
            new Dog();
            new Cat();
        }



    }
}
class Cat
{
    @Override
    protected void finalize() throws Throwable
    {
        super.finalize();
        System.out.println("Cat destroyed");
    }
}

class Dog
{
    @Override
    protected void finalize() throws Throwable
    {
        super.finalize();
        System.out.println("Dog destroyed");
    }
}
____________________
package com.javarush.test.level06.lesson05.task04;

/* Cчётчик котов
В конструкторе класса Cat [public Cat()] увеличивать счётчик котов (статическую переменную этого же класса catCount) на 1. В методе finalize уменьшать на 1.
*/

public class Cat
{
    public static int catCount = 0;

    public Cat(){

        catCount ++;

    }

    protected void finalize() throws Throwable{
        catCount --;
    }

    public static void main(String[] args) {
    }
}


class Cat                        //класс
{
    String name;                 //переменная  

    Cat(String name)             //конструктор 
    {
        this.name = name;        //инициализация переменной 
    }
}


package com.javarush.test.level06.lesson08.task02;

/* Статические методы: int getCatCount() и setCatCount(int)
Добавить  к классу Cat два статических метода: int getCatCount() и setCatCount(int), с помощью которых можно получить/изменить количество котов (переменную catCount)
*/

public class Cat
{
    private static int catCount = 0;

    public Cat()
    {
        catCount++;
    }

    public static int getCatCount()
    {
        return catCount;

    }

    public static void setCatCount(int catCount)
    {
        Cat.catCount = catCount;

    }
}



package com.javarush.test.level06.lesson08.task04;

import java.io.BufferedReader;
import java.io.Console;
import java.io.InputStreamReader;

/* Класс ConsoleReader
Сделать класс ConsoleReader, у которого будут 4 статических метода:
String readString() – читает с клавиатуры строку
int readInt() – читает с клавиатуры число
double readDouble() – читает с клавиатуры дробное число
boolean readBoolean() – читает с клавиатуры строку "true" или "false" и возвращает соответствующую логическую переменную true или false
Внимание: создавайте переменную для чтения данных с консоли (BufferedReader или Scanner) внутри каждого метода
*/

public class ConsoleReader
{
    public static BufferedReader reader = new BufferedReader(new InputStreamReader (System.in));

    public static String readString() throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader (System.in));
        return reader.readLine();
    }

    public static int readInt() throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader (System.in));
        return Integer.parseInt(ConsoleReader.readString());

    }

    public static double readDouble() throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader (System.in));
        return Double.parseDouble(ConsoleReader.readString());

    }

    public static boolean readBoolean() throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader (System.in));
        boolean boo = true;
        String bstr = reader.readLine();
        if(bstr.equals("false"))
            return false;
        else if(bstr.equals("true"))
            return true;
        else return false;

    }
}




InputStream inputStream = System.in;
Reader inputStreamReader = new InputStreamReader(inputStream);
BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

String name = bufferedReader.readLine(); //читаем строку с клавиатуры
String sAge = bufferedReader.readLine(); //читаем строку с клавиатуры
int nAge = Integer.parseInt(sAge); //преобразовываем строку в число.
2	Более компактная запись первой части:
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

String name = reader.readLine();
String sAge = reader.readLine();
int nAge = Integer.parseInt(sAge);
3	Еще более компактная
Scanner scanner = new Scanner(System.in);
String name = scanner.nextLine();
int age = scanner.nextInt();




/* Класс StringHelper
Cделать класс StringHelper, у которого будут 2 статических метода:
String multiply(String s, int count) – возвращает строку повторенную count раз.
String multiply(String s) – возвращает строку повторенную 5 раз.
Пример:
Амиго -> АмигоАмигоАмигоАмигоАмиго
*/

public class StringHelper
{
    public static String multiply(String s)
    {
        String result = " ";
        for(int i = 0; i != 5; i++){
            result += s;
        }
        return result;
    }

    public static String multiply(String s, int count)
    {
        String result = " ";
        for(int i = 0; i != count; i++)
        {
            result += s;

        }
        return result;
    }
}


package com.javarush.test.level06.lesson08.task03;

/* Класс Util
Реализовать статический метод double getDistance(x1, y1, x2, y2). Он должен вычислять расстояние между точками.
Используй метод double Math.sqrt(double a), который вычисляет квадратный корень переданного параметра
*/

public class Util
{

    public static double getDistance(int x1, int y1, int x2, int y2)
    {
        double a = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);

        return Math.sqrt(a);


    }

}



package com.javarush.test.level07.lesson04.task03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* 2 массива
1. Создать массив на 10 строк.
2. Создать массив на 10 чисел.
3. Ввести с клавиатуры 10 строк, заполнить ими массив строк.
4. В каждую ячейку массива чисел записать длину строки из массива строк, индекс/номер ячейки которой совпадает с текущим индексом из массива чисел. Вывести содержимое массива чисел на экран, каждое значение выводить с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] list = new String[10];
        String s;
        for (int d = 0; d < 10; d++){
            s = reader.readLine();
            list[d] = s;
        }

        int[] list1 = new int[10];
        for (int t = 0; t < 10; t++){
            list1[t] = list[t].length();
            System.out.println(list1[t]);
        }

    }
}

package com.javarush.test.level07.lesson04.task05;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Один большой массив и два маленьких
1. Создать массив на 20 чисел.
2. Ввести в него значения с клавиатуры.
3. Создать два массива на 10 чисел каждый.
4. Скопировать большой массив в два маленьких: половину чисел в первый маленький, вторую половину во второй маленький.
5. Вывести второй маленький массив на экран, каждое значение выводить с новой строки.
*/



public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] list = new int[20];

        for (int i = 0; i < list.length; i++)
        {
            String s = reader.readLine();
            list[i] = Integer.parseInt(s);

        }
        int[] list1 = new int[10];

            for (int a = 0; a < list.length/2; a++)
            {
                list1[a] = list[a];

            }

        int[] list2 = new int[10];

        for (int c = list.length/2, a = 0; c<list.length; c++, a++)
        {
            list2[a] = list[c];
        }
        for (int s = 0; s<list2.length; s++)
        {
            System.out.println(list2[s]);
        }
    }
}



package com.javarush.test.level07.lesson04.task04;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Массив из чисел в обратном порядке
1. Создать массив на 10 чисел.
2. Ввести с клавиатуры 10 чисел и записать их в массив.
3. Расположить элементы массива в обратном порядке.
4. Вывести результат на экран, каждое значение выводить с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] list = new int[10];

        for(int i = 0; i < list.length; i++){
            String s = reader.readLine();
            list[i] = Integer.parseInt(s);
        }

        for(int a = list.length - 1; a >= 0; a--){

            System.out.println(list[a]);
        }

    }
}


package com.javarush.test.level06.lesson11.home06;

/* KissMyShinyMetalAss
Создай класс с именем KissMyShinyMetalAss. Создай объект этого класса, выведи его на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        KissMyShinyMetalAss ass = new KissMyShinyMetalAss();
        System.out.println(ass);
    }

        public static class KissMyShinyMetalAss
        {

        }

}



package com.javarush.test.level06.lesson11.home05;

/* Есть новые идеи? Подумаем...
1. В классе Solution создать public статический класс Idea
2. В классе Idea создать метод public String getDescription(), который будет возвращать любой непустой текст
3. В классе Solution создайте статический метод public void printIdea(Idea idea), который будет выводить
на экран описание идеи - это то, что возвращает метод getDescription
*/

public class Solution
{

    public static void printIdea(Idea idea)
    {
        System.out.print(idea.getDescription());
    }

    public static void main(String[] args)
    {
        printIdea(new Idea());
    }


    public static class Idea{

        public String getDescription()
        {
            return "fesf";
        }
    }




}


package com.javarush.test.level06.lesson11.home04;

/* Минимальное количество static-ов
Расставьте минимальное количество static-ов, чтобы код начал работать, и программа успешно завершилась
*/

public class Solution
{
    public static int step;

    public static void main(String[] args) {
        method1();
    }

    public static void method1() {
        method2();
    }


    public static void method2() {
        new Solution().method3();
    }

    public void method3() {
        method4();
    }

    public void method4() {
        step++;
        for (StackTraceElement element : Thread.currentThread().getStackTrace())
            System.out.println(element);
        if (step > 1) return;
        main(null);
    }
}


package com.javarush.test.level06.lesson11.home03;

/* Переставь один модификатор static
Переставь один модификатор static, чтобы пример скомпилировался.
*/

public class Solution
{

    public static int A = 5;
    public int B = 2;
    public int C = A*B;

    public static void main(String[] args)
    {
        A = 15;
    }

}



package com.javarush.test.level06.lesson11.home02;

import java.util.ArrayList;

/* Статические коты
1. В классе Cat добавь public статическую переменную cats (ArrayList<Cat>).
2. Пусть при каждом создании кота (нового объекта Cat) в переменную cats добавляется этот новый кот. Создать 10 объектов Cat.
3. Метод printCats должен выводить всех котов на экран. Нужно использовать переменную cats.
*/

public class Cat
{
    public Cat()
    {
        cats.add(this);
    }
    public static ArrayList<Cat> cats = new ArrayList<>();

    public static void main(String[] args)
    {

        for (int i = 0; i < 10; i++)
            new Cat();
            printCats();

    }

    public static void printCats() {

            System.out.println(cats);
        }
    }

	


	
package com.javarush.test.level06.lesson11.home01;

/* Класс Cat и статическая переменная catCount
В классе Cat создай статическую переменную public int catCount.
Создай конструктор [public Cat()]. Пусть при каждом создании кота (нового объекта Cat) статическая переменная
catCount увеличивается на 1. Создать 10 объектов Cat и вывести значение переменной catCount на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {

        Cat cat = new Cat();
        Cat cat1 = new Cat();
        Cat cat2 = new Cat();
        Cat cat3 = new Cat();
        Cat cat4 = new Cat();
        Cat cat5 = new Cat();
        Cat cat6 = new Cat();
        Cat cat7 = new Cat();
        Cat cat8 = new Cat();
        Cat cat9 = new Cat();

        System.out.println(Cat.catCount);

    }


    public static class Cat
    {
        public static int catCount = 0;

        public Cat()
        {
            Cat.catCount++;
        }
    }
}


package com.javarush.test.level07.lesson06.task01;

import java.util.ArrayList;

/* 5 различных строчек в списке
1. Создай список строк.
2. Добавь в него 5 различных строчек.
3. Выведи его размер на экран.
4. Используя цикл выведи его содержимое на экран, каждое значение с новой строки.
*/
public class Solution
{
    public static void main(String[] args) throws Exception
    {
        ArrayList<String> list = new ArrayList<String>();

        String a = "daw";
        String b = "dwada";
        String c = "dwadaa";
        String d = "dawgawfwa";
        String e = "Da";



        list.add(0, a);
        list.add(1, b);
        list.add(2, c);
        list.add(3, d);
        list.add(4, e);

        int n = list.size();

        System.out.println(n);

        for(int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }


    }
}



package com.javarush.test.level07.lesson06.task01;

import java.util.ArrayList;

/* 5 различных строчек в списке
1. Создай список строк.
2. Добавь в него 5 различных строчек.
3. Выведи его размер на экран.
4. Используя цикл выведи его содержимое на экран, каждое значение с новой строки.
*/
public class Solution
{
    public static void main(String[] args) throws Exception
    {
        ArrayList<String> list = new ArrayList<String>();

        String a = "daw";
        String b = "dwada";
        String c = "dwadaa";
        String d = "dawgawfwa";
        String e = "Da";



        list.add(0, a);
        list.add(1, b);
        list.add(2, c);
        list.add(3, d);
        list.add(4, e);

        int n = list.size();

        System.out.println(n);

        for(int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }


    }
}


package com.javarush.test.level07.lesson06.task02;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Самая длинная строка
1. Создай список строк.
2. Считай с клавиатуры 5 строк и добавь в список.
3. Используя цикл, найди самую длинную строку в списке.
4. Выведи найденную строку на экран.
5. Если таких строк несколько, выведи каждую с новой строки.
*/
public class Solution {
    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();

        for (int i = 0; i < 5; i++) {

            list.add(reader.readLine());
        }
        int max = list.get(0).length();

        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).length() > max) {
                max = list.get(i).length();
            }

            }
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).length() == max) {
                System.out.println(list.get(i));
            }
        }
    }
	



package com.javarush.test.level07.lesson06.task03;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Самая короткая строка
1. Создай список строк.
2. Считай с клавиатуры 5 строк и добавь в список.
3. Используя цикл, найди самую короткую строку в списке.
4. Выведи найденную строку на экран.
5. Если таких строк несколько, выведи каждую с новой строки.
*/
public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();

        for (int i = 0; i < 5; i++) {

            list.add(reader.readLine());
        }
        int min = list.get(0).length();

        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).length() < min) {
                min = list.get(i).length();
            }

        }
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).length() == min) {
                System.out.println(list.get(i));
            }
        }
    }
}


package com.javarush.test.level07.lesson06.task04;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* 10 строчек в начало списка
1. Создай список строк в методе main.
2. Добавь в него 10 строчек с клавиатуры, но только добавлять не в конец списка, а в начало.
3. Используя цикл выведи содержимое на экран, каждое значение с новой строки.
*/
public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();

        for (int i = 0; i < 10; i++) {

            list.add(0, reader.readLine());

        }

        for (int i = 0; i < list.size(); i++) {
                System.out.println(list.get(i));
            }
        }
}


package com.javarush.test.level07.lesson06.task05;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Удали последнюю строку и вставь её в начало
1. Создай список строк.
2. Добавь в него 5 строчек с клавиатуры.
3. Удали последнюю строку и вставь её в начало. Повторить 13 раз.
4. Используя цикл выведи содержимое на экран, каждое значение с новой строки.
*/
public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();

        for (int i = 0; i < 5; i++) {

            list.add(reader.readLine());

        }

        for (int i = 0; i < 13; i++) {
            String s = list.get(4);
            list.remove(s);
            list.add(0, s);
        }
        for (int i = 0; i < 5; i++){
            System.out.println(list.get(i));
        }

    }
}



- Давай-ка я начну с действительно полезных вещей. Сейчас ты увидишь несколько полезных примеров работы с ArrayList и Generics:

- Пример 1:

Ввод списка целых чисел с клавиатуры
	
public static void main(String[] args) throws IOException
{
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in) );
    ArrayList<Integer> list = new ArrayList<Integer>();

    while (true)
    {
        String s = reader.readLine();
        if (s.isEmpty()) break;
        list.add(Integer.parseInt(s));
    }
}
- Пример 2:

То же, чётные числа добавляются в конец списка, нечётные – в начало.
	
public static void main(String[] args) throws IOException
{
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    ArrayList<Integer> list = new ArrayList<Integer>();

    while (true)
    {
        String s = reader.readLine();
        if (s.isEmpty()) break;

        int x = Integer.parseInt(s);
        if (x % 2 == 0)  //проверяем, что остаток от деления на два равен нулю
            list.add(x);          //добавление в конец
        else
            list.add(0, x);      //вставка в начало      
    }
}
- Пример 3:

Удаление всех чисел больше 5:
	
public static void main(String[] args) throws IOException
{
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in) );
    ArrayList<Integer> list = new ArrayList<Integer>();

    list.add(1);
    list.add(7);
    list.add(11);
    list.add(3);
    list.add(15);

    for (int i = 0; i < list.size(); )  //убрали увеличение i внутрь цикла
    {
        if (list.get(i) > 5)
            list.remove(i);  //не увеличиваем i, если удалили текущий  элемент  
        else
            i++;
    }
}
- Пример 4:

Разделение массива на два – чётных и нечётных чисел
	
public static void main(String[] args) throws IOException
{
    //статическая инициализация массива
    int[] data = {1, 5, 6, 11, 3, 15, 7, 8};  

    //создание списка, где все элементы должны быть типа Integer 
    ArrayList<Integer> list = new ArrayList<Integer>();   

    //заполнение списка из массива
    for (int i = 0; i < data.length; i++) list.add(data[i]);  

    ArrayList<Integer> even = new ArrayList<Integer>();  //чётные
    ArrayList<Integer> odd = new ArrayList<Integer>();    //нечётные

    for (int i = 0; i < list.size(); i++)
    {
        Integer x = list.get(i);
        if (x % 2 == 0)    //если x - чётное
            even.add(x);   // добавляем x в коллекцию четных чисел  
        else
            odd.add(x);    // добавляем x в коллекцию нечетных чисел
    }
}
- Пример 5:

Слияние списков.
	
public static void main(String[] args) throws IOException
{
    ArrayList<Integer> list1 = new ArrayList<Integer>();   //создание списка  
    Collections.addAll(list1, 1, 5, 6, 11, 3, 15, 7, 8);   //заполнение списка

    ArrayList<Integer> list2 = new ArrayList<Integer>();
    Collections.addAll(list2, 1, 8, 6, 21, 53, 5, 67, 18);

    ArrayList<Integer> result = new ArrayList<Integer>();

    result.addAll(list1);   //добавление всех значений из одного списка в другой
    result.addAll(list2);

    for (Integer x : result)   //быстрый for по всем элементам, только для коллекций
    {
        System.out.println(x);
    }
}



package com.javarush.test.level07.lesson09.task01;


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Три массива
1. Введи с клавиатуры 20 чисел, сохрани их в список и рассортируй по трём другим спискам:
Число делится на 3 (x%3==0), делится на 2 (x%2==0) и все остальные.
Числа, которые делятся на 3 и на 2 одновременно, например 6, попадают в оба списка.
2. Метод printList должен выводить на экран все элементы списка с новой строки.
3. Используя метод printList выведи эти три списка на экран. Сначала тот, который для x%3, потом тот, который для x%2, потом последний.
*/

public class Solution {

    public static void main(String[] args) throws Exception {

        ArrayList<Integer> list = new ArrayList<Integer>();

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<Integer> list3 = new ArrayList<Integer>();
        ArrayList<Integer> list2 = new ArrayList<Integer>();
        ArrayList<Integer> list1 = new ArrayList<Integer>();


        for (int i = 0; i < 20; i++) {
            String s = reader.readLine();
            list.add(Integer.parseInt(s));
        }

        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) % 3 == 0)
                list3.add(list.get(i));
            if (list.get(i) % 2 == 0)
                list2.add(list.get(i));
            if (list.get(i) % 3 != 0 && list.get(i) % 2 != 0) {
                list1.add(list.get(i));
            }
        }

            printList(list3);
            printList(list2);
            printList(list1);
        }

    public static void printList(List<Integer> list) {
        for (int i = 0; i < list.size(); i++) {

            System.out.println(list.get(i));

        }
    }
}




package com.javarush.test.level07.lesson09.task02;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Слова в обратном порядке
Введи с клавиатуры 5 слов в список строк. Удали 3 - ий элемент списка, и выведи оставшиеся элементы в обратном порядке.
*/

public class Solution {
    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<>();

        for (int i = 0; i < 5; i++) {
            list.add(reader.readLine());

        }
        list.remove(2);
        for (int a = list.size() - 1; a >= 0; a--) {

            System.out.println(list.get(a));
        }
    }
}



package com.javarush.test.level07.lesson09.task03;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;

/* Слово «именно»
1. Создай список из слов «мама», «мыла», «раму».
2. После каждого слова вставь в список строку, содержащую слово «именно».
3. Используя цикл for вывести результат на экран, каждый элемент списка с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        ArrayList<String> list = new ArrayList<>();

        Collections.addAll(list, "мама", "мыла", "раму");


        for(int i = 1; i < list.size() + 1; i += 2){
            list.add(i, "именно");
        }
        for(int i = 0; i < list.size(); i++){
            System.out.println(list.get(i));
        }

    }
}


package com.javarush.test.level07.lesson09.task04;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Буква «р» и буква «л»
1. Создай список слов, заполни его самостоятельно.
2. Метод fix должен:
2.1. удалять из списка строк все слова, содержащие букву «р»
2.2. удваивать все слова содержащие букву «л».
2.3. если слово содержит и букву «р» и букву «л», то оставить это слово без изменений.
2.4. с другими словами ничего не делать.
Пример:
роза
лира
лоза
Выходные данные:
лира
лоза
лоза
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader bis = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();

        for (int i = 0; i < 4; i++) {
            String s = bis.readLine();
            list.add(s);
        }
        list.add("роза"); //0
        list.add("лира"); //1
        list.add("лоза"); //2
        list = fix(list);

        for (String s : list) {
            System.out.println(s);
        }
    }

    public static ArrayList<String> fix(ArrayList<String> list) {
        for (int i = 0; i < list.size(); i++) {
            if (!(list.get(i).matches("^.*(л.*р|р.*л).*$"))) {
                if (list.get(i).matches("^.*р.*$")) {
                    list.remove(list.get(i));
                    i--;
                } else if (list.get(i).matches("^.*л.*$")) {
                    list.add(i, list.get(i));
                    i++;
                }
            }
        }
        return list;
    }
}



package com.javarush.test.level07.lesson09.task05;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Удвой слова
1. Введи с клавиатуры 10 слов в список строк.
2. Метод doubleValues должен удваивать слова по принципу a,b,c -> a,a,b,b,c,c.
3. Используя цикл for выведи результат на экран, каждое значение с новой строки.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        ArrayList<String> list = new ArrayList<String>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        for (int i = 0; i < 10; i++) {
            list.add(reader.readLine());
        }
        ArrayList<String> result = doubleValues(list);
        for (int i = 0; i < result.size(); i++) {
            System.out.println(result.get(i));
        }
    }

    public static ArrayList<String> doubleValues(ArrayList<String> list2) {
        for (int i = 0; i < list2.size(); i++) {
            list2.set(i, list2.get(i));
        }
        for (int i = 0; i < list2.size(); i+=2) {
            list2.add(i + 1, list2.get(i));
        }
        return list2;
    }
}

____________________(1-e решение)
package com.javarush.test.level07.lesson12.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Задача по алгоритмам
Задача: Написать программу, которая вводит с клавиатуры 20 чисел и выводит их в убывающем порядке.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] array = new int[20];
        for (int i = 0; i < 20; i++) {
            array[i] = Integer.parseInt(reader.readLine());
        }

        sort(array);

    }

    public static void sort(int[] array) {
        for (int a = array.length - 1; a >= 0; a--) {

            System.out.println(array[a]);
        }
    }

}

/**
 * Created by Кира on 23.03.2016.
 */
public class Hobbits {
    String name;

    public static void main(String[] args)throws Exception
    {

        Hobbits[] h = new Hobbits[3];
        int z = -1;

        while (z<2){
            z = z+1;
            h[z] = new Hobbits();
                h[z].name = "Бильбо";
            if(z == 1) {
                h[z].name = "Сэм";
            }
            if(z == 2) {
                h[z].name = "Фродо";
            }
            System.out.print(h[z].name + " - ");
            System.out.println("имя хорошего хобита");
        }
    }
}

package HeadsFirst;

/**
 * Created by Кира on 23.03.2016.
 */


public class Trianlgle {

    public double area;
    public int height;
    public int length;

    public static void main(String[] args) {

            Triangle[] ta = new Triangle[4];
            int x = 0;

            while (x < 4) {
                ta[x] = new Triangle();
                ta[x].height = (x+1)*2;
                ta[x].length = x + 4;
                ta[x].setArea();
                System.out.print("треугольник "+x+" , зона");
                System.out.println(" = " + ta[x].area);
                x = x + 1;
            }
        int y = x;
        x = 27;
        Triangle t5 = ta[2];
        ta[2].area = 343;
        System.out.print("y = " + y);
        System.out.println(", зона t5 = "+t5.area);
        }
    public void setArea(){
        area = (height * length) / 2;
    }
}



public class Puzzle4 {
    public static void main(String[] args) {
        Puzzle4b[] obs = new Puzzle4b[6];

        int y = 1;
        int x = 0;
        int result = 0;
        while (x < 6) {

            obs[x] = new Puzzle4b();
            obs[x].ivar = y;
            y = y * 10;
            x = x+1;
        }

        x = 6;
        while (x > 0) {

            x = x -1;

            result = result + obs[x].doStuff(x);
        }
        System.out.println("Результат " + result);
    }
}
class Puzzle4b {
        int ivar;

    public int doStuff(int factor) {
        if (ivar > 100){
            return ivar*factor;
        }
        else{
            return ivar*(5-factor);
        }

    }


}


Вывод на экран элементов Set
	
public static void main(String[] args)
{
    Set<String> set = new HashSet<String>();
    set.add("Mama");
    set.add("Mila");
    set.add("Ramu");

    //получение итератора для множества
    Iterator<String> iterator = set.iterator();

    while (iterator.hasNext())        //проверка, есть ли ещё элементы   
    {
        //получение текущего элемента и переход на следующий
        String text = iterator.next();

        System.out.println(text);
    }
}
	Вывод на экран элементов List
public static void main(String[] args)
{
    List<String> list = new ArrayList<String>();
    list.add("Mama");
    list.add("Mila");
    list.add("Ramu");

    Iterator<String> iterator = list.iterator();//получение итератора для списка

    while (iterator.hasNext())      //проверка, есть ли ещё элементы   
    {
        //получение текущего элемента и переход на следующий
        String text = iterator.next();

        System.out.println(text);
    }
}
	Вывод на экран элементов Map
public static void main(String[] args)
{
    //все элементы хранятся в парах
    Map<String, String> map = new HashMap<String, String>();
    map.put("first", "Mama");
    map.put("second", "Mila");
    map.put("third", "Ramu");

    Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();

    while (iterator.hasNext())
    {
        //получение «пары» элементов
        Map.Entry<String, String> pair = iterator.next();
        String key = pair.getKey();            //ключ
        String value = pair.getValue();        //значение
        System.out.println(key + ":" + value);
    }
}



public static void main(String[] args)
{
  Set<String> set = new HashSet<String>();
  set.add("Mama");
  set.add("Mila");
  set.add("Ramu");

  Iterator<String> iterator = set.iterator();
  while (iterator.hasNext())
  {
    String text = iterator.next();
    System.out.println(text);
  }
}
СОКРАЩЕННАЯ ЗАПИСЬ
public static void main(String[] args)
{
    Set<String> set = new HashSet<String>();
    set.add("Mama");
    set.add("Mila");
    set.add("Ramu");

    for (String text : set)   
    {
        System.out.println(text);
    }
}
________________________PUZZLE
package HeadsFirst;

/**
 * Created by Кира on 31.03.2016.
 */
public class Puzzle4 {
    public static void main(String[] args) {
        Puzzle4b[] obs = new Puzzle4b[6];

        int y = 1;
        int x = 0;
        int result = 0;
        while (x < 6) {

            obs[x] = new Puzzle4b();
            obs[x].ivar = y;
            y = y * 10;
            x = x+1;
        }

        x = 6;
        while (x > 0) {

            x = x -1;

            result = result + obs[x].doStuff(x);
        }
        System.out.println("Результат " + result);
    }
}
class Puzzle4b {
        int ivar;

    public int doStuff(int factor) {
        if (ivar > 100){
            return ivar*factor;
        }
        else{
            return ivar*(5-factor);
        }

    }


}


package com.javarush.test.level08.lesson03.task02;

/* HashMap из 10 пар
Создать коллекцию HashMap<String, String>, занести туда 10 пар строк:
арбуз - ягода, банан - трава, вишня - ягода, груша - фрукт, дыня - овощ, ежевика - куст, жень-шень - корень, земляника - ягода, ирис - цветок, картофель - клубень.
Вывести содержимое коллекции на экран, каждый элемент с новой строки.
Пример вывода (тут показана только одна строка):
картофель - клубень
*/

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        Map<String, String> map = new HashMap<String, String>();
        map.put("арбуз", "ягода");
        map.put("банан", "трава");
        map.put("вишня", "ягода");
        map.put("груша", "фрукт");
        map.put("дыня", "овощ");
        map.put("ежевика", "куст");
        map.put("жень-шень", "корень");
        map.put("земляника", "ягода");
        map.put("ирис", "цветок");
        map.put("картофель", "клубень");


        for (Map.Entry<String, String> pair : map.entrySet()) {
            String key = pair.getKey();
            String value = pair.getValue();
            System.out.println(key + " - " + value);
        }

    }
}



package com.javarush.test.level08.lesson03.task03;

import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

/* Коллекция HashMap из котов
Есть класс Cat с полем имя (name, String).
Создать коллекцию HashMap<String, Cat>.
Добавить в коллекцию 10 котов, в качестве ключа использовать имя кота.
Вывести результат на экран, каждый элемент с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        String[] cats = new String[] {"васька", "мурка", "дымка", "рыжик", "серый", "снежок", "босс", "борис", "визя", "гарфи"};

        HashMap<String, Cat> map = addCatsToMap(cats);

        for (Map.Entry<String, Cat> pair : map.entrySet())
        {
            System.out.println(pair.getKey() + " - " + pair.getValue());
        }
    }


    public static HashMap<String, Cat> addCatsToMap(String[] cats)
    {
        HashMap<String, Cat> cat1 = new HashMap<String, Cat>();
        for (int i = 0; i < cats.length; i++)
        {
            cat1.put(cats[i], new Cat(cats[i]));
        }
        return cat1;
    }



    public static class Cat
    {
        String name;

        public Cat(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name != null ? name.toUpperCase() : null;
        }
    }
}


package com.javarush.test.level08.lesson03.task04;

import java.util.HashMap;
import java.util.Map;

/* Вывести на экран список ключей
Есть коллекция HashMap<String, String>, туда занесли 10 различных строк. Вывести на экран список ключей, каждый элемент с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        HashMap<String, String> map = new HashMap<String, String>();


        map.put("Sim", "Sim");
        map.put("Tom", "Tom");
        map.put("Arbus", "Arbus");
        map.put("Baby", "Baby");
        map.put("Cat", "Cat");
        map.put("Dog", "Dog");
        map.put("Eat", "Eat");
        map.put("Food", "Food");
        map.put("Gevey", "Gevey");
        map.put("Hugs", "Hugs");

        printKeys(map);
    }

    public static void printKeys(Map<String, String> map)
    {
            for (Map.Entry<String, String> pair : map.entrySet()) {
                System.out.println(pair.getKey());
            }
    }
}



package com.javarush.test.level08.lesson03.task05;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Вывести на экран список значений
Есть коллекция HashMap<String, String>, туда занесли 10 различных строк.
Вывести на экран список значений, каждый элемент с новой строки.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put("Sim", "Sim");
        map.put("Tom", "Tom");
        map.put("Arbus", "Arbus");
        map.put("Baby", "Baby");
        map.put("Cat", "Cat");
        map.put("Dog", "Dog");
        map.put("Eat", "Eat");
        map.put("Food", "Food");
        map.put("Gevey", "Gevey");
        map.put("Hugs", "Hugs");

        printValues(map);
    }

    public static void printValues(Map<String, String> map)
    {
        for (Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<String, String> pair = iterator.next();
            System.out.println(pair.getValue());
        }
    }

}

package com.javarush.test.level08.lesson03.task06;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;

/* Коллекция HashMap из Object
Есть коллекция HashMap<String, Object>, туда занесли 10 различных пар объектов.
Вывести содержимое коллекции на экран, каждый элемент с новой строки.
Пример вывода (тут показана только одна строка):
Sim - 5
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("Sim", 5);
        map.put("Tom", 5.5);
        map.put("Arbus", false);
        map.put("Baby", null);
        map.put("Cat", "Cat");
        map.put("Eat", new Long(56));
        map.put("Food", new Character('3'));
        map.put("Gevey", '6');
        map.put("Hugs", 111111111111L);
        map.put("Comp", (double) 123);

        for (Iterator<Map.Entry<String, Object>> iterator = map.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<String, Object> pair = iterator.next();
            System.out.println(pair.getKey() + " - " + pair.getValue());

        }
    }
}



package com.javarush.test.level07.lesson12.home01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Вывести числа в обратном порядке
Ввести с клавиатуры 10 чисел и заполнить ими список.
Вывести их в обратном порядке.
Использовать только цикл for.
*/

public class Solution
{
    public static void main(String[] args) throws IOException
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<Integer> list = new ArrayList<Integer>();

        for(int i = 0; i < 10; i++){
            String s = reader.readLine();
            list.add(i, Integer.parseInt(s));
        }

        for(int a = list.size() - 1; a >= 0; a--){

            System.out.println(list.get(a));
        }

    }
}

package com.javarush.test.level07.lesson12.home02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


/* Переставить M первых строк в конец списка
Ввести с клавиатуры 2 числа N  и M.
Ввести N строк и заполнить ими список.
Переставить M первых строк в конец списка.
Вывести список на экран, каждое значение с новой строки.
*/

public class Solution {
    public static void main(String[] args) throws IOException {
        {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            int n = Integer.parseInt(reader.readLine());
            int m = Integer.parseInt(reader.readLine());
            ArrayList<String> list = new ArrayList<String>();
            for (int i = 0; i < n; i++) {
                list.add(reader.readLine());
            }
            for (int i = 0; i < m; i++) {
                list.add(list.remove(0));
            }
            for (String s : list) {
                System.out.println(s);
            }
        }
    }
	
	
	
	package com.javarush.test.level07.lesson12.home03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Максимальное и минимальное числа в массиве
Создать массив на 20 чисел. Заполнить его числами с клавиатуры. Найти максимальное и минимальное числа в массиве.
Вывести на экран максимальное и минимальное числа через пробел.
*/

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int maximum;
        int minimum;

        ArrayList<Integer> list = new ArrayList<Integer>();

            for (int i = 0; i < 20; i++) {
                list.add(Integer.parseInt(reader.readLine()));
            }
        maximum = list.get(1);
        minimum = list.get(1);
        for (int i = 0; i < list.size(); i++)
        {
            if (minimum > list.get(i))
            {
                minimum = list.get(i);
            }
            if (maximum < list.get(i))
            {
                maximum = list.get(i);
            }
        }
        System.out.print(maximum + " ");
        System.out.println(minimum);

    }
}
}






package com.javarush.test.level07.lesson12.home04;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Вводить с клавиатуры строки, пока пользователь не введёт строку 'end'
Создать список строк.
Ввести строки с клавиатуры и добавить их в список.
Вводить с клавиатуры строки, пока пользователь не введёт строку "end".  "end" не учитывать.
Вывести строки на экран, каждую с новой строки.
*/

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();
        while (true) {
            String s = reader.readLine();
            if (s.equals("end")) {
                break;
            }
            else{
            list.add(s);
            }
        }
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}




package com.javarush.test.level07.lesson12.home05;

/* Бум
Написать программу, которая ведёт обратный отсчёт с 30 до 0, и в конце выводит на экран текст «Бум!». Программа должна уменьшать число 10 раз в секунду. Для того чтобы вставить в программу задержку, воспользуйся функцией:
Thread.sleep(100); //задержка на одну десятую секунды.
Пример:
30
29
…
1
0
Бум!
*/

public class Solution
{
    public static void main(String[] args) throws InterruptedException {
        for (int i=30;i>=0;i--)
        {
            System.out.println(i);

            Thread.sleep(100);
        }

        System.out.println("Бум!");
    }
}





package com.javarush.test.level07.lesson12.home06;

/* Семья
Создай класс Human с полями имя(String), пол(boolean),возраст(int), отец(Human), мать(Human). Создай объекты и заполни их так, чтобы получилось: Два дедушки, две бабушки, отец, мать, трое детей. Вывести объекты на экран.
Примечание:
Если написать свой метод String toString() в классе Human, то именно он будет использоваться при выводе объекта на экран.
Пример вывода:
Имя: Аня, пол: женский, возраст: 21, отец: Павел, мать: Катя
Имя: Катя, пол: женский, возраст: 55
Имя: Игорь, пол: мужской, возраст: 2, отец: Михаил, мать: Аня
…
*/

import java.util.ArrayList;
import java.util.Collections;

public class Solution
{
    public static void main(String[] args)
    {

        ArrayList<Human> list = new ArrayList<Human>();
        Human grandFather1 = new Human("Bob", true, 95, null, null);
        Human grandFather2 = new Human("bab", true, 94, null, null);
        Human grandMother1 = new Human("Bgb", false, 92, null, null);
        Human grandMother2 = new Human("gfd", false, 91, null, null);
        Human father = new Human("Fadaw", true, 43, grandFather1, grandMother1);
        Human mother = new Human("Fadwa", false, 43, grandFather2, grandMother2);
        Human child1 = new Human("Fat", false, 33, father, mother);
        Human child2 = new Human("Fadawdaw", true, 23, father, mother);
        Human child3 = new Human("Ghdh", true, 13, father, mother);

        Collections.addAll(list, grandFather1, grandFather2, grandMother1, grandMother2, father, mother, child1, child2, child3);
        for (int i = 0; i < list.size(); i++)
            System.out.println(list.get(i));

    }

    public static class Human
    {
        String name;
        boolean sex;
        int age;
        Human father;
        Human mother;

        Human(String name, boolean sex, int age, Human father, Human mother){
            this.name = name;
            this.sex = sex;
            this.age = age;
            this.father = father;
            this.mother = mother;
        }

        public String toString()
        {
            String text = "";
            text += "Имя: " + this.name;
            text += ", пол: " + (this.sex ? "мужской" : "женский");
            text += ", возраст: " + this.age;

            if (this.father != null)
                text += ", отец: " + this.father.name;

            if (this.mother != null)
                text += ", мать: " + this.mother.name;

            return text;


        }

    }

}


package com.javarush.test.level05.lesson12.bonus03;

import java.io.*;

/* Задача по алгоритмам
Написать программу, которая:
1. вводит с консоли число N > 0
2. потом вводит N чисел с консоли
3. выводит на экран максимальное из введенных N чисел.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int maximum;

        int n = Integer.parseInt(reader.readLine());
        if (n > 0) {
            int first = Integer.parseInt(reader.readLine());
            for (int i = 1; i <= n - 1; i++) {
                int w = Integer.parseInt(reader.readLine());
                if (w > first) {
                    first = w;
                }
            }
            maximum = first;
            System.out.print(maximum);
        }
    }
}


СКОЛЬКО ПРОШЛО ВРЕМЕНИ С НАЧАЛА ТЕКУЩЕГО ДНЯ
package HeadsFirst;

import java.util.Date;

/**
 * Created by Кира on 08.04.2016.
 */
public class TImeFrom {
    public static void main(String[] args) throws Exception
    {
        Date currentTime = new Date();
        int hours = currentTime.getHours();
        int mins = currentTime.getMinutes();
        int secs = currentTime.getSeconds();

        System.out.println("Time from midnight " + hours + ":" + mins + ":" + secs);
    }
}


СКОЛЬКО ПРОШЛО ДНЕЙ С НАЧАЛА ГОДА
package HeadsFirst;

import java.util.Date;

/**
 * Created by Кира on 08.04.2016.
 */
public class DaysFrom {
    public static void main(String[] args) throws Exception
    {
        Date yearStartTime = new Date();
        yearStartTime.setHours(0);
        yearStartTime.setMinutes(0);
        yearStartTime.setSeconds(0);

        yearStartTime.setDate(1);
        yearStartTime.setMonth(0);

        Date currentTime = new Date();
        long msTimeDistance = FcurrentTime.getTime() - yearStartTime.getTime();
        long msDay = 24 * 60 * 60 * 1000;

        int dayCount = (int) (msTimeDistance/msDay);
        System.out.println("Days from start of year: " + dayCount);
    }
}




package com.javarush.test.level08.lesson06.task02;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/* Провести 10 тысяч вставок, удалений
Для arrayList и linkedList провести 10 тысяч вставок, удалений, а также вызовов get и set.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        // ArrayList
        ArrayList arrayList = new ArrayList();
        insert10000(arrayList);
        get10000(arrayList);
        set10000(arrayList);
        remove10000(arrayList);

        // LinkedList
        LinkedList linkedList = new LinkedList();
        insert10000(linkedList);
        get10000(linkedList);
        set10000(linkedList);
        remove10000(linkedList);
    }

    public static void insert10000(List list)
    {
        for(int i = 0; i<10000; i++){
            list.add(new Object());
        }

    }

    public static void get10000(List list)
    {
        for(int i = 0; i<10000; i++){
            list.get(i);
        }

    }

    public static void set10000(List list)
    {
        for(int i = 0; i<10000; i++){
            list.set(i, new Object());
        }

    }

    public static void remove10000(List list)
    {
        for(int i = 0; i<10000; i++){
            list.remove(0);
        }

    }
}




package com.javarush.test.level08.lesson06.task02;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

/* Провести 10 тысяч вставок, удалений
Для arrayList и linkedList провести 10 тысяч вставок, удалений, а также вызовов get и set.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        Date start = new Date();
        ArrayList arrayList = new ArrayList();
        insert10000(arrayList);
        get10000(arrayList);
        set10000(arrayList);
        remove10000(arrayList);
        Date end = new Date();
        int time = (int) (end.getTime() - start.getTime());
        System.out.println("arrayList shows the next result: " + time);
        // LinkedList
        Date start2 = new Date();
        LinkedList linkedList = new LinkedList();
        insert10000(linkedList);
        get10000(linkedList);
        set10000(linkedList);
        remove10000(linkedList);
        Date end2 = new Date();
        int time2 = (int) (end2.getTime() - start2.getTime());
        System.out.println("LinkedList shows the next result: " + time2);
    }
    public static void insert10000(List list)
    {
        //напишите тут ваш код
        for (int i = 0; i < 10000; i++)
            list.add(new Object());
    }
    public static void get10000(List list)
    {
        //напишите тут ваш код
        for (int i = 0; i < 10000; i++)
            list.get(i);
    }
    public static void set10000(List list)
    {
        //напишите тут ваш код
        for (int i = 0; i < 10000; i++)
            list.set(i, new Object());
    }
    public static void remove10000(List list)
    {
        //напишите тут ваш код
        for (int i = 0; i < 10000; i++)
            list.remove(0);
    }
}



package com.javarush.test.level08.lesson06.task03;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

/* Измерить сколько времени занимает 10 тысяч вставок для каждого списка
Измерить, сколько времени занимает 10 тысяч вставок для каждого списка.
Метод getTimeMsOfInsert  должен вернуть время его исполнения в миллисекундах.
*/

public class Solution
{
    public static void main(String[] args)
    {
        System.out.println(getTimeMsOfInsert(new ArrayList()));
        System.out.println(getTimeMsOfInsert(new LinkedList()));
    }

    public static long  getTimeMsOfInsert(List list)
    {
        Date start = new Date();

        insert10000(list);

        Date end = new Date();
        int time = (int) (end.getTime() - start.getTime());

        return time;
    }

    public static void insert10000(List list)
    {
        for (int i=0;i<10000;i++)
        {
            list.add(0, new Object());
        }
    }
}


package com.javarush.test.level08.lesson06.task04;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

/* Измерить сколько времени занимает 10 тысяч вызовов get для каждого списка
Измерить, сколько времени занимает 10 тысяч вызовов get для каждого списка.
Метод getTimeMsOfGet  должен вернуть время его исполнения в миллисекундах.
*/

public class Solution
{
    public static void main(String[] args)
    {
        System.out.println(getTimeMsOfGet(fill(new ArrayList())));
        System.out.println(getTimeMsOfGet(fill(new LinkedList())));
    }

    private static List fill(List list)
    {
        for(int i = 0; i < 11; i++)
        {
            list.add(new Object());
        }
        return list;
    }

    public static long  getTimeMsOfGet(List list)
    {
        Date start = new Date();

        get10000(list);

        Date end = new Date();
        int time = (int) (end.getTime() - start.getTime());

        return time;

    }

    public static void get10000(List list)
    {
        if (list.isEmpty()) return;
        int x = list.size() / 2;

        for (int i = 0; i < 10000; i++)
        {
            list.get(x);
        }
    }
}


package com.javarush.test.level08.lesson06.task05;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/* Четыре метода
Реализовать 4 метода. Они должны возвращать список, который лучше всего подходит для выполнения данных операций (быстрее всего справится с большим количеством операций). Ничего измерять не нужно.
*/

public class Solution
{
    public static List  getListForGet()
    {
        return new ArrayList();

    }

    public static List  getListForSet()
    {
        return new ArrayList();

    }

    public static List  getListForAddOrInsert()
    {
        return new LinkedList();

    }

    public static List  getListForRemove()
    {
        return new LinkedList();

    }
}



package com.javarush.test.level08.lesson08.task01;

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/* 20 слов на букву «Л»
Создать множество строк (Set<String>), занести в него 20 слов на букву «Л».
*/

public class Solution {
    public static void main(String[] args) {
    }

    Set<String> set = createSet();

    public static HashSet<String> createSet() {

        HashSet<String> set = new HashSet<>();

        for (int i = 0; i < 20; i++) {

            set.add("Ложь");
            set.add("Ложка");
            set.add("Лес");
            set.add("Лор");
            set.add("Лёgrsха");
            set.add("Лёхка");
            set.add("Лёхпа");
            set.add("Лёиха");
            set.add("Лёмха");
            set.add("Лёдха");
            set.add("Лёха");
            set.add("Лёяха");
            set.add("Лсёха");
            set.add("Лёчсха");
            set.add("Лёмсха");
            set.add("Лёчсмха");
            set.add("Лёчясмха");
            set.add("Лёчсмчсмха");
            set.add("Лёячсмячсмха");
            set.add("Лёчясмячсмячсмячсха");
        }

        return set;
    }
}



public class Solution
{
    public static HashSet<Integer> createSet()
    {

        HashSet<Integer> set = new HashSet<Integer>();
        for (int i = 0; i < 20 ; i++)
        {
            set.add(i);
        }
        return  set;
    }
    public static HashSet<Integer> removeAllNumbersMoreThan10(HashSet<Integer> set)
    {

        Iterator<Integer> iterator = set.iterator();
        while (iterator.hasNext())
        {
            int item = iterator.next();
            if (item > 10)
                iterator.remove();
        }
        return set;
    }
    public static void main(String[] args)
    {
        System.out.println(removeAllNumbersMoreThan10(createSet()));
    }
}




package com.javarush.test.level08.lesson08.task03;

import java.util.HashMap;
import java.util.Iterator;

/* Одинаковые имя и фамилия
Создать словарь (Map<String, String>) занести в него десять записей по принципу «Фамилия» - «Имя».
Проверить сколько людей имеют совпадающие с заданным имя или фамилию.
*/

public class Solution
{
    public static HashMap<String, String> createMap() {
        HashMap<String, String> map = new HashMap<String, String>();

            map.put("Adwa", "Oleg");
            map.put("Bdwa", "Sasha");
            map.put("Dda", "Andrey");
            map.put("Dda", "Kolya");
            map.put("Edaw", "Vasya");
            map.put("Fda", "Petya");
            map.put("Gdaw", "Andrey");
            map.put("Hdd", "Oleg");
            map.put("Idaw", "Sasha");
            map.put("Jdaw", "Andrey");

        return map;
    }

    public static int getCountTheSameFirstName(HashMap<String, String> map, String name)
    {

        int count = 0;
        Iterator<String> iterator = map.values().iterator();
        while (iterator.hasNext()) {
            String tmp = iterator.next();
            if (name.equals(tmp)) {
                count++;
            }
        }


        return count;
    }

    public static int getCountTheSameLastName(HashMap<String, String> map, String lastName)
    {
        if (map.containsKey(lastName)) return 1;
        else return 0;
        //метод containsKey возвращает boolean. "return map.containsKey(familiya) ? 1 : 0;" - это тернарная операция,
        // иными словами, если функция containsKey найдет совпадающую фамилию, то вернет "true", а следовательно наш return вернет 1, если не найдет то 0


    }
    public static void main(String[] args){
        HashMap<String,String> ma = createMap();
        System.out.println(getCountTheSameFirstName(ma,"Oleg"));
        System.out.println(getCountTheSameLastName(ma,"Dda"));
    }


}


package com.javarush.test.level08.lesson08.task03;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;


/* Одинаковые имя и фамилия
Создать словарь (Map<String, String>) занести в него десять записей по принципу «Фамилия» - «Имя».
Проверить сколько людей имеют совпадающие с заданным имя или фамилию.
*/

public class Solution
{
    public static HashMap<String, String> createMap() {

        HashMap<String, String> map = new HashMap<String, String>();
        map.put("aaa", "aaa");
        map.put("2", "b");
        map.put("3", "c");
        map.put("aaa", "4");
        map.put("e", "e");
        map.put("6", "f");
        map.put("7", "6");
        map.put("b", "b");
        map.put("aaa", "aaa");
        map.put("aaa", "aaa");
        return map;
    }
    public static int getCountTheSameFirstName(HashMap<String, String> map, String name)
    {
        int count = 0;
        Iterator<Map.Entry<String, String>>iterator = map.entrySet().iterator();
        while(iterator.hasNext())
        {
            if (name.equals(iterator.next().getValue()))
                count++;
        }
        return count;
    }
    public static int getCountTheSameLastName(HashMap<String, String> map, String familiya)
    {
        int count2 = 0;
        Iterator<Map.Entry<String, String>>iterator = map.entrySet().iterator();
        while (iterator.hasNext())
        {
            if (familiya.equals(iterator.next().getKey()))
                count2++;
        }

        return count2;
    }
    public static void main(String[] args)
    {
        System.out.println(getCountTheSameFirstName(createMap(), "aaa"));
        System.out.println(getCountTheSameLastName(createMap(), "aaa"));
    }
}



package com.javarush.test.level08.lesson08.task04;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Удалить всех людей, родившихся летом
Создать словарь (Map<String, Date>) и занести в него десять записей по принципу: «фамилия» - «дата рождения».
Удалить из словаря всех людей, родившихся летом.
*/

public class Solution
{
    public static HashMap<String, Date> createMap()
    {
        HashMap<String, Date> map = new HashMap<String, Date>();
        map.put("Stallone", new Date("Jun 1 1980"));
        map.put("Stallon", new Date("Jul 1 1980"));
        map.put("Stallodwa", new Date("Aug 1 1980"));
        map.put("Stallodaw", new Date("Jan 1 1980"));
        map.put("Stalloa", new Date("Sep 1 1980"));
        map.put("Stallodawd", new Date("Sep 1 1980"));
        map.put("Stalldawo", new Date("Sep 1 1980"));
        map.put("Stallodawdaw", new Date("Sep 1 1980"));
        map.put("Stalloaa", new Date("Sep 1 1980"));
        map.put("Stallovv", new Date("Sep 1 1980"));


        return map;
    }

    public static void removeAllSummerPeople(HashMap<String, Date> map) {


        Iterator<Map.Entry<String, Date>> summer = map.entrySet().iterator();
        while (summer.hasNext()) {
            Map.Entry<String, Date> pair = summer.next();
            if (pair.getValue().getMonth() == 5 || pair.getValue().getMonth() == 6 || pair.getValue().getMonth() == 7) {
                summer.remove();
            }

        }
    }
    public static void main(String[] args){

        removeAllSummerPeople(createMap());
        System.out.println(createMap());


    }

}





public class Puzzle4 {
    public static void main(String[] args) {
        Puzzle4[] obs = new Puzzle4[6];
        int y = 1;
        int x = 0;
        int result = 0;
        while (x < 6) {
            obs.ivar = x;
            obs[x].ivar = y;
            y = y * 10;



        }
        x = 6;
        while (x > 0) {
            obs.doStuff(x);

            result = result + ivar*factor;
        }

        System.out.println("Резульат" + result);
    }
}

class Puzzle4b{
    int ivar;
    public int doStuff(int factor){
        if (ivar>100){
            return ivar*(2+factor);
        }
        else{
            return ivar*(5-factor);
        }
    }
}


package com.javarush.test.level08.lesson08.task05;

import java.util.HashMap;
import java.util.Map;

/* Удалить людей, имеющих одинаковые имена
Создать словарь (Map<String, String>) занести в него десять записей по принципу «фамилия» - «имя».
Удалить людей, имеющих одинаковые имена.
*/

public class Solution
{
    public static HashMap<String, String> createMap()
    {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put("Stallone77", "Silvestre55");
        map.put("Stallone2", "Silvestr4");
        map.put("Stallone3", "Silvestre3");
        map.put("Stallone4", "Silvestre4");
        map.put("Stallone5", "Silvestre7");
        map.put("Stallone", "Silvestre11");
        map.put("Stallon", "Silvestre");
        map.put("Stallone9", "Silvestre");
        map.put("Stallone8", "Silvestre3");
        map.put("Stallone7", "Silvestre9");

        return map;
    }

    public static void removeTheFirstNameDuplicates(HashMap<String, String> map)
    {
        HashMap<String, String> copy = new HashMap<String, String>(map);
        for (Map.Entry<String,String> element : copy.entrySet())
        {
            int count = 0;
            for (Map.Entry<String, String> copyElement : copy.entrySet())
            {
                if (element.getValue().equals(copyElement.getValue()))
                {
                    count++;
                }
            }
            if (count > 1)
            {
                removeItemFromMapByValue(map, element.getValue());
            }

        }

    }

    public static void removeItemFromMapByValue(HashMap<String, String> map, String value)
    {
        HashMap<String, String> copy = new HashMap<String, String>(map);
        for (Map.Entry<String, String> pair : copy.entrySet()) {
            if (pair.getValue().equals(value))
                map.remove(pair.getKey());
        }
    }
    public static void main(String[] args) {
    }
}

package com.javarush.test.level08.lesson11.home01;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/* Set из котов
1. Внутри класса Solution создать public static класс кот – Cat.
2. Реализовать метод createCats, он должен создавать множество (Set) котов и добавлять в него 3 кота.
3. В методе main удалите одного кота из Set cats.
4. Реализовать метод printCats, он должен вывести на экран всех котов, которые остались во множестве. Каждый кот с новой строки.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Set<Cat> cats = createCats();

        for (Iterator<Cat> iterator = cats.iterator(); iterator.hasNext(); ) {
            Cat a = iterator.next();

            cats.remove(a);
            break;

        }


        printCats(cats);
    }

    public static Set<Cat> createCats()
    {
        HashSet<Cat> cats = new HashSet<Cat>();

        Cat a  = new Cat();
        Cat b  = new Cat();
        Cat c  = new Cat();

        cats.add(a);
        cats.add(b);
        cats.add(c);

        return cats;
    }

    public static void printCats(Set<Cat> cats)
    {

            System.out.println(cats);

    }

    public static class Cat{


    }
}


package com.javarush.test.level08.lesson11.home02;

import java.util.*;

/* Множество всех животных
1. Внутри класса Solution создать public static классы Cat, Dog.
2. Реализовать метод createCats, котороый должен возвращать множество с 4 котами.
3. Реализовать метод createDogs, котороый должен возвращать множество с 3 собаками.
4. Реализовать метод join, котороый должен возвращать объединенное множество всех животных - всех котов и собак.
5. Реализовать метод removeCats, котороый должен удалять из множества pets всех котов, которые есть в множестве cats.
6. Реализовать метод printPets, котороый должен выводить на экран всех животных, которые в нем есть. Каждое животное с новой строки
*/

public class Solution
{
    public static void main(String[] args)
    {
        Set<Cat> cats = createCats();
        Set<Dog> dogs = createDogs();

        Set<Object> pets = join(cats, dogs);
        printPets(pets);

        removeCats(pets, cats);
        printPets(pets);
    }

    public static Set<Cat> createCats()
    {
        HashSet<Cat> result = new HashSet<Cat>();
        result.add(new Cat());
        result.add(new Cat());
        result.add(new Cat());
        result.add(new Cat());
        //Написать тут ваш код
        return result;
    }

    public static Set<Dog> createDogs()
    {
        HashSet<Dog> result = new HashSet<Dog>();
        result.add(new Dog());
        result.add(new Dog());
        result.add(new Dog());
        //Написать тут ваш код
        return result;
    }

    public static Set<Object> join(Set<Cat> cats, Set<Dog> dogs)
    {
        Set<Object> result = new HashSet<Object>();//Написать тут ваш код
        result.addAll(cats);
        result.addAll(dogs);
        return result;

    }

    public static void removeCats(Set<Object> pets, Set<Cat> cats) {
        for (Iterator<Cat> iterator = cats.iterator(); iterator.hasNext(); ) {
            Cat x = iterator.next();
            pets.remove(x);
        }
        }

    public static void printPets(Set<Object> pets)
    {
        for (Iterator<Object> iterator = pets.iterator(); iterator.hasNext(); ) {
            Object join = iterator.next();
            System.out.println(join);
        }
    }
    public static class  Cat{

    }
    public static class Dog{

    }
}



package com.javarush.test.level08.lesson11.home03;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Люди с одинаковыми именами и/или фамилиями
1. Создать словарь Map (<String, String>) и добавить туда 10 человек в виде «Фамилия»-«Имя».
2. Пусть среди этих 10 человек есть люди с одинаковыми именами.
3. Пусть среди этих 10 человек есть люди с одинаковыми фамилиями.
4. Вывести содержимое Map на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Map<String, String> map = createPeopleList();
        printPeopleList(map);
    }

    public static Map<String, String> createPeopleList()
    {
            HashMap<String, String> map = new HashMap<String, String>();
            map.put("Stallone77", "Silvestre55");
            map.put("Stallone2", "Silvestr4");
            map.put("Stallone3", "Silvestre3");
            map.put("Stallone4", "Silvestre");
            map.put("Stallone5", "Silvestre7");
            map.put("Stallone", "Silvestre11");
            map.put("Stallone", "Silvestre");
            map.put("Stallone9", "Silvestre");
            map.put("Stallone8", "Silvestre");
            map.put("Stallone7", "Silvestre9");

            for (Map.Entry<String,String> element : map.entrySet()) {
                for (Map.Entry<String, String> copyElement : map.entrySet()) {
                        element.getValue().equals(copyElement.getValue());

                    }
                }

        for (Map.Entry<String,String> element : map.entrySet()) {
            for (Map.Entry<String, String> copyElement : map.entrySet()) {
                    element.getKey().equals(copyElement.getKey());

                }
            }


        return map;
    }



    public static void printPeopleList(Map<String, String> map)
    {
        for (Map.Entry<String, String> s : map.entrySet()) {
            System.out.println(s.getKey() + " " + s.getValue());
        }
    }

}

package com.javarush.test.level08.lesson11.home04;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/* Минимальное из N чисел
1. Ввести с клавиатуры число N.
2. Считать N целых чисел и заполнить ими список - метод getIntegerList.
3. Найти минимальное число среди элементов списка - метод getMinimum.
*/

public class Solution {

    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws Exception {


        List<Integer> integerList = getIntegerList();
        System.out.println(getMinimum(integerList));
    }


    public static int getMinimum(List<Integer> array) {
        //find minimum here - найти минимум тут
        int min = array.get(0);
        for (int i = 0; i < array.size(); i++) {
            if (array.get(i) < min)
                min = array.get(i);
        }
        return min;
    }

    public static List<Integer> getIntegerList() throws IOException {
        //create and initialize a list here - создать и заполнить список тут
        List<Integer> list = new ArrayList<Integer>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(reader.readLine());
        for (int i = N; i > 0; i--) {
            list.add(Integer.parseInt(reader.readLine()));
        }
        return list;
    }
}



package com.javarush.test.level08.lesson11.home05;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

/* Мама Мыла Раму. Теперь с большой буквы
Написать программу, которая вводит с клавиатуры строку текста.
Программа заменяет в тексте первые буквы всех слов на заглавные.
Вывести результат на экран.

Пример ввода:
  мама     мыла раму.

Пример вывода:
  Мама     Мыла Раму.
*/

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String s = reader.readLine();

        char[] chars = s.toCharArray();
        boolean b = true;
        s = "";
        for (int i = 0; i < chars.length; i++)
        {
            if (chars[i] == ' ') b = true;
            else
            {
                if (b)
                {
                    chars[i] = Character.toUpperCase(chars[i]);
                    b = !b;
                }
            }
            s += chars[i];
        }
        System.out.println(s);
    }
}


package com.javarush.test.level08.lesson11.home06;

/* Вся семья в сборе
1. Создай класс Human с полями имя (String), пол (boolean), возраст (int), дети (ArrayList<Human>).
2. Создай объекты и заполни их так, чтобы получилось: два дедушки, две бабушки, отец, мать, трое детей.
3. Вывести все объекты Human на экран.
*/

import java.util.ArrayList;
import java.util.Collections;

public class Solution
{
    public static void main(String[] args)
    {
        ArrayList<Human> list = new ArrayList<Human>();
        Human grandFather1 = new Human("Bob", true, 95);
        Human grandFather2 = new Human("bab", true, 94);
        Human grandMother1 = new Human("Bgb", false, 92);
        Human grandMother2 = new Human("gfd", false, 91);
        Human father = new Human("Fadaw", true, 43);
        Human mother = new Human("Fadwa", false, 43);
        Human child = new Human("Fat", false, 33);
        Human child2 = new Human("Fadawdaw", true, 23);
        Human child3 = new Human("Ghdh", true, 13);

        ArrayList<Human> children = new ArrayList<Human>();

        children.add(child);
        children.add(child2);
        children.add(child3);

        Collections.addAll(list, grandFather1, grandFather2, grandMother1, grandMother2, father, mother, child, child2, child3);
        for (int i = 0; i < list.size(); i++)
            System.out.println(list.get(i));



    }

    public static class Human
    {
        String name;
        boolean sex;
        int age;

        ArrayList<Human> children = new ArrayList<>();



        Human(String name, boolean sex, int age){
            this.name = name;
            this.sex = sex;
            this.age = age;


        }

        public String toString()
        {
            String text = "";
            text += "Имя: " + this.name;
            text += ", пол: " + (this.sex ? "мужской" : "женский");
            text += ", возраст: " + this.age;

            int childCount = this.children.size();
            if (childCount > 0)
            {
                text += ", дети: "+this.children.get(0).name;

                for (int i = 1; i < childCount; i++)
                {
                    Human child = this.children.get(i);
                    text += ", "+child.name;
                }
            }

            return text;
        }
    }

}


package com.javarush.test.level08.lesson11.home08;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;

/* Пять наибольших чисел
Создать массив на 20 чисел. Заполнить его числами с клавиатуры. Вывести пять наибольших чисел.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] array = new int[20];
        for (int i = 0; i < array.length; i++) {
            array[i] = Integer.parseInt(reader.readLine());
        }

        sort(array);

        System.out.println(array[0]);
        System.out.println(array[1]);
        System.out.println(array[2]);
        System.out.println(array[3]);
        System.out.println(array[4]);
    }

    public static void sort(int[] array){


        for (int i = 0; i < array.length - 1; i++)
        {
            for (int j = 0; j < array.length - i - 1; j++)
            {
                if (array[j] < array[j+1])
                {
                   int  temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
    }

    }


	
	package com.javarush.test.level08.lesson08.task04;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Удалить всех людей, родившихся летом
Создать словарь (Map<String, Date>) и занести в него десять записей по принципу: «фамилия» - «дата рождения».
Удалить из словаря всех людей, родившихся летом.
*/

public class Solution
{
    public static HashMap<String, Date> createMap()
    {
        HashMap<String, Date> map = new HashMap<String, Date>();
        map.put("Stallone", new Date("Jun 1 1980"));
        map.put("Stallon", new Date("Jul 1 1980"));
        map.put("Stallodwa", new Date("Aug 1 1980"));
        map.put("Stallodaw", new Date("Jan 1 1980"));
        map.put("Stalloa", new Date("Sep 1 1980"));
        map.put("Stallodawd", new Date("Sep 1 1980"));
        map.put("Stalldawo", new Date("Sep 1 1980"));
        map.put("Stallodawdaw", new Date("Sep 1 1980"));
        map.put("Stalloaa", new Date("Sep 1 1980"));
        map.put("Stallovv", new Date("Sep 1 1980"));


        return map;
    }

    public static void removeAllSummerPeople(HashMap<String, Date> map) {


        Iterator<Map.Entry<String, Date>> summer = map.entrySet().iterator();
        while (summer.hasNext()) {
            Map.Entry<String, Date> pair = summer.next();
            if (pair.getValue().getMonth() == 5 || pair.getValue().getMonth() == 6 || pair.getValue().getMonth() == 7) {
                summer.remove();
            }

        }
    }
    public static void main(String[] args){

        removeAllSummerPeople(createMap());
        System.out.println(createMap());


    }

}



package com.javarush.test.level08.lesson11.home09;

import java.util.Date;

/* Работа с датой
1. Реализовать метод isDateOdd(String date) так, чтобы он возвращал true, если количество дней с начала года - нечетное число, иначе false
2. String date передается в формате MAY 1 2013
Не забудьте учесть первый день года.
Пример:
JANUARY 1 2000 = true
JANUARY 2 2020 = false
*/

public class Solution {
    public static void main(String[] args) {
        System.out.print(isDateOdd("APRIL 10 2016"));

    }

    public static boolean isDateOdd(String date) {
        {
            Date yearStartTime = new Date("APRIL 10 2016");
            yearStartTime.setHours(0);
            yearStartTime.setMinutes(0);
            yearStartTime.setSeconds(0);
            yearStartTime.setDate(1);      // первое число
            yearStartTime.setMonth(0);     // месяц январь, нумерация для месяцев 0-11
            Date currentTime = new Date(date);
            long msTimeDistance = currentTime.getTime() - yearStartTime.getTime();
            long msDay = 24 * 60 * 60 * 1000;  //сколько миллисекунд в одних сутках
            int dayCount = (int) (msTimeDistance / msDay);
            if (dayCount % 2 != 0)
                return true;
            else 
                return false;
        }
    }
}





____________________________________________________________________________________________--СОРТИРОВКА ВЕДЕННЫХ СТРОК В АЛФАВИТНОМ ПОРЯДКЕ!!!!!
package com.javarush.test.level08.lesson11.bonus03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Задача по алгоритмам
Задача: Введи с клавиатуры 20 слов и выведи их в алфавитном порядке.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] array = new String[20];
        for (int i = 0; i < array.length; i++)
        {
            array[i] = reader.readLine();
        }

        sort(array);

        for (int i = 0, arrayLength = array.length; i < arrayLength; i++) {
            String x = array[i];
            System.out.println(x);
        }
    }

    public static void sort(String[] array) throws IOException {

        for (int i = 0; i < array.length; i++){
            for (int j = i+1; j < array.length; j++){
                if(isGreaterThan(array[i], array[j])){
                    String s = array[i];
                    array[i] = array[j];
                    array[j] = s;
                }
            }
        }
    }


    //Метод для сравнения строк: 'а' больше чем 'b'
    public static boolean isGreaterThan(String a, String b)
    {
        return a.compareTo(b) > 0;
    }
}



package com.javarush.test.level07.lesson12.bonus01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Нужно исправить программу, чтобы компилировалась и работала
Задача:  Программа вводит с клавиатуры данные про котов и выводит их на экран. Пример:
Cat name is Barsik, age is 6, weight is 5, tail = 22
Cat name is Murka, age is 8, weight is 7, tail = 20
*/

public class Solution
{
    public final static ArrayList<Cat> CATS = new ArrayList<Cat>();

    public static void main(String[] args) throws IOException
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        while (true)
        {
            String name = reader.readLine();

            if (name.isEmpty()) break;

            int age = Integer.parseInt(reader.readLine());
            int weight = Integer.parseInt(reader.readLine());
            int tailLength = Integer.parseInt(reader.readLine());
            Cat cat = new Cat(name, age, weight, tailLength);

            CATS.add(cat);

        }

        printList();
    }

    public static void printList() {
        for (int i = 0; i < CATS.size(); i++)
        {
            System.out.println(CATS.get(i));
        }
    }

    public static class Cat
    {
        private String name;
        private int age;
        private int weight;
        private int tailLength;

        Cat(String name, int age, int weight, int tailLength)
        {
            this.name = name;
            this.age = age;
            this.weight = weight;
            this.tailLength = tailLength;
        }

        @Override
        public String toString()
        {
            return "Cat name is " + name + ", age is " + age + ", weight is " + weight + ", tail = " + tailLength;
        }
    }
}


package com.javarush.test.level06.lesson11.bonus01;

/* Нужно исправить программу, чтобы компилировалась и работала
Задача: Программа вводит два числа с клавиатуры и выводит их максимум в виде «Max is 25»
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Solution
{
    public static int max = 100;

    public static void main(String[] args) throws IOException
    {
        BufferedReader reader  = new BufferedReader(new InputStreamReader(System.in));

        String max = "Max is ";
        int a = Integer.parseInt(reader.readLine());
        int b = Integer.parseInt(reader.readLine());

        int maximum = a > b ? a : b;

        System.out.println(max + maximum);
    }

}


package com.javarush.test.level05.lesson12.bonus02;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Нужно добавить в программу новую функциональность
Задача: Программа вводит два числа с клавиатуры и выводит минимальное из них на экран.
Новая задача: Программа вводит пять чисел с клавиатуры и выводит минимальное из них на экран.
*/

public class Solution {

    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));


        ArrayList<Integer> list = new ArrayList<Integer>();

        for (int i = 0; i < 5; i++) {

            list.add(Integer.parseInt(reader.readLine()));
        }

            int minimum = list.get(0);

            for (int j = 0; j < list.size(); j++) {
                if (minimum > list.get(j)) {
                    minimum = list.get(j);
                }
            }

            System.out.println("Minimum = " + minimum);
        }

    }


	
	
	package com.javarush.test.level06.lesson11.bonus02;

import com.javarush.test.level06.lesson05.task04.Cat;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Нужно добавить в программу новую функциональность
Задача: У каждой кошки есть имя и кошка-мама. Создать класс, который бы описывал данную ситуацию. Создать два объекта: кошку-дочь и кошку-маму. Вывести их на экран.
Новая задача: У каждой кошки есть имя, кошка-папа и кошка-мама. Изменить класс Cat так, чтобы он мог описать данную ситуацию.
Создать 6 объектов: дедушку(папин папа), бабушку(мамина мама), папу, маму, сына, дочь.
Вывести их всех на экран в порядке: дедушка, бабушка, папа, мама, сын, дочь.

Пример ввода:
дедушка Вася
бабушка Мурка
папа Котофей
мама Василиса
сын Мурчик
дочь Пушинка

Пример вывода:
Cat name is дедушка Вася, no mother, no father
Cat name is бабушка Мурка, no mother, no father
Cat name is папа Котофей, no mother, father is дедушка Вася
Cat name is мама Василиса, mother is бабушка Мурка, no father
Cat name is сын Мурчик, mother is мама Василиса, father is папа Котофей
Cat name is дочь Пушинка, mother is мама Василиса, father is папа Котофей
*/

public class Solution
{
    public static void main(String[] args) throws IOException
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String grandfaName = reader.readLine();
        Cat catGrandfa = new Cat(grandfaName);

        String grandmaName = reader.readLine();
        Cat catGrandma = new Cat(grandmaName);

        String fatherName = reader.readLine();
        Cat catFather = new Cat(fatherName, catGrandfa, null);

        String motherName = reader.readLine();
        Cat catMother = new Cat(motherName, null, catGrandma);

        String sonName = reader.readLine();
        Cat catSon = new Cat(sonName, catFather, catMother);

        String daughterName = reader.readLine();
        Cat catDaughter = new Cat(daughterName, catFather, catMother);

        System.out.println(catGrandfa);
        System.out.println(catGrandma);
        System.out.println(catFather);
        System.out.println(catMother);
        System.out.println(catSon);
        System.out.println(catDaughter);
    }

    public static class Cat
    {
        private String name;
        private Cat mother;
        private Cat father;

        Cat(String name)
        {
            this.name = name;
        }

        Cat(String name, Cat father, Cat mother)
        {
            this.name = name;
            this.father = father;
            this.mother = mother;
        }

        @Override
        public String toString()
        {
            if ((father == null) && (mother == null))
                return "Cat name is " + name + ", no mother, no father";
            if (father == null){
                return "Cat name is " + name + ", mother is " + mother.name + ", no father";
            }
            if (mother == null){
                return "Cat name is " + name + ", no mother, father is " + father.name;
            }
            else
                return "Cat name is " + name + ", mother is " + mother.name + ", father is " + father.name;
        }
    }

}




package com.javarush.test.level07.lesson12.bonus02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Нужно заменить функциональность программы
Задача:  Программа вводит строки, пока пользователь не введёт пустую строку (нажав enter). Потом она конвертирует строки в верхний регистр (Мама превращается в МАМА) и выводит их на экран.
Новая задача: Программа вводит строки, пока пользователь не введёт пустую строку (нажав enter).
Потом программа строит новый список. Если в строке чётное число букв, строка удваивается, если нечётное – утраивается.
Программа выводит содержимое нового списка на экран.
Пример ввода:
Кот
Коты
Я
Пример вывода:
Кот Кот Кот
Коты Коты
Я Я Я
*/

public class Solution
{
    public static void main(String[] args) throws IOException
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> list = new ArrayList<String>();
        while (true)
        {
            String s = reader.readLine();
            if (s.isEmpty()) break;
            list.add(s);
        }

        ArrayList<String> listCount = new ArrayList<String>();
        for (int i = 0; i < list.size(); i++)
        {
            String s = list.get(i);

            if(s.length() % 2 == 0){

                System.out.println(list.get(i) + " " + list.get(i));
            }

            if(s.length() % 2 != 0){

                System.out.println(list.get(i) + " " + list.get(i) + " " + list.get(i));
            }

        }
    }
}


_________________________________________________________________________________________________________НЕ РАБОТАЕТ, ПОДУМАТЬ!
package com.javarush.test.level08.lesson11.bonus02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Нужно добавить в программу новую функциональность
Задача: Программа определяет, какая семья (фамилию) живёт в доме с указанным номером.
Новая задача: Программа должна работать не с номерами домов, а с городами:
Пример ввода:
Москва
Ивановы
Киев
Петровы
Лондон
Абрамовичи

Лондон

Пример вывода:
Абрамовичи
*/

public class Solution
{
    public static void main(String[] args) throws IOException
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        //list of addresses
        List<String> addresses = new ArrayList<String>();
        while (true)
        {
            String family = reader.readLine();
            if (family.isEmpty()) break;

            addresses.add(family);
        }

        //read home number
        int houseNumber = Integer.parseInt(reader.readLine());

        if (0 <= houseNumber && houseNumber < addresses.size())
        {
            String familySecondName = addresses.get(houseNumber);
            System.out.println(familySecondName);
        }
    }
}



package com.javarush.test.level08.lesson11.bonus02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

/* Нужно добавить в программу новую функциональность
Задача: Программа определяет, какая семья (фамилию) живёт в доме с указанным номером.
Новая задача: Программа должна работать не с номерами домов, а с городами:
Пример ввода:
Москва
Ивановы
Киев
Петровы
Лондон
Абрамовичи

Лондон

Пример вывода:
Абрамовичи
*/

public class Solution
{
    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        //list of addresses
        Map<String,String> map = new HashMap<String, String>();
        while (true) {
            String city = reader.readLine();

            if (city.isEmpty()) break;

            String family = reader.readLine();

            map.put(city, family);
        }
        //read home number
        String currentcity = reader.readLine();
        for (Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<String, String> pair = iterator.next();
            if (currentcity.equals(pair.getKey())) System.out.println(pair.getValue());
            else continue;

        }
    }
}


__________________________________________________________________________________________РАЗОБРАТЬСЯ С ВЫВОДОМ НА ЭКРАН
package com.javarush.test.level09.lesson02.task01;

/* Каждый метод должен возвращать свой StackTrace
Написать пять методов, которые вызывают друг друга. Каждый метод должен возвращать свой StackTrace.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        method1();
    }

    public static StackTraceElement[] method1()
    {
        method2();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : stackTraceElements)
        {
            System.out.println(element.getMethodName());
        }

        return stackTraceElements;
    }

    public static StackTraceElement[] method2()
    {
        method3();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : stackTraceElements)
        {
            System.out.println(element.getMethodName());
        }

        return stackTraceElements;
    }

    public static StackTraceElement[] method3()
    {
        method4();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : stackTraceElements)
        {
            System.out.println(element.getMethodName());
        }

        return stackTraceElements;
    }

    public static StackTraceElement[] method4()
    {
        method5();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : stackTraceElements)
        {
            System.out.println(element.getMethodName());
        }

        return stackTraceElements;
    }

    public static StackTraceElement[] method5()
    {
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : stackTraceElements)
        {
            System.out.println(element.getMethodName());
        }

        return stackTraceElements;
    }
}




package com.javarush.test.level09.lesson02.task02;

/* И снова StackTrace
Написать пять методов, которые вызывают друг друга. Каждый метод должен возвращать имя метода, вызвавшего его, полученное с помощью StackTrace.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        method1();
    }

    public static String method1()
    {
        method2();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        return stackTraceElements[2].getMethodName();

    }

    public static String method2()
    {
        method3();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        return stackTraceElements[2].getMethodName();

    }

    public static String method3()
    {
        method4();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        return stackTraceElements[2].getMethodName();

    }

    public static String method4()
    {
        method5();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        return stackTraceElements[2].getMethodName();

    }

    public static String method5()
    {
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        return stackTraceElements[2].getMethodName();

    }
}
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//Виталий, вероятно потому, что в стеке нет такого уровня. Смотрите: [0] - это сам стек [1] - это текущий метод
// [2] - это метод, на уровень ниже - то есть тот, который вызвал текущий [3]- соответственно метод, который вызвал метод, который вызвал текущий
// метод... и так далее, пока не достигнет дна стека... То есть отрицательный вариант не возможен...
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



package com.javarush.test.level09.lesson02.task03;

/* Метод должен вернуть номер строки кода, из которого вызвали этот метод
Написать пять методов, которые вызывают друг друга. Метод должен вернуть номер строки кода, из которого вызвали этот метод. Воспользуйся функцией: element.getLineNumber().
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        method1();
    }

    public static int method1()
    {
        method2();

        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();

        return stackTraceElements[2].getLineNumber();
    }

    public static int method2()
    {
        method3();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();

        return stackTraceElements[2].getLineNumber();
    }

    public static int method3()
    {
        method4();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();

        return stackTraceElements[2].getLineNumber();
    }

    public static int method4()
    {
        method5();
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();

        return stackTraceElements[2].getLineNumber();
    }

    public static int method5()
    {
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();

        return stackTraceElements[2].getLineNumber();
    }
}



package com.javarush.test.level09.lesson02.task04;

/* Стек-трейс длиной 10 вызовов
Напиши код, чтобы получить стек-трейс длиной 10 вызовов.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        method1();
    }

    public static StackTraceElement[] method1()
    {
        return method2();
    }

    public static StackTraceElement[] method2()
    {
        return method3();

    }

    public static StackTraceElement[] method3()
    {
        return method4();

    }

    public static StackTraceElement[] method4()
    {
        return method5();

    }

    public static StackTraceElement[] method5()
    {
        return method6();

    }

    public static StackTraceElement[] method6()
    {
        return method7();

    }

    public static StackTraceElement[] method7()
    {
        return method8();

    }

    public static StackTraceElement[] method8()
    {
        return method9();

    }

    public static StackTraceElement[] method9()
    {
        return method10();
    }

    public static StackTraceElement[] method10()
    {
        return Thread.currentThread().getStackTrace();
    }
}


package com.javarush.test.level09.lesson02.task05;

/* Метод должен возвращать результат – глубину его стек-трейса
Написать метод, который возвращает результат – глубину его стек трейса – количество методов в нем (количество элементов в списке). Это же число метод должен выводить на экран.
*/

public class Solution {

    public static int getStackTraceDeep() {

            StackTraceElement[] StackTrace = Thread.currentThread().getStackTrace();

        System.out.print(StackTrace.length);

            return StackTrace.length;
        }

}


__________________________________________________________CATCH Exception

public class ExceptionExample2
{
    public static void main(String[] args)
    {
        System.out.println("Program starts");

        try
        {
            System.out.println("Before method1 calling");
            method1();
            System.out.println("After method1 calling. Never will be shown");
        }
        catch (Exception e)
        {
           System.out.println("Exception has been caught");
        }

        System.out.println("Program is still running");
    }

    public static void method1()
    {
        int a = 100;
        int b = 0;
        System.out.println(a / b);
    }
}


public class ExceptionExample2
{
    public static void main(String[] args)
    {
        System.out.println("Program starting.");

        try
        {
            System.out.println("Before method1 calling.");
            method1();
            System.out.println("After method1 calling. Never showed.");
        }
        catch (NullPointerException e)
        {
           System.out.println("Reference is null. Exception caught.");
        }
        catch (ArithmeticException e)
        {
            System.out.println("Divided by zero. Exception caught.");
        }
        catch (Exception e)
        {
            System.out.println("Any other errors. Exception caught.");
        }

        System.out.println("Program still running.");
    }

    public static void method1()
    {
        int a = 100;
        int b = 0;
        System.out.println(a / b);
    }
}




package com.javarush.test.level09.lesson06.task01;

/* Исключение при работе с числами
Перехватить исключение (и вывести его на экран), указав его тип, возникающее при выполнении кода:
int a = 42 / 0;
*/


public class Solution
{
    public static void main(String[] args) throws Exception
    {
        try {

            int a = 42 / 0;
        }

        catch(ArithmeticException e)
        {
            System.out.println(e);

    }

    }
}


package com.javarush.test.level09.lesson06.task02;

/* Исключение при работе со строками
Перехватить исключение (и вывести его на экран), указав его тип, возникающее при выполнении кода:
String s = null;
String m = s.toLowerCase();
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        try {

            String s = null;
            String m = s.toLowerCase();
        }
        catch (Exception e)
        {
            System.out.println(e);
        }


    }
}


package com.javarush.test.level09.lesson06.task03;

/* Исключение при работе с массивами
Перехватить исключение (и вывести его на экран), указав его тип, возникающее при выполнении кода:
int[] m = new int[2];
m[8] = 5;
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        try {

            int[] m = new int[2];
            m[8] = 5;
        }
        
        catch(Exception e)
        {
            System.out.println(e);
        }


    }
}



package com.javarush.test.level09.lesson06.task04;

import java.util.ArrayList;

/* Исключение при работе с коллекциями List
Перехватить исключение (и вывести его на экран), указав его тип, возникающее при выполнении кода:
ArrayList<String> list = new ArrayList<String>();
String s = list.get(18);
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        try {

            ArrayList<String> list = new ArrayList<String>();
            String s = list.get(18);
        }

        catch(Exception e)
        {
            System.out.println(e);
        }

    }
}


package com.javarush.test.level09.lesson06.task05;

import java.util.HashMap;

/* Исключение при работе с коллекциями Map
Перехватить исключение (и вывести его на экран), указав его тип, возникающее при выполнении кода:
HashMap<String, String> map = new HashMap<String, String>(null);
map.put(null, null);
map.remove(null);
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        try {

            HashMap<String, String> map = new HashMap<String, String>(null);
            map.put(null, null);
            map.remove(null);
        }
        catch(Exception e){
            System.out.println(e);
        }

    }
}


!!!!!!!!!!!!!!!!!!!!!! Выброс неуказанного исключения в следующий метод
В примере ниже исключение ArithmeticException не будет перехвачено, а будет выброшено дальше в вызывающий метод.

Код
try
{
    System.out.println("Before method1 calling.");
    int a = 1/0;
    System.out.println("After method1 calling. Never will be shown.");
}
catch (NullPointerException e)
{
    System.out.println("Reference is null. Exception has been caught.");
}


package com.javarush.test.level09.lesson08.task01;

import java.io.FileNotFoundException;
import java.net.URISyntaxException;
import java.util.HashMap;

/* Исключения
Есть метод, который выбрасывает два исключения, унаследованные от Exception, и два унаследованных от RuntimeException:
NullPointerException, ArithmeticException, FileNotFoundException, URISyntaxException.

Нужно перехватить NullPointerException и FileNotFoundException, но не перехватывать
ArithmeticException и URISyntaxException. Как это сделать?
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        try {

            method1();
        }

        catch(NullPointerException | FileNotFoundException e)
        {
            String s = e.getMessage();
            System.out.println(s);

    }


    }

    public static void method1() throws NullPointerException, ArithmeticException, FileNotFoundException, URISyntaxException
    {
        int i = (int) (Math.random() * 4);
        if (i == 0)
            throw new NullPointerException();
        if (i == 1)
            throw new ArithmeticException();
        if (i == 2)
            throw new FileNotFoundException();
        if (i == 3)
            throw new URISyntaxException("", "");
    }
}



package com.javarush.test.level09.lesson08.task02;

/* Перехватывание исключений
1. Есть три исключения последовательно унаследованные от Exception:
2. class Exception1 extends  Exception
3. class Exception2 extends  Exception1
4. class Exception3 extends  Exception2
5. Есть метод, который описан так:
5.1. public static void method1() throws Exception1, Exception2, Exception3

6. Напиши catch, который перехватит все три Exception1, Exception2 и Exception3
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
      try {

          method1();
      }

      catch(Exception e){
          System.out.println(e);
      }


    }

    public static void method1() throws Exception1, Exception2, Exception3
    {
        int i = (int) (Math.random() * 3);
        if (i == 0)
            throw new Exception1();
        if (i == 1)
            throw new Exception2();
        if (i == 2)
            throw new Exception3();
    }
}

class Exception1 extends Exception {
}

class Exception2 extends Exception1 {
}

class Exception3 extends Exception2 {
}


__________________ ПРОСМОТРЕТЬ
package com.javarush.test.level09.lesson08.task03;


import java.io.CharConversionException;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.FileSystemException;

/* Перехват выборочных исключений
1. Разберись, какие исключения бросает метод BEAN.methodThrowExceptions.
2. Метод processExceptions должен вызывать метод BEAN.methodThrowExceptions и обрабатывать исключения:
2.1. если возникло исключение FileSystemException, то логировать его (вызвать метод BEAN.log) и пробросить дальше
2.2. если возникло исключение CharConversionException или любое другое IOException, то только логировать его - вызвать метод BEAN.log
3. Добавь в сигнатуру метода processExceptions класс исключения, которое ты пробрасываешь в п.2.1.
4. В методе main обработай оставшееся исключение - логируй его. Используй try..catch

Подсказка:
Если ты захватил исключение MyException, которое не хотел захватывать, его можно пробросить дальше кодом вида:
catch (MyException e) {
throw e;
}
*/

public class Solution {
    public static StatelessBean BEAN = new StatelessBean();

    public static void main(String[] args) {

        try {
            processExceptions();
        }
        catch (FileSystemException e){
            BEAN.log(e);
        }


    }

    public static void processExceptions() throws FileSystemException {

        try{
            BEAN.methodThrowExceptions();

        }
        catch(FileSystemException e){
            BEAN.log(e);
            throw(e);

        }
        catch(IOException e){
            BEAN.log(e);
        }


    }

    public static class StatelessBean {
        public void log(Exception exception) {
            System.out.println(exception.getMessage() + ", " + exception.getClass().getSimpleName());
        }

        public void methodThrowExceptions() throws CharConversionException, FileSystemException, IOException {
            int i = (int) (Math.random() * 3);
            if (i == 0)
                throw new CharConversionException();
            if (i == 1)
                throw new FileSystemException("");
            if (i == 2)
                throw new IOException();
        }
    }
}



package com.javarush.test.level09.lesson08.task04;

import java.io.IOException;
import java.rmi.RemoteException;

/* Перехват checked исключений
В методе processExceptions обработайте все checked исключения.
Нужно вывести на экран каждое возникшее checked исключение.
Можно использовать только один блок try..
*/

public class Solution {
    public static void main(String[] args) {
        processExceptions(new Solution());

    }

    public static void processExceptions(Solution obj) {

        try
        {
            obj.method1();
            obj.method2();
            obj.method3();
        }
        catch (RemoteException e)
        {
            System.out.print(e);
        }
        catch (NoSuchFieldException e)
        {
            System.out.print(e);
        }
        catch (IOException e)
        {
            System.out.print(e);
        }

    }

    public void method1() throws IOException {
        throw new IOException();
    }

    public void method2() throws NoSuchFieldException {
        throw new NoSuchFieldException();
    }

    public void method3() throws RemoteException {
        throw new RemoteException();
    }
}


СЛИЯНИЕ СПИСКОВ
public static void main(String[] args) throws IOException
{
    ArrayList<Integer> list1 = new ArrayList<Integer>();   //создание списка  
    Collections.addAll(list1, 1, 5, 6, 11, 3, 15, 7, 8);   //заполнение списка

    ArrayList<Integer> list2 = new ArrayList<Integer>();
    Collections.addAll(list2, 1, 8, 6, 21, 53, 5, 67, 18);

    ArrayList<Integer> result = new ArrayList<Integer>();

    result.addAll(list1);   //добавление всех значений из одного списка в другой
    result.addAll(list2);

    for (Integer x : result)   //быстрый for по всем элементам, только для коллекций
    {
        System.out.println(x);
    }
}



package com.javarush.test.level09.lesson08.task05;

/* Перехват unchecked исключений
В методе processExceptions обработайте все unchecked исключения.
Нужно вывести стек-трейс каждого возникшего исключения используя метод printStack.
Можно использовать только один блок try..
*/

public class Solution
{
    public static void main(String[] args) {
        processExceptions(new Solution());
    }

    public static void processExceptions(Solution obj) {

        try {
            obj.method1();
            obj.method2();
            obj.method3();
        }
        catch(NumberFormatException e){
            printStack(e);
        }
        catch(IndexOutOfBoundsException e){
            printStack(e);
        }
        catch(NullPointerException e){
            printStack(e);
        }




    }

    public static void printStack(Throwable throwable) {
        System.out.println(throwable);
        for (StackTraceElement element : throwable.getStackTrace()) {
            System.out.println(element);
        }
    }

    public void method1(){
        throw new NullPointerException();
    }

    public void method2() {
        throw new IndexOutOfBoundsException();
    }

    public void method3() {
        throw new NumberFormatException();
    }
}



package com.javarush.test.level09.lesson11.home01;

/* Деление на ноль
Создай метод public static void divisionByZero, в котором подели любое число на ноль и выведи на экран результат деления.
Оберни вызов метода divisionByZero в try..catch. Выведи стек-трейс исключения используя метод exception.printStackTrace()
*/

public class Solution {

    public static void main(String[] args) throws ArithmeticException{

        try {
            divisionByZero();
        }
        catch(ArithmeticException e){
            e.printStackTrace();
        }

        }

    private static void divisionByZero() {
        int i = 5/0;
        System.out.println(i);
    }

}


package com.javarush.test.level09.lesson11.home02;

/* Обратный отсчёт от 10 до 0
Написать в цикле обратный отсчёт от 10 до 0. Для задержки иcпользовать Thread.sleep(100);
Обернуть вызов sleep в try..catch.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        for (int i = 10; i >= 0; i--)
        {
            System.out.println(i);

            try{
                Thread.sleep(100);
            }
            catch (Exception e){
                break;
            }
        }
    }
}


____________________________________________________________________________________________________________EXCEPTION TRUE/FALSE!!!!!
package com.javarush.test.level09.lesson11.home03;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.BufferUnderflowException;
import java.util.ArrayList;
import java.util.List;

/* Метод в try..catch
Вводить с клавиатуры числа. Код по чтению чисел с клавиатуры вынести в отдельный метод readData.
Обернуть все тело (весь код внутри readData, кроме объявления списка, где будут храниться числа и BufferedReader - а) этого метода в try..catch.
Если пользователь ввёл какой-то текст, вместо ввода числа, то метод должен перехватить исключение и вывести на экран все введенные числа в качестве результата.
Числа выводить с новой строки сохраняя порядок ввода.
*/

public class Solution
{
    public static void main(String[] args) throws Exception{
        readData();
    }

    public static void readData() throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<Integer> list = new ArrayList<Integer>();
        try
        {
            while(true)
            {
                list.add(Integer.parseInt(reader.readLine()));
            }
        }
        catch (Exception e)
        {
            for (int i1 = 0; i1 < list.size(); i1++) {
                Integer i = list.get(i1);
                System.out.println(i);
            }
        }
    }
}
	
	
	
____________________________________________________________________________________________РАБОТА С ДАТАМИ!!!!!!!!!!	
	package com.javarush.test.level09.lesson11.home04;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/* Конвертер дат
Ввести с клавиатуры дату в формате «08/18/2013»
Вывести на экран эту дату в виде «AUG 18, 2013».
Воспользоваться объектом Date и SimpleDateFormat.
*/

public class Solution {

    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/mm/yyyy");

        Date date = new Date(reader.readLine());

        SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("MMM d, yyyy", Locale.ENGLISH);

        System.out.println(simpleDateFormat1.format(date).toUpperCase());

    }
}



________________________________________________________________________________________________________СМОТРЕТЬ ДОЛГО И НУДНО!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
package com.javarush.test.level09.lesson11.home05;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Гласные и согласные буквы
Написать программу, которая вводит с клавиатуры строку текста.
Программа должна вывести на экран две строки:
1. первая строка содержит только гласные буквы
2. вторая - только согласные буквы и знаки препинания из введённой строки.
Буквы соединять пробелом, каждая строка должна заканчиваться пробелом.

Пример ввода:
Мама мыла раму.
Пример вывода:
а а ы а а у
М м м л р м .
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String s = reader.readLine();
        char[] stroka = new char[s.length()]; // Создаём массив чар, в который перенесём строку
        ArrayList<String> glas = new ArrayList<>(); // Создаю аррэй для гласных
        ArrayList<String> soglas = new ArrayList<>(); // Создаю аррэй для согласных

        for (int i = 0; i < s.length(); i++) {
            stroka[i] = s.charAt(i);  // В этом цикле переношу всё из строки s в чар массив
        }
        String temp = " ";  // создал стринг с пробелом
        char probel = temp.charAt(0); //и вставил пробел в чар переменную
        // что бы в результате не было двойных пробелов (М м  м л  р м .) - нужно их удалить.
        for (int i = 0; i < stroka.length; i++)  { //начинаем перенос каждого чара в соответствующий список
            if (stroka[i] == probel)
            continue;// если текущий чар это пробел - пропускаем чар
            else {                                                     // Если не пробел - распределяем по спискам
                if (isVowel(stroka[i]))
                    glas.add(String.valueOf(stroka[i]));                              //если гласная - в гласные
                else
                    soglas.add(String.valueOf(stroka[i]));                              //если согласная - в согласные
            }
        }
        for (int i = 0, glasSize = glas.size(); i < glasSize; i++) {
            String a = glas.get(i);
            System.out.print(a + " "); //выводим на экран глассные
        }
        System.out.println();
        for (int i = 0, soglasSize = soglas.size(); i < soglasSize; i++) {
            String a = soglas.get(i);
            System.out.print(a + " ");//выводим на экран соглассные
        }
    }


    public static char[] vowels = new char[]{'а', 'я', 'у', 'ю', 'и', 'ы', 'э', 'е', 'о', 'ё'};

    //метод проверяет, гласная ли буква
    public static boolean isVowel(char c)
    {
        c = Character.toLowerCase(c);  //приводим символ в нижний регистр - от заглавных к строчным буквам

        for (char d : vowels)   //ищем среди массива гласных
        {
            if (c == d)
                return true;
        }
        return false;
    }
}


_____________________________________________________________________________________________АБСТРАКТНЫЙ КЛАСС!!!!!!!!!!
package com.javarush.test.level09.lesson11.home06;

import java.util.ArrayList;

/* Сказка «Красная Шапочка»
1. Есть пять классов: красная шапочка, бабушка, пирожок, дровосек, волк.
2. У каждого класса есть 2 поля: убил (killed ArrayList) и съел (ate ArrayList).
3. Необходимые объекты созданы (hood, grandmother, ...).
4. Расставь правильно связи, кто кого съел и убил, чтобы получилась логика сказки «Красная Шапочка».
PS: пирожки никто не ел. Их только несли. Волк чуток поел. А его потом убили.
*/

public class Solution {
    public static LittleRedRidingHood hood = new LittleRedRidingHood();
    public static Grandmother grandmother = new Grandmother();
    public static Patty patty = new Patty();
    public static Woodman woodman = new Woodman();
    public static Wolf wolf = new Wolf();

    public static void main(String[] args) {


        wolf.ate.add(grandmother);
        wolf.ate.add(hood);
        woodman.killed.add(wolf);

    }

    //красная шапочка
    public static class LittleRedRidingHood extends StoryItem {
    }

    //бабушка
    public static class Grandmother extends StoryItem {
    }

    //пирожок
    public static class Patty extends StoryItem {
    }

    //дровосек
    public static class Woodman extends StoryItem {
    }

    //волк
    public static class Wolf extends StoryItem {
    }

    public static abstract class StoryItem {

        public ArrayList<StoryItem> killed = new ArrayList<StoryItem>();
        public ArrayList<StoryItem> ate = new ArrayList<StoryItem>();

    }
}



package com.javarush.test.level09.lesson11.home07;

/* Расставь модификаторы static
Расставь модификаторы static так, чтобы пример скомпилировался.
*/

public class Solution
{
    public static int A = 5;
    public static int B = 2 * A;
    public int C = A * B;
    public static int D = A * B;

    public void main(String[] args)
    {
        Solution room = new Solution();
        room.A = 5;

        Solution.D = 5;
    }

    public int getA()
    {
        return A;
    }

}



package com.javarush.test.level09.lesson11.home08;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Список из массивов чисел
Создать список, элементами которого будут массивы чисел. Добавить в список пять объектов–массивов длиной 5, 2, 4, 7, 0 соответственно. Заполнить массивы любыми данными и вывести их на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        ArrayList<int[]> list = createList();
        printList(list);
    }

    public static ArrayList<int[]> createList()
    {
        ArrayList<int[]> list = new ArrayList<>();
        int[] arr1 = new int[5];
        list.add(arr1);
        for (int i = 0, arr1Length = arr1.length; i < arr1Length; i++) {
            int b = (int) (Math.random());
            arr1[i] = b;
        }
        int[] arr2 = new int[2];
        list.add(arr2);
        for (int i = 0, arr1Length = arr2.length; i < arr1Length; i++) {
            int b = (int) (Math.random());
            arr2[i] = b;
        }
        int[] arr3 = new int[4];
        list.add(arr3);
        for (int i = 0, arr1Length = arr3.length; i < arr1Length; i++) {
            int b = (int) (Math.random());
            arr3[i] = b;
        }

        int[] arr4 = new int[7];
        list.add(arr4);
        for (int i = 0, arr1Length = arr4.length; i < arr1Length; i++) {
            int b = (int) (Math.random());
            arr4[i] = b;
        }
        int[] arr5 = new int[0];
        list.add(arr5);
        for (int i = 0, arr1Length = arr5.length; i < arr1Length; i++) {
            int b = (int) (Math.random());
            arr5[i] = b;
        }

        return list;
    }

    public static void printList(ArrayList<int[]> list)
    {
        for (int[] array: list )
        {
            for (int x: array)
            {
                System.out.println(x);
            }
        }
    }
}

_______________________________________________ЕЩЕ ОДНО РЕШЕНИЕ ЗАДАЧИ ВЫШЕ____________________:

public static ArrayList<int[]> createList()
{
    ArrayList<int[]> list = new ArrayList<int[]>();
    int[] a = new int[5];
    int[] b = new int[2];
    int[] c = new int[4];
    int[] d = new int[7];
    int[] f = new int[0];
    list.add(a);
    list.add(b);
    list.add(c);
    list.add(d);
    list.add(f);
    for (int j = 0; j < list.size(); j++)
    {
        int[] lol = list.get(j);
        for (int i = 0; i < lol.length; i++)
        {
            lol[i] = i;
        }
    }
    return list;//напишите тут ваш код
}
public static void printList(ArrayList<int[]> list)
{
    for (int[] array: list )
    {
        for (int x: array)
        {
            System.out.println(x);
        }
    }
}



package com.javarush.test.level09.lesson11.home09;

import com.javarush.test.level06.lesson05.task04.Cat;

import java.util.*;

/* Десять котов
Создать класс кот – Cat, с полем «имя» (String).
Создать словарь Map(<String, Cat>) и добавить туда 10 котов в виде «Имя»-«Кот».
Получить из Map множество(Set) всех имен и вывести его на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Map<String, Cat> map = createMap();
        Set<Cat> set = convertMapToSet(map);
        printCatSet(set);

    }

    public static Map<String, Cat> createMap()
    {
        HashMap<String, Cat> cats = new HashMap<String, Cat>();

        Cat cat1 = new Cat("cat1");
        Cat cat2 = new Cat("cat2");
        Cat cat3 = new Cat("cat3");
        Cat cat4 = new Cat("cat4");
        Cat cat5 = new Cat("cat5");
        Cat cat6 = new Cat("cat6");
        Cat cat7 = new Cat("cat7");
        Cat cat8 = new Cat("cat8");
        Cat cat9 = new Cat("cat9");
        Cat cat10 = new Cat("cat10");

        cats.put("cat1", cat1);
        cats.put("cat2", cat2);
        cats.put("cat3", cat3);
        cats.put("cat4", cat4);
        cats.put("cat5", cat5);
        cats.put("cat6", cat6);
        cats.put("cat7", cat7);
        cats.put("cat8", cat8);
        cats.put("cat9", cat9);
        cats.put("cat10", cat10);


        return cats;
    }

    public static Set<Cat> convertMapToSet(Map<String, Cat> map)
    {
        Set<Cat> newVariable = new HashSet<Cat>(map.values());
        return newVariable;
    }

    public static void printCatSet(Set<Cat> set)
    {
        for (Cat cat:set)
        {
            System.out.println(cat);
        }
    }

    public static class Cat
    {
        private String name;

        public Cat(String name)
        {
            this.name = name;
        }

        public String toString()
        {
            return "Cat "+ this.name;
        }
    }


}




package com.javarush.test.level08.lesson11.bonus01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

/* Номер месяца
Программа вводит с клавиатуры имя месяца и выводит его номер на экран в виде: «May is 5 month».
Используйте коллекции.
*/

public class Solution {
    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        HashMap<String, Integer> mapp = new HashMap<String, Integer>();
        mapp.put("January", 1);
        mapp.put("February", 2);
        mapp.put("March", 3);
        mapp.put("April", 4);
        mapp.put("May", 5);
        mapp.put("June", 6);
        mapp.put("July", 7);
        mapp.put("August", 8);
        mapp.put("September", 9);
        mapp.put("October", 10);
        mapp.put("November", 11);
        mapp.put("December", 12);
        String month = reader.readLine();

        System.out.println(month + " is " + mapp.get(month) + " month");
    }
}



______________________________________________________________________________СМОТРЕТЬ СОРТИРОВКА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
package com.javarush.test.level07.lesson12.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Задача по алгоритмам
Задача: Написать программу, которая вводит с клавиатуры 20 чисел и выводит их в убывающем порядке.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] array = new int[20];
        for (int i = 0; i < 20; i++) {
            array[i] = Integer.parseInt(reader.readLine());
        }

        sort(array);

        for (int i = 0, arrayLength = array.length; i < arrayLength; i++) {
            int x = array[i];
            System.out.println(x);
        }
    }

    public static void sort(int[] array) {   // создаем метод сортировки
        for (int i = 0; i < array.length - 1; i++) {    //прогоняем цикл для всего массива 
            for (int j = 0; j < array.length - i - 1; j++) {      прогоняем цикл для соседних чисел(сортировка пузырьком)
                if (array[j] < array[j + 1]) {   //условие для соседних одинаковых чисел
                    int temp = array[j];           // переменная для одинаковых
                    array[j] = array[j + 1];        //приравниваем одинаковые
                    array[j + 1] = temp;         //
                }

            }
        }
    }
}


- - - - - - - - - - - - - - - - - - - - ВАРИАНТ С МАКСИМАЛЬНЫМИ ВОЗРАСТАЮЩИМИ ДЛЯ ПРОШЛОЙ ЗАДАЧИ
package com.javarush.test.level07.lesson12.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Задача по алгоритмам
Задача: Написать программу, которая вводит с клавиатуры 20 чисел и выводит их в возрастающем ВОЗРАСТАЮЩЕМ порядке.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] array = new int[20];
        for (int i = 0; i < 20; i++) {
            array[i] = Integer.parseInt(reader.readLine());
        }

        sort(array);

        for (int i = 0, arrayLength = array.length; i < arrayLength; i++) {
            int x = array[i];
            System.out.println(x);
        }
    }

    public static void sort(int[] array) {

        for(int i = array.length-1 ; i > 0 ; i--){
            for(int j = 0 ; j < i ; j++){
            if( array[j] > array[j+1] ){
                int tmp = array[j];
                array[j] = array[j+1];
                array[j+1] = tmp;
                }

            }
        }
    }
}






package com.javarush.test.level06.lesson11.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Задача по алгоритмам
Задача: Написать программу, которая вводит с клавиатуры 5 чисел и выводит их в возрастающем порядке.
Пример ввода:
3
2
15
6
17
Пример вывода:
2
3
6
15
17
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int[] arr = new int[5];

        for (int i = 0; i < 5; i++) {
            arr[i] = Integer.parseInt(reader.readLine());
        }
        for(int i = arr.length-1 ; i > 0 ; i--){
            for(int j = 0 ; j < i ; j++){
                if( arr[j] > arr[j+1] ){
                    int tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
            }
        }
            for (int i = 0, arrayLength = arr.length; i < arrayLength; i++) {
                int x = arr[i];
                System.out.println(x);


        }
    }
}



package com.javarush.test.level09.lesson11.bonus01;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
/ Нужно исправить программу, чтобы компилировалась и работала Задача: Программа вводит два имени файла. И копирует первый файл на место заданное вторым именем. /

public class Solution
{
public static void main(String[] args) throws IOException
{
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
	
    String sourceFileName = reader.readLine();
    String destinationFileName = reader.readLine();
	
    java.io.FileInputStream fileInputStream = new java.io.FileInputStream(sourceFileName);
    java.io.FileOutputStream fileOutputStream = new java.io.FileOutputStream(destinationFileName);
    
	int count = 0;
	
    while (fileInputStream.available()>0);
    {
        int data = fileInputStream.read();
        fileOutputStream.write(data);
        count++;
    }
    System.out.println("Скопировано байт " + count);
    fileInputStream.close();
    fileOutputStream.close();
}




package com.javarush.test.level09.lesson11.bonus01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Нужно исправить программу, чтобы компилировалась и работала
Задача: Программа вводит два имени файла. И копирует первый файл на место заданное вторым именем.
*/

public class Solution
{
    public static void main(String[] args) throws IOException
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String sourceFileName = reader.readLine();
        String destinationFileName = reader.readLine();

        java.io.FileInputStream fileInputStream = new java.io.FileInputStream(sourceFileName);
        java.io.FileOutputStream fileOutputStream = new java.io.FileOutputStream(destinationFileName);

        int count = 0;

        while (fileInputStream.available()>0)
        {
            int data = fileInputStream.read();
            fileOutputStream.write(data);
            count++;
        }

        System.out.println("Скопировано байт " + count);

        fileInputStream.close();
        fileOutputStream.close();
    }
}




___________________________________________________________________________JAVA.IO!!!!!!!!!!! java.io
package com.javarush.test.level09.lesson11.bonus02;

import java.io.*;

/* Нужно добавить в программу новую функциональность
Задача: Программа вводит два имени файла. И копирует первый файл на место, заданное вторым именем.
Новая задача: Программа вводит два имени файла. И копирует первый файл на место, заданное вторым именем.
Если файла (который нужно копировать) с указанным именем не существует, то
программа должна вывести надпись «Файл не существует.» и еще раз прочитать имя файла с консоли, а уже потом считывать файл для записи.
*/

public class Solution
{
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String sourceFileName = reader.readLine();

        while (!new File(sourceFileName).exists()){
            System.out.println("Файл не существует.");
            sourceFileName = reader.readLine();
    }
        String destinationFileName = reader.readLine();

        java.io.FileInputStream fileInputStream = new java.io.FileInputStream(sourceFileName);
        java.io.FileOutputStream fileOutputStream = new java.io.FileOutputStream(destinationFileName);

        while (fileInputStream.available() > 0)
        {
            int data = fileInputStream.read();
            fileOutputStream.write(data);
        }

        fileInputStream.close();
        fileOutputStream.close();
    }
}



public class Compars {
    public static void main(String[] main){
        System.out.println(("22").compareTo("3") < 0);  ------------------------true/false!!!!
    }
}



____________________________________________________НЕ ОЧ ПРАВИЛЬНЫЙ_________________
package com.javarush.test.level09.lesson11.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Задача по алгоритмам
Задача: Пользователь вводит с клавиатуры список слов (и чисел). Слова вывести в возрастающем порядке, числа - в убывающем.
Пример ввода:
Вишня
1
Боб
3
Яблоко
2
0
Арбуз
Пример вывода:
Арбуз
3
Боб
2
Вишня
1
0
Яблоко
*/

public class Solution
{
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        ArrayList<String> list = new ArrayList<String>();

            while (true) {
                String s = reader.readLine();
                if (s.isEmpty()) break;
                list.add(s);
            }

            String[] array = list.toArray(new String[list.size()]);

            sort(array);

            for (int i = 0, arrayLength = array.length; i < arrayLength; i++) {
                String x = array[i];
                System.out.println(x);
            }
        }

    //Вы можете взять список введенных значений и проходясь по нему в цикле разбить его на два списка - список с числами и список со строками.
    // Потом по отдельности в разных циклах отсортировать их в указанных в условии порядках.
    // А потом просто берете исходный список, и начинаете бежать по нему в цикле (если попадается строка - выводите строку из отсортированного списка строк,
    // если число - число из отсортированного списка чисел). Таким образом сохраняете порядок вывода в соответствии с порядком ввода.


    public static void sort(String[] array) {

        for (int i = 0; i < array.length; i++) {

            for (int j = i + 1; j < array.length; j++) {

                if (!isNumber(array[i]) && !isNumber(array[j]) && isGreaterThan(array[i], array[j])) {
                    String s = array[i];
                    array[i] = array[j];
                    array[j] = s;
                }
                if (isNumber(array[i]) && isNumber(array[j]) && (array[i].compareTo(array[j]) < 0)) {
                    String s1 = array[i];
                    array[i] = array[j];
                    array[j] = s1;
                }
                }
            }
        }


    //Метод для сравнения строк: 'а' больше чем 'b'
    public static boolean isGreaterThan(String a, String b)
    {
        return a.compareTo(b) > 0;
    }


    //строка - это на самом деле число?
    public static boolean isNumber(String s)
    {
        if (s.length() == 0)
            return false;

        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++)
        {
            char c = chars[i];
            if ((i != 0 && c == '-') //есть '-' внутри строки
                    || (!Character.isDigit(c) && c != '-') ) // не цифра и не начинается с '-'
            {
                return false;
            }
        }
        return true;
    }
}


_______________________________________________________ЕЩЕ ВАРИАНТ  - ПРЕДФИНАЛЬНЫЙ!
package com.javarush.test.level09.lesson11.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Задача по алгоритмам
Задача: Пользователь вводит с клавиатуры список слов (и чисел). Слова вывести в возрастающем порядке, числа - в убывающем.
Пример ввода:
Вишня
1
Боб
3
Яблоко
2
0
Арбуз
Пример вывода:
Арбуз
3
Боб
2
Вишня
1
0
Яблоко
*/

public class Solution
{
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        ArrayList<String> list = new ArrayList<String>();
        

            while (true) {
                String s = reader.readLine();
                if (s.isEmpty()) break;
                list.add(s);

            }

            String[] array = list.toArray(new String[list.size()]);

            sort(array);

            for (int i = 0, arrayLength = array.length; i < arrayLength; i++) {
                String x = array[i];
                System.out.println(x);
            }
        }

    //Вы можете взять список введенных значений и проходясь по нему в цикле разбить его на два списка - список с числами и список со строками.
    // Потом по отдельности в разных циклах отсортировать их в указанных в условии порядках.
    // А потом просто берете исходный список, и начинаете бежать по нему в цикле (если попадается строка - выводите строку из отсортированного списка строк,
    // если число - число из отсортированного списка чисел). Таким образом сохраняете порядок вывода в соответствии с порядком ввода.


    public static void sort(String[] array) {

        for (int i = 0; i < array.length; i++)
        {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (isNumber(array[j])) {
                    if (!(isGreaterThan(array[j], array[j + 1]))) {
                        String tmp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = tmp;
                    }

                }
            }
                for (int a = 0; a < array.length - i - 1; a++) {
                    if (!isNumber(array[a])) {
                        if (isGreaterThan(array[a], array[a + 1])) {
                            String tmp = array[a + 1];
                            array[a + 1] = array[a];
                            array[a] = tmp;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
        }


    //Метод для сравнения строк: 'а' больше чем 'b'
    public static boolean isGreaterThan(String a, String b)
    {
        return a.compareTo(b) > 0;
    }


    //строка - это на самом деле число?
    public static boolean isNumber(String s)
    {
        if (s.length() == 0)
            return false;

        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++)
        {
            char c = chars[i];
            if ((i != 0 && c == '-') //есть '-' внутри строки
                    || (!Character.isDigit(c) && c != '-') ) // не цифра и не начинается с '-'
            {
                return false;
            }
        }
        return true;
    }
}




________________________________________________________ПРАВИЛЬНОЕ РЕШЕНИЕ ____________СМОТРЕТЬ
package com.javarush.test.level09.lesson11.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Задача по алгоритмам
Задача: Пользователь вводит с клавиатуры список слов (и чисел). Слова вывести в возрастающем порядке, числа - в убывающем.
Пример ввода:
Вишня
1
Боб
3
Яблоко
2
0
Арбуз
Пример вывода:
Арбуз
3
Боб
2
Вишня
1
0
Яблоко
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        ArrayList<String> list = new ArrayList<String>();
        while (true) {
            String s = reader.readLine();
            if (s.isEmpty()) break;
            list.add(s);
        }

        String[] array = list.toArray(new String[list.size()]);
        sort(array);

        for (int i = 0, arrayLength = array.length; i < arrayLength; i++) {
            String x = array[i];
            System.out.println(x);
        }
    }

    public static void sort(String[] array) {

        for (int j = 0; j < array.length; j++)   //цикл для ввода
        {
            String bufferString;
            for (int i = 0; i < array.length - 1; i++) //цикл для неопред. переменной
            {
                int m = 1;
                if (!isNumber(array[i]))    //если не число
                {
                    while (true) {
                        if (i + m == array.length)      //если цикл достиг размера массива
                        {
                            bufferString = "";     //буфер вывода равен ""
                            break;
                        }
                        bufferString = array[i + m];    //до тех пор пока цикл не достиг размера массива
                        if (isNumber(bufferString) || bufferString.equals(""))  //а так же если буфер равен числу или ""
                        {
                            m++;
                            continue;                                           //цикл продолжается
                        } else {
                            break;
                        }
                    }
                    if (bufferString.equals("")) {
                        continue;
                    }
                    if (isGreaterThan(array[i], bufferString)) {
                        array[i + m] = array[i];
                        array[i] = bufferString;
                    }
                }
                else {                                                     //если число

                    while (true) {
                        if (i + m == array.length) {
                            bufferString = "";
                            break;
                        }
                        bufferString = array[i + m];
                        if (!isNumber(bufferString) || bufferString.equals("")) {
                            m++;
                            continue;
                        } else {
                            break;
                        }
                    }
                    if (bufferString.equals("")) {
                        continue;
                    }
                    if (Integer.parseInt(array[i]) < Integer.parseInt(bufferString)) {
                        array[i + m] = array[i];
                        array[i] = bufferString;
                    }
                }
            }
        }
    }


    //Метод для сравнения строк: 'а' больше чем 'b'
    public static boolean isGreaterThan(String a, String b)
    {
        return a.compareTo(b) > 0;
    }


    //строка - это на самом деле число?
    public static boolean isNumber(String s)
    {
        if (s.length() == 0) return false;

        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++)
        {
            char c = chars[i];
            if ((i != 0 && c == '-') //есть '-' внутри строки
                    || (!Character.isDigit(c) && c != '-') ) // не цифра и не начинается с '-'
            {
                return false;
            }
        }
        return true;
    }
}

package com.javarush.test.level10.lesson04.task01;

/* Задача №1 на преобразование целых типов
Расставьте правильно операторы приведения типа, чтобы получился ответ: d > 0
int a = 0;
int b = (byte) a + 46;
byte c = (byte) (a*b);
double f = (char) 1234.15;
long d = (short) (a + f / c + b);
*/

public class Solution
{
    public static void main(String[] args)
    {
        int a = 0;
        int b = a + 46;
        byte c = (byte) (a*b);
        double f = 1234.15;
        long d = (long) (a + f / c + b);
        System.out.println(d);
    }
}

package com.javarush.test.level10.lesson04.task03;

/* Задача №3 на преобразование целых типов
Добавить одну операцию по преобразованию типа, чтобы получался ответ: b=0
float f = (float)128.50;
int i = (int)f;
int b = (int)(i + f);
*/

public class Solution
{
    public static void main(String[] args)
    {
        float f = (float)128.50;
        int i = (byte)f;
        int b = (byte)(i + f);
        System.out.println(b);
    }
}
//Потому что именно так работает явное приведение типов в джаве (а может и не только в джаве). 
// Если выполняется неявное приведение, при котором ширина типа целевого значения больше, чем ширина исходного типа, то все пройдет нормально. 
// Например, привести byte к int можно без проблем и никаких неожиданностей не будет. А вот когда мы пытаемся выполнить обратное приведение, 
// то наш более широкий тип может просто не поместиться в более узкий целевой. 
// При этом величина целевого типа будет равна результату деления по модулю исходного значения на диапазон целевого типа. 
// Поэтому, например, если взять число int = 500; и привести его к byte, то результат будет -12. Почитайте в интернете про 
// неявное приведение примитивных типов более подробно, информации предостаточно.



____________________________________________________________________________НА ВЫВОДЕ В СКОБКИ
package com.javarush.test.level10.lesson04.task04;

/* Задача №4 на преобразование целых типов
Добавить одну операцию по преобразованию типа, чтобы получался ответ: nine=9
short number = 9;
char zero = '0';
int nine = (zero + number);
*/

public class Solution
{
    public static void main(String[] args)
    {
        short number = 9;
        char zero = '0';
        int nine = (zero + number);
        System.out.println((char)nine);
    }
}


package com.javarush.test.level10.lesson04.task05;

/* Задача №5 на преобразование целых типов
Расставьте правильно операторы приведения типа, чтобы получился ответ: c=256
int a = (byte)44;
int b = (byte)300;
short c = (byte)(b - a);
*/

public class Solution
{
    public static void main(String[] args)
    {
        int a = 44;
        int b = 300;
        short c = (short) (b - a);
        System.out.println(c);
    }
}


int i = 5;
float f = 444.23f;
String s = "17";
Object o = f;                       //o хранит объект типа Float

if (o instanceof  Integer)
{
    Integer i2 = (Integer) o;
}
else if (o instanceof  Float)        
{
    Float f2 = (Float) o;            //отработает именно этот if
}
else if (o instanceof  String)
{
    String s2 = (String) o;
}
- Желательно выполнять такую проверку, перед каждым сужением типа, если тип сохраненного объекта на 100% не известен.



float f = 3 / 5;

В результате данного вычисления значение f будет равно… нулю!

- Мне Риша что-то подобное рассказывал…

- Да? Вот и отлично. Повторение – мать учения.

- На самом деле тут нет никакой ошибки. В делении участвуют два целых числа, поэтому происходит деление нацело,
 остаток от деления просто отбрасывается. Чтобы такого не было, нужно, чтобы хотя бы одно из двух чисел, участвующих в делении, было дробным.

- Если одно из чисел дробное, то сначала второе число будет преобразовано к дробному типу, а затем будет выполнено деление.


- Вот как можно решить данную проблему:

Запись дробного числа:
float f = 3.0f / 5.0f;
float f = 3.0f / 5;
float f = 3 / 5.0f;

- А если в делении участвуют переменные?

- Тогда – вот так:

Преобразование целой переменной в вещественную
int a = 3, b = 5;
float f = (a * 1.0f) / b;
int a = 3, b = 5;
float f = a / (b * 1.0f);
int a = 3, b = 5;
float f = (a*1.0) / (b*1.0);
int a = 3, b = 5;
float f = (float) a / b;


- На самом деле литералов несколько больше. С помощью литералов можно задать значения любых известных типов:

Литерал	Тип	Описание
123676	int	Целое число
22223333444433332222L	long	Длинное целое число
12.323232323f	float	Дробное число
12.33333333333333333d	double	Длинное дробное число
"Mama"
""
"Mama\nMila\nRamu\u123"	String	Строка
'\u3232'
'T'
'5'	char	Символ
true, false	boolean	Логический тип
null	Object	Ссылка на объект
- Т.е. код – это методы, классы, переменные,…, а литералы – это конкретные значения переменных, записанные прямо в коде. Так, я правильно понял?

- Да, так и есть.




package com.javarush.test.level10.lesson11.home01;

/* Правильный ответ: d=2.941
Добавить одну операцию по преобразованию типа, чтобы получался ответ: d=2.941.
Пример вывода: 2.9411764705882355
*/

public class Solution
{
    public static void main(String[] args)
    {
        int a = 50;
        int b = 17;
        double d = a/ (double)b;
        System.out.println(d);
    }
}


package com.javarush.test.level10.lesson11.home02;

/* Правильный ответ: d=5.5
Добавить одну операцию по преобразованию типа, чтобы получался ответ: d=5.5.
*/

public class Solution
{
    public static void main(String[] args)
    {
        int a = 5;
        int b = 4;
        int c = 3;
        int e = 2;
        double d = a + b/c/(double)e;
        System.out.println(d);
    }
}


package com.javarush.test.level10.lesson11.home03;

/* Правильный ответ: d=1.0
Добавить одну операцию по преобразованию типа, чтобы получался ответ: d=1.0.
*/

public class Solution
{
    public static void main(String[] args)
    {
        int a = 257;
        int b = 4;
        int c = 3;
        int e = 2;
        double d = (byte)a + b/c/e;

        System.out.println(d);
    }
}

__________________________________________________________________________ substring()  method
public String substring(int beginIndex)

or

public String substring(int beginIndex, int endIndex)
Parameters:
Here is the detail of parameters:

beginIndex -- the begin index, inclusive.

endIndex -- the end index, exclusive.

Return Value:
The specified substring.

Example:
import java.io.*;

public class Test{
   public static void main(String args[]){
      String Str = new String("Welcome to Tutorialspoint.com");

      System.out.print("Return Value :" );
      System.out.println(Str.substring(10) );

      System.out.print("Return Value :" );
      System.out.println(Str.substring(10, 15) );
   }
}
This produces the following result:

Return Value : Tutorialspoint.com
Return Value : Tuto





package com.javarush.test.level10.lesson11.home04;

/* Большая зарплата
Вывести на экран надпись «Я не хочу изучать Java, я хочу большую зарплату» 40 раз по образцу.
Образец:
Я не хочу изучать Java, я хочу большую зарплату
 не хочу изучать Java, я хочу большую зарплату
не хочу изучать Java, я хочу большую зарплату
е хочу изучать Java, я хочу большую зарплату
 хочу изучать Java, я хочу большую зарплату
хочу изучать Java, я хочу большую зарплату
…
*/

import java.util.ArrayList;

public class Solution {
    public static void main(String[] args) {
        String s = " Я не хочу изучать Java, я хочу большую зарплату";

        StringBuffer out = new StringBuffer(s);
        for (int i = 0; i < 40; i++) {
            out.deleteCharAt(0);
            System.out.println(out);

        }
    }
}


_______________________________________________________________StringBuilder   ПОСМОТРЕТЬ!!!!!!




_________________________________________________________________________CharAt!!!!!!!!!!!
public char charAt(int index)
Parameters:
Here is the detail of parameters:

index -- Index of the character to be returned.

Return Value:
This method Returns a char at the specified index.

Example:
public class Test {

   public static void main(String args[]) {
      String s = "Strings are immutable";
      char result = s.charAt(8);
      System.out.println(result);
   }
}
This produces the following result:

a



_________________________________________________________________________________________________String____________IndexOf____________________________________

public int indexOf(int ch): Returns the index within this string of the first occurrence of the specified character or -1 if the character does not occur.

public int indexOf(int ch, int fromIndex): Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index or -1 if the character does not occur.

int indexOf(String str): Returns the index within this string of the first occurrence of the specified substring. If it does not occur as a substring, -1 is returned.

int indexOf(String str, int fromIndex): Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. If it does not occur, -1 is returned.

Syntax:
Here is the syntax of this method:

public int indexOf(int ch )

or

public int indexOf(int ch, int fromIndex)

or

int indexOf(String str)

or

int indexOf(String str, int fromIndex)
Parameters:
Here is the detail of parameters:

ch -- a character.

fromIndex -- the index to start the search from.

str -- a string.

Return Value:
See the description.

Example:
import java.io.*;

public class Test {

   public static void main(String args[]) {
      String Str = new String("Welcome to Tutorialspoint.com");
      String SubStr1 = new String("Tutorials");
      String SubStr2 = new String("Sutorials");

      System.out.print("Found Index :" );
      System.out.println(Str.indexOf( 'o' ));
      System.out.print("Found Index :" );
      System.out.println(Str.indexOf( 'o', 5 ));
      System.out.print("Found Index :" );
      System.out.println( Str.indexOf( SubStr1 ));
      System.out.print("Found Index :" );
      System.out.println( Str.indexOf( SubStr1, 15 ));
      System.out.print("Found Index :" );
      System.out.println(Str.indexOf( SubStr2 ));
   }
}
This produces the following result:

Found Index :4
Found Index :9
Found Index :11
Found Index :-1
Found Index :-1




package com.javarush.test.level10.lesson11.home05;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Количество букв
Ввести с клавиатуры 10 строчек и подсчитать в них количество различных букв (для 33 букв алфавита).  Вывести результат на экран.
Пример вывода:
а 5
б 8
в 3
г 7
д 0
…
я 9
*/

public class Solution
{
    public static void main(String[] args)  throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        //алфавит
        String abc = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
        char[] abcArray = abc.toCharArray();

        ArrayList<Character> alphabet = new ArrayList<Character>();
        for (int i = 0; i < abcArray.length; i++)
        {
            alphabet.add(abcArray[i]);
        }

        //ввод строк
        ArrayList<String> list = new ArrayList<String>();
        for (int i = 0; i < 10; i++) {
            String s = reader.readLine();
            list.add(s.toLowerCase());
        }

        for (int j = 0; j < alphabet.size(); j++) {    //проходимся по массиву алфавита
            char ch = alphabet.get(j);                //присваиваем переменной char ch каждую букву алфавита
            int count = 0;                            //вводим переменную COUNT для определения кол-ва букв алфавита по номеру буквы в алфавите
            for (int k = 0; k < list.size(); k++) {       //проходимся циклом по вводу строк
                String s = list.get(k);                     //приваиваем переменной String s каждую из десяти строк
                for (int i = 0; i < s.length(); i++) {      //проходмся циклом по КАЖДОЙ ВВЕДЕННОЙ СТРОКЕ
                    if (ch == s.charAt(i)) {               //если буква из алфавита равна
                        count++;                          //тогда итерация переменной COUNT
                    }
                }
            }
            System.out.println(ch + " " + count);
        }

        }

    }
	
	
	
	

package com.javarush.test.level10.lesson11.home06;

/* Конструкторы класса Human
Напиши класс Human с 6 полями. Придумай и реализуй 10 различных конструкторов для него. Каждый конструктор должен иметь смысл.
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public static class Human
    {
        public String name;
        public int age;
        public int weight;
        public int height;
        public boolean sex;
        public Human kids;


        public  Human(String name)
        {
            this.name = name;
        }
        public Human(String name, int age)
        {
            this.name = name;
            this.age = age;
        }
        public  Human(String name, int age, boolean sex)
        {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
        public  Human(String name, int age, boolean sex, Human kids)
        {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.kids = kids;
        }
        public  Human(String name, int age, int height, int weight, boolean sex, Human kids)
        {
            this.name = name;
            this.age = age;
            this.height = height;
            this.weight = weight;
            this.sex = sex;
            this.kids = kids;
        }
        public  Human(String name, int age, Human kids)
        {
            this.name = name;
            this.age = age;
            this.kids = kids;
        }
        public  Human(String name, boolean sex)
        {
            this.name = name;
            this.sex = sex;
        }
        public  Human(String name, Human kids)
        {
            this.name = name;
            this.kids = kids;
        }
        public  Human(String name, int height, int weight)
        {
            this.name = name;
            this.height = height;
            this.weight = weight;
        }
        public  Human(int height, int weight)
        {
            this.height = height;
            this.weight = weight;
        }

    }
}


package com.javarush.test.level10.lesson11.home07;

/* Расставьте минимум static-ов
Расставьте как можно меньше модификаторов static так, чтобы пример скомпилировался.
*/

public class Solution
{
    public int A = 5;
    public static int B = 5;
    public static int C = 5;
    public static int D = 5;

    public static void main(String[] args)
    {
        Solution solution = new Solution();
        solution.A = 5;
        solution.B = 5 * B;
        solution.C = 5 * C * D;
        Solution.D = 5 * D * C;

        Solution.D = 5;
    }

    public int getA()
    {
        return A;
    }

}




package com.javarush.test.level10.lesson11.home08;

import java.util.ArrayList;

/* Массив списков строк
Создать массив, элементами которого будут списки строк. Заполнить массив любыми данными и вывести их на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        ArrayList<String>[] arrayOfStringList =  createList();
        printList(arrayOfStringList);
    }

    public static ArrayList<String>[] createList()
    {

        ArrayList<String> list2 = new ArrayList<String>();

        list2.add("efseffesfe");

        ArrayList<String>[] list1 = new ArrayList[1];

        list1[0] = list2;

        return list1;
    }

    public static void printList(ArrayList<String>[] arrayOfStringList)
    {
        for (int i = 0, arrayOfStringListLength = arrayOfStringList.length; i < arrayOfStringListLength; i++) {
            ArrayList<String> list = arrayOfStringList[i];
            for (int i1 = 0, listSize = list.size(); i1 < listSize; i1++) {
                String s = list.get(i1);
                System.out.println(s);
            }
        }
    }
}




package com.javarush.test.level10.lesson11.home09;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Одинаковые слова в списке
Ввести с клавиатуры в список 20 слов. Нужно подсчитать количество одинаковых слов в списке.
Результат нужно представить в виде словаря Map<String, Integer>, где первый параметр – уникальная строка,
а второй – число, сколько раз данная строка встречалась в списке.
Вывести содержимое словаря на экран.
В тестах регистр (большая/маленькая буква) НЕ______________________________ влияет на результат.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> words = new ArrayList<String>();   //создаем спиок строк для считываемых слов
        for (int i = 0; i < 20; i++) {
            words.add(reader.readLine());
        }

        Map<String, Integer> map = countWords(words);             //создаем мапу со строками и числами и применяем к ней метод считывания кол-ва повторений строк

        for (Map.Entry<String, Integer> pair : map.entrySet())                     //цикл для вывода
        {
            System.out.println(pair.getKey() + " " + pair.getValue());
        }
    }

    public static Map<String, Integer> countWords(ArrayList<String> list)       //создаем метод считывания кол-ва повторений строк
    {
        HashMap<String, Integer> result = new HashMap<String, Integer>();

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String s = iterator.next();
            if (!(result.containsKey(s))) {
                result.put(s, 1);
            }
            else {
                int count = result.get(s);
                count++;
                result.put(s, count);

            }
        }
        return result;
    }

}





package com.javarush.test.level10.lesson11.home09;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Одинаковые слова в списке
Ввести с клавиатуры в список 20 слов. Нужно подсчитать количество одинаковых слов в списке.
Результат нужно представить в виде словаря Map<String, Integer>, где первый параметр – уникальная строка,
а второй – число, сколько раз данная строка встречалась в списке.
Вывести содержимое словаря на экран.
В тестах регистр (большая/маленькая буква) ВЛИЯТ_______________________ на результат.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> words = new ArrayList<String>();   //создаем спиок строк для считываемых слов
        for (int i = 0; i < 20; i++) {
            words.add(reader.readLine());
        }

        Map<String, Integer> map = countWords(words);             //создаем мапу со строками и числами и применяем к ней метод считывания кол-ва повторений строк

        for (Map.Entry<String, Integer> pair : map.entrySet())                     //цикл для вывода
        {
            System.out.println(pair.getKey() + " " + pair.getValue());
        }
    }

    public static Map<String, Integer> countWords(ArrayList<String> list)       //создаем метод считывания кол-ва повторений строк
    {
        HashMap<String, Integer> result = new HashMap<String, Integer>();

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String s = iterator.next();
			s.toLowerCase();
            if (!(result.containsKey(s))) {
                result.put(s, 1);
            }
            else {
                int count = result.get(s);
                count++;
                result.put(s, count);

            }
        }
        return result;
    }

}



_________________________________________________________________ЕЩЕ ОДНО РЕШЕНИЕ ПРЕД.ВАР-ТА С ИНВЕРТИРОВАННЫМ ЦИКЛОМ ДЛЯ ITERATOR!
public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<String> words = new ArrayList<String>();   //создаем спиок строк для считываемых слов
        for (int i = 0; i < 20; i++) {
            words.add(reader.readLine());
        }

        Map<String, Integer> map = countWords(words);             //создаем мапу со строками и числами и применяем к ней метод считывания кол-ва повторений строк

        for (Map.Entry<String, Integer> pair : map.entrySet())                     //цикл для вывода
        {
            System.out.println(pair.getKey() + " " + pair.getValue());
        }
    }

    public static Map<String, Integer> countWords(ArrayList<String> list)       //создаем метод считывания кол-ва повторений строк
    {
        HashMap<String, Integer> result = new HashMap<String, Integer>();

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String s = iterator.next();
            s.toLowerCase();
            if ((result.containsKey(s))) {
                int count = result.get(s);
                count++;
                result.put(s, count);
            }
            else {
                result.put(s, 1);
            }
        }
        return result;
    }

}


_______________________________________________________________________Положить в мапу и вывести с помощью iterator!______________-
package HeadsFirst;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Created by Кира on 15.04.2016.
 */
public class Iter {
    public static void main(String[] args) {
        Map<String, String> pets = new HashMap<String, String>();
        pets.put("Мурзик", "кот");
        pets.put("Бобик", "собака");
        pets.put("Кеша", "попугай");

        Iterator<Map.Entry<String, String>> iterator = pets.entrySet().iterator();

        while (iterator.hasNext()) {

            Map.Entry pet = (Map.Entry) iterator.next();
            System.out.println(pet.getKey() + " это " + pet.getValue());
        }
    }
}




package com.javarush.test.level10.lesson11.home10;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/* Безопасное извлечение из списка
Создать список целых чисел. Ввести с клавиатуры 20 целых чисел. Создать метод по безопасному извлечению чисел из списка:
int safeGetElement(ArrayList<Integer> list, int index, int defaultValue)
Метод должен возвращать элемент списка (list) по его индексу (index). Если в процессе получения элемента возникло исключение, 
его нужно перехватить, и метод должен вернуть defaultValue.
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        ArrayList<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < 20; i++) {
            int x = Integer.parseInt(reader.readLine());
            list.add(x);
        }

        System.out.println(safeGetElement(list, 5, 1));
        System.out.println(safeGetElement(list, 20, 7));
        System.out.println(safeGetElement(list, -5, 9));
    }

    public static int safeGetElement(ArrayList<Integer> list, int index, int defaultValue) {

        try{
            return list.get(index);
        }
        catch(Exception e){
            return defaultValue;
        }
    }
}



ИНКАПСУЛЯЦИЯ
Например, мы хотим, чтобы все могли узнать количество элементов в нашей коллекции, 
но никто не мог его поменять без нашего разрешения. Тогда мы объявляем переменную private int count и метод public getCount().

Правильное использование инкапсуляции гарантирует, что ни один класс не может получить прямой доступ к внутренним данным нашего класса и, 
следовательно, изменить их без контроля с нашей стороны. Только через вызов методов того же класса, что и изменяемые переменные.




package com.javarush.test.level11.lesson08.task02;

/* Доступ есть
Скрыть все внутренние переменные класса Cat, но только те, к которым остается доступ с помощью методов.
*/

public class Solution
{
    public static void main(String[] args)
    {
    }

    public class Cat
    {
        private String name;
        private int age;
        public int weight;

        public Cat(String name, int age, int weight)
        {
            this.name = name;
            this.age = age;
            this.weight = weight;
        }

        public String getName()
        {
            return name;
        }

        public void setName(String name)
        {
            this.name = name;
        }

        public int getAge()
        {
            return age;
        }

        public void setAge(int age)
        {
            this.age = age;
        }
    }
}



package com.javarush.test.level11.lesson06.task05;

/* ИТ-компания
Написать девять классов: Worker(сотрудник), Clerk (клерк), IT (ИТ-специалист), Programmer(программист), ProjectManager(менеджер проекта), CTO(технический директор), HR(рекрутер), OfficeManager(офис-менеджер), Cleaner (уборщик).
Унаследовать программиста, менеджера проекта и технического директора от ИТ-специалиста.
Унаследовать рекрутера, уборщика и офис-менеджера от клерка.
Унаследовать клерка и ИТ-специалиста от сотрудника.
*/

public class Solution
{
    public static void main(String[] args)
    {
    }

    public class Worker
    {

    }

    public class Clerk extends Worker
    {

    }

    public class IT extends Worker
    {

    }

    public class Programmer extends IT
    {

    }

    public class ProjectManager extends IT
    {

    }

    public class CTO extends IT
    {

    }

    public class OfficeManager extends Clerk
    {

    }

    public class HR extends Clerk
    {

    }

    public class Cleaner extends Clerk
    {

    }
}




package com.javarush.test.level11.lesson08.task04;

/* Инкапсуляция для классов Cat и Dog
Скрыть все внутренние переменные класса Cat и Dog. Также скрыть все методы, кроме тех, с помощью которых эти классы взаимодействуют друг с другом.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Cat cat = new Cat("Vaska",5);
        Dog dog = new Dog("Sharik",4);

        System.out.println(cat.isDogNear(dog));
        System.out.print(dog.isCatNear(cat));
    }

    public static class Cat
    {
        private String name;
        private int speed;

        public Cat(String name, int speed)
        {
            this.name = name;
            this.speed = speed;
        }

        private String getName()
        {
            return name;
        }

        private int getSpeed()
        {
            return speed;
        }

        public boolean isDogNear(Dog dog)
        {
            return this.speed > dog.getSpeed();
        }
    }

    public static  class Dog
    {
        private String name;
        private int speed;

        public Dog(String name, int speed)
        {
            this.name = name;
            this.speed = speed;
        }

        private String getName()
        {
            return name;
        }

        private int getSpeed()
        {
            return speed;
        }

        public boolean isCatNear(Cat cat)
        {
            return this.speed > cat.getSpeed();
        }
    }
}




package com.javarush.test.level11.lesson08.task05;

/* Добавь недостающие переменные
Посмотри внимательно на методы и добавь недостающие переменные.
*/


public class Solution
{
    public static void main(String[] args)
    {

    }

    public class Cat
    {

        private String name;
        private int age;
        private int weight;
        private int speed;

        public Cat(String name, int age, int weight, int speed)
        {
            this.name = name;
            this.age = age;
            this.weight = weight;
            this.speed = speed;
        }

        public String getName()
        {
            return name;
        }

        public int getAge()
        {
            return 0;
        }

        public void setWeight(int weight)
        {
            this.weight = weight;

        }

        public void setSpeed(int speed)
        {
            this.speed = speed;

        }
    }
}




package com.javarush.test.level11.lesson11.home05;

/* От школьника к рабству
Написать четыре класса: Schoolboy(школьник), Student(студент), Worker(Сотрудник), Slave (Раб)
Унаследовать студента от школьника, сотрудника от студента, раба от сотрудника.
*/

public class Solution
{
    public static void main(String[] args)
    {
    }

    public class Schoolboy
    {

    }

    public class Student extends Schoolboy
    {

    }

    public class Worker extends Student
    {

    }

    public class Slave extends Worker
    {

    }

}


package com.javarush.test.level11.lesson11.home07;

/* Вторая правильная «цепочка наследования»
Расставь правильно «цепочку наследования» в классах: Carnivora (плотоядное животное), Cow (корова), Dog(собака), Pig(свинья), Animal (животное).
*/

public class Solution
{
    public static void main(String[] args)
    {
    }

    public class Carnivora extends Animal
    {

    }

    public class Cow extends Animal
    {

    }

    public class Dog extends Carnivora
    {

    }

    public class Pig extends Animal
    {

    }

    public class Animal
    {

    }
}


package com.javarush.test.level11.lesson11.home10;

/* Пятая правильная «цепочка наследования»
Расставь правильно «цепочку наследования» в классах: House (дом), Cat (кот), Dog(собака), Car (машина), Animal(животное), Assets (имущество).
*/

public class Solution
{
    public static void main(String[] args)
    {
    }

    public class House extends Assets
    {

    }

    public class Cat extends Animal
    {

    }

    public class Car extends Assets
    {

    }

    public class Dog extends Animal
    {

    }

    public class Animal
    {

    }

    public class Assets
    {

    }
}


package com.javarush.test.level10.lesson11.bonus01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/* Нужно исправить программу, чтобы компилировалась и работала
Задача: Программа демонстрирует работу HashMap: вводит с клавиатуры набор пар (номер и строку), помещает их в HashMap и выводит на экран содержимое HashMap.
*/

public class Solution {

    public static void main(String[] args) throws IOException {

        HashMap<Integer, String> map = new HashMap<Integer, String>();

        Solution solution = new Solution();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        for (int i = 0; i < 10; i++) {
            int index = Integer.parseInt(reader.readLine());
            String name = reader.readLine();
            map.put(index, name);
        }

        for (Map.Entry<Integer, String> pair : map.entrySet()) {
            int index = pair.getKey();
            String name = pair.getValue();

                System.out.println("Id=" + index + " Name=" + name);
            }
        }
    }

	
	
	
	
	__________________________________________________________________________________СМОТРЕТЬ И УЧИТЬСЯ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!_________________________
package com.javarush.test.level10.lesson11.bonus02;

import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Нужно добавить в программу новую функциональность
Задача: Программа вводит с клавиатуры пару (число и строку) и выводит их на экран.
Новая задача: Программа вводит с клавиатуры пары (число и строку), сохраняет их в HashMap.
Пустая строка – конец ввода данных. Числа могу повторяться. Строки всегда уникальны. Введенные данные не должны потеряться!
Затем программа выводит содержание HashMap на экран.

Пример ввода:
1
Мама
2
Рама
1
Мыла

Пример вывода:
1 Мыла
2 Рама
1 Мама
*/

public class Solution {
    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        Map<String,Integer> map = new HashMap<>();
        int id;
        String name;
        String tmp = reader.readLine();
        while(true)
        {
            if (!tmp.isEmpty())
            {
                id =Integer.parseInt(tmp);
                name = reader.readLine();
                if(name.isEmpty())
                    break;
                map.put(name, id);
                tmp = reader.readLine();
            }
            else break;
        }
        Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();

        while (iterator.hasNext())
        {
            //получение «пары» элементов
            Map.Entry<String, Integer> pair = iterator.next();
            String key = pair.getKey();            //ключ
            Integer value = pair.getValue();        //значение
            System.out.println(value + " " + key);
        }
    }

}




package com.javarush.test.level11.lesson11.bonus02;

/* Нужно добавить в программу новую функциональность
Добавь общий базовый класс к классам-фигур:  (фигуры из шахмат).
*/

public class Solution
{
    public static void main(String[] args)
    {
        
    }

    public class King extends Chesitem
    {
    }

    public class Queen extends Chesitem
    {
    }

    public class Rook extends Chesitem
    {
    }

    public class Knight extends Chesitem
    {
    }

    public class Bishop extends Chesitem
    {
    }

    public class Pawn extends Chesitem
    {
    }
    public static class Chesitem{

    }
}


__________________________________________________________________________________СМОТРЕТЬ!
package com.javarush.test.level11.lesson11.bonus03;

/* Задача по алгоритмам
Написать метод, который возвращает минимальное и максимальное числа в массиве.
*/


public class Solution
{
    public static void main(String[] args) throws Exception
    {
        int[] data = new int[]{1, 2, 3, 5, -2, -8, 0, 77, 5, 5};

        Pair<Integer, Integer> result = getMinimumAndMaximum(data);

        System.out.println("Minimum is " + result.x);
        System.out.println("Maximum is " + result.y);
    }

    public static Pair<Integer, Integer> getMinimumAndMaximum(int[] array) {
        if (array == null || array.length == 0) {
            return new Pair<Integer, Integer>(null, null);
        }

        for (int i = 0; i < array.length - 1; i++) {
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < array[i]) {
                    int temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }

            return new Pair<Integer, Integer>(array[0], array[array.length-1]);
        }


    public static class Pair<X, Y>
    {
        public X x;
        public Y y;

        public Pair(X x, Y y)
        {
            this.x = x;
            this.y = y;
        }

    }
}


Полиморфизм. Приведение типов._____________________________________________________________________________________________________________________
Cow cow = new Whale();	Классическое сужение типа. Теперь у объекта типа Whale можно вызывать только методы, описанные в классе Cow.
Компилятор разрешит вызвать у переменной cow только те методы, которые есть у ее типа - класса Cow.

ЕЩЕ

Cow cow = new Whale();
if (cow instanceof Whale)
{
 Whale whale = (Whale) cow;
}	
Классическое расширение типа с проверкой. Переменная cow типа Cow, хранит ссылку на объект класса Whale.
Мы проверяем, что это так и есть, и затем выполняем операцию преобразования (расширения) типа. Или как ее еще называют – type cast.

ИЛИ

Cow cow = new Cow();
Whale whale = (Whale) cow; //exception	Ссылочное расширение типа можно провести и без проверки типа объекта.
!!!!!При этом, если в переменной cow хранился объект не класса Whale, будет сгенерировано исключение – InvalidClassCastException.

ВЫЗОВ ОРИГИНАЛЬНОГО МЕТОДА

Иногда тебе хочется не заменить унаследованный метод на свой при переопределении метода, а лишь немного дополнить его.

В этом случае очень хочется исполнить в новом методе свой код и вызвать этот же метод, но базового класса. И такая возможность в Java есть. Делается это так: super.method().

Примеры:

Код	Описание
class Cow
{
 public void printAll()
 {
  printColor();
  printName();
 }
 public void printColor()
 {
  System.out.println("Я – белый");
 }
 public void printName()
 {
  System.out.println("Я – корова");
 }
}

class Whale extends Cow
{
 public void printName()
 {
  System.out.print("Это неправда: ");
  super.printName();

  System.out.println("Я – кит");
 }
}	
public static void main(String[] args)
{
 Whale whale = new Whale();
 whale.printAll();
}




package com.javarush.test.level12.lesson02.task01;

/* Я не корова, Я - кит.
Переопределить метод getName в классе Whale(Кит), чтобы программа выдавала:
Я не корова, Я - кит.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Whale whale = new Whale();

        System.out.println(whale.getName());
    }

    public static class Cow
    {
        public String getName()
        {
            return "Я не корова, Я - кит.";
        }
    }

    public static class Whale extends Cow
    {

    }
}



package com.javarush.test.level12.lesson02.task02;

/* Ничего не выводится на экран
Переопределить метод getName в классе Whale(Кит), чтобы программа ничего не выдавала на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Whale whale = new Whale();

        System.out.println(whale.getName());
    }

    public static class Cow
    {
        public String getName()
        {
            return "";
        }
    }

    public static class Whale extends Cow
    {

    }
}




____________________________________________________________________________________________________InstanceOf____________!!!!!!!!!!!!!!!!!!!!!!!!
package com.javarush.test.level12.lesson02.task04;

/* Или «Кошка», или «Собака», или «Птица», или «Лампа»
Написать метод, который определяет, объект какого класса ему передали, и выводит на экран одну из надписей: Кошка, Собака, Птица, Лампа.
*/

public class Solution
{
    public static void main(String[] args)
    {
        printObjectType(new Cat());
        printObjectType(new Bird());
        printObjectType(new Lamp());
        printObjectType(new Cat());
        printObjectType(new Dog());
    }

    public static void printObjectType(Object o)
    {
        if(o instanceof Cat)
            System.out.println("Кошка");
        if(o instanceof Dog)
            System.out.println("Собака");
        if(o instanceof Bird)
            System.out.println("Птица");
        if(o instanceof Lamp)
            System.out.println("Лампа");
    }

    public static class Cat
    {
    }

    public static class Dog
    {
    }

    public static class Bird
    {
    }

    public static class Lamp
    {
    }
}



package com.javarush.test.level12.lesson02.task05;

/* Или «Корова», или «Кит», или «Собака», или «Неизвестное животное»
Написать метод, который определяет, объект какого класса ему передали, и возвращает результат – одно значение из: «Корова», «Кит», «Собака», «Неизвестное животное».
*/

public class Solution
{
    public static void main(String[] args)
    {
        System.out.println(getObjectType(new Cow()));
        System.out.println(getObjectType(new Dog()));
        System.out.println(getObjectType(new Whale()));
        System.out.println(getObjectType(new Pig()));
    }

    public static String getObjectType(Object o)
    {
        if(o instanceof Cow)
            return "Корова";
        if(o instanceof Dog)
            return "Собака";
        if(o instanceof Whale)
            return "Кит";
        else
        return "Неизвестное животное";
    }

    public static class Cow
    {
    }

    public static class Dog
    {
    }

    public static class Whale
    {
    }

    public static class Pig
    {
    }
}



package com.javarush.test.level12.lesson04.task02;

/* print(int) и print(Integer)
Написать два метода: print(int) и print(Integer).
Написать такой код в методе main, чтобы вызвались они оба.
*/

public class Solution
{
    public static void main(String[] args)
    {

        Solution s = new Solution();
        s.print(1);
        s.print(12);

    }

    void print(int a){

        System.out.println(a);
    }
    void print(Integer b){

        System.out.println(b);
    }
}



package com.javarush.test.level12.lesson04.task03;

/* Пять методов print с разными параметрами
Написать пять методов print с разными параметрами.
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    void print(Integer a){

    }
    void print(int a){

    }
    void print(String a){

    }
    void print(boolean a){

    }
    void print(double a){

    }

}


________________________________________________________________________________________________________ВОЗВРАТ МИНИМУМА
package com.javarush.test.level12.lesson04.task04;

/* Три метода возвращают минимальное из двух переданных в него чисел
Написать public static методы: int min(int, int), long min(long, long), double min(double, double).
Каждый метод должен возвращать минимальное из двух переданных в него чисел.
*/

public class Solution
{
    public static void main(String[] args)
    {


    }

    public static int min(int a, int b){

        return a < b ? a : b;                         !!!!!!!!!!!!!!!!if (a < b) return a;
                                                                            else return b;
    }
    public static long min(long c, long d){

        return c < d ? c : d;
    }
    public static double min(double e, double f){

        return e < f ? e : f;              
    }
}

___________________________________________________________________________ТО ЖЕ САМОЕ С МАКСИМУМОМ
package com.javarush.test.level12.lesson04.task05;

/* Три метода возвращают максимальное из двух переданных в него чисел
Написать public static методы: int max(int, int), long max (long, long), double max (double, double).
Каждый метод должен возвращать максимальное из двух переданных в него чисел.
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public static int max(int a, int b){
        return a > b ? a : b;
    }
    public static long max(long a, long b){
        return a > b ? a : b;
    }
    public static double max(double a, double b){
        return a > b ? a : b;
    }
}

- Теперь представь, что у каждой фигуры есть метод, который занимается ее отрисовкой на экране. Вызываешь метод, и фигура сама себя рисует в своих текущих координатах. Удобно было бы вынести этот метод в базовый класс?

- Да. После того, что я узнал о полиморфизме, можно было бы вызывать метод отрисовки для всех фигур, независимо от их типа. Примерно так:

Пример
class ChessBoard
{
  public void drawAllChessItems()
  {
  //добавляем фигуры в список
  ArrayList<ChessItem> items = new ArrayList<ChessItem>();
  items.add(new King());
  items.add(new Queen());
  items.add(new Bishop());

  //рисуем их независимо от их типа.
  for (ChessItem item: items)
  {
   item.draw(); 
  }
 }
}


















































package com.javarush.test.level12.lesson06.task05;

/* Классы Cat и Dog от Pet
Унаследуй классы Cat и Dog от Pet.
Реализуй недостающие методы. Классы Cat и Dog не должны быть абстрактными.
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public static abstract class Pet
    {
        public abstract String getName();
        public abstract Pet getChild();
    }

    public static class Cat extends Pet
    {
        public String getName(){

            return null;
        }
        public Pet getChild(){

            return null;
        }

    }

    public static class Dog extends Pet
{
        public String getName(){

            return null;
        }
        public Pet getChild(){

            return null;
        }
    }

}


interface Moveable
{
void move(String newAddress);
}
- соответствует способности передвигаться.
interface Driveable
{
void drive(Driver driver);
}	- соответствует способности управляться водителем.
interface Transport
{
void addStaff(Object staff);
Object removeStaff();
}	- соответствует способности перевозить грузы.
class Wheel implements Moveable
{
...
}	- класс «колесо». Обладает способностью передвигаться.
class Car implements Moveable, Driveable,   Transport
{
...
}	- класс «машина». Обладает способностью передвигаться, управляться человеком и перевозить грузы.
class Skateboard implements Moveable, Driveable
{
...
}





Представь, что ты – робот-строитель и у тебя в подчинении есть десятки роботов, каждый из которых может иметь несколько профессий. Тебе нужно срочно достроить стену. Ты просто берешь всех роботов, у которых есть способность «строитель» и говоришь им строить стену. Тебе все равно, что это за роботы. Хоть робот-поливалка. Если он умеет строить – пусть идет строить.

Вот как это выглядело бы в коде:

Код	Описание
static interface WallBuilder
{
void buildWall();
}	- способность «строитель стен». Понимает команду «(по)строить стену» - имеет соответствующий метод.
static class РабочийРобот implements WallBuilder
{
void buildWall()
 {
…
 }
}
static class РоботСторож implements WallBuilder
{
void buildWall()
 {
…
 }
}
static class Поливалка
{
…
}
- роботы у которых есть эта профессия/особенность.

- для удобства я сделал классам имена на русском. Такое допускается в java, но крайне нежелательно.

- поливалка не обладает способностью строить стены (не реализует интерфейс WallBuilder).
public static void main(String[] args)
{
 //добавляем всех роботов в список
 ArrayList robots = new ArrayList(); 
 robots.add(new РабочийРобот());
 robots.add(new РоботСторож());
 robots.add(new Поливалка());

 //строить стену, если есть такая способность
 for (Object robot: robots)
 {
  if (robot instanceof WallBuilder)
  {
   WallBuilder builder = (WallBuilder) robot;
   builder.buildWall();
   } 
  }
 }
}




package com.javarush.test.level12.lesson09.task02;

/* Интерфейсы Fly, Run, Swim
Напиши public интерфейсы Fly(летать), Run(бежать/ездить), Swim(плавать).
Добавить в каждый интерфейс по одному методу.
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public interface Fly{
       void fly();
    }
    public interface Run{
        void run();
    }
    public interface Swim{
        void swim();
    }

}



package com.javarush.test.level12.lesson09.task03;

/* Fly, Move, Eat для классов Dog, Car, Duck, Airplane
Есть public интерфейсы Fly(летать), Move(передвигаться), Eat(есть).
Добавь эти интерфейсы классам Dog(собака), Car(автомобиль), Duck(утка), Airplane(самолет).
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public interface Fly
    {
        public void fly();

        void move();
    }

    public interface Move
    {
        public void move();
    }

    public interface Eat
    {
        public void eat();
    }

    public class Dog implements Move, Eat
    {
        @Override
        public void eat() {

        }

        @Override
        public void move() {

        }
    }

    public class Duck implements Eat, Fly, Move
    {

        @Override
        public void eat() {

        }

        @Override
        public void fly() {

        }

        @Override
        public void move() {

        }
    }

    public class Car implements Move
    {
        @Override
        public void move() {

        }
    }

    public class Airplane implements Fly, Move
    {
        @Override
        public void fly() {

        }

        @Override
        public void move() {

        }

    }
}


package com.javarush.test.level12.lesson09.task04;

/* Fly, Run, Swim для классов Human, Duck, Penguin, Airplane
Есть public интерфейсы Fly(летать), Run(бежать/ездить), Swim(плавать).
Добавь эти интерфейсы классам Human(человек), Duck(утка), Penguin(пингвин), Airplane(самолет).
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public interface Fly
    {
        public void fly();
    }

    public interface Run
    {
        public void run();
    }

    public interface Swim
    {
        public void swim();
    }


    public class Human implements Run,  Swim
    {

        @Override
        public void run() {

        }

        @Override
        public void swim() {

        }
    }

    public class Duck implements Swim, Fly, Run
    {

        @Override
        public void fly() {

        }

        @Override
        public void swim() {

        }

        @Override
        public void run() {

        }
    }

    public class Penguin implements Run, Swim
    {

        @Override
        public void run() {

        }

        @Override
        public void swim() {

        }
    }

    public class Airplane implements Run, Fly
    {

        @Override
        public void fly() {

        }

        @Override
        public void run() {

        }
    }
}




package com.javarush.test.level12.lesson09.task05;

/* Класс Human и интерфейсы Run, Swim
Напиши public класс Human(человек) и  public интерфейсы Run(бежать/ездить), Swim(плавать).
Добавь в каждый интерфейс по одному методу.
Добавь эти интерфейсы классу Human, но не реализуй методы.
Объяви класс Human абстрактным.
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public interface Run{
        void fast();
    }

    public interface Swim{
        void ener();
    }

    public abstract class Human implements Run, Swim
    {

    }

}



http://wikijava.it-cache.net/index.php@title=Glava_8_Thinking_in_Java_4th_edition.html
ЧИТАТЬ ОБЯЗАТЕЛЬНО!!!!!!!







package com.javarush.test.level12.lesson12.home01;

/* Метод getName в классе Cat
Переопредели метод getName в классе Cat так, чтобы программа выдавала на экран надпись
«Я - кот».
*/

public class Solution
{
    public static void main(String[] args)
    {
        Pet pet = new Cat();

        System.out.println(pet.getName());
    }

    public static class Pet
    {
        public String getName()
        {
            return "Я - пушистик";
        }
    }

    public static class Cat extends Pet
    {
        public String getName()
        {
            return "Я - кот";
        }

    }
}



package com.javarush.test.level12.lesson12.home02;

/* Метод setName в классе Cat
Переопредели метод setName в классе Cat так, чтобы программа выдавала на экран надпись
«Я - кот».
*/

public class Solution {
    public static void main(String[] args) {
        Pet pet = new Cat();
        pet.setName("Я - пушистик");

        System.out.println(pet.getName());
    }

    public static class Pet {
        protected String name;

        public Pet() {
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = "Я - кот";
        }

    }

    public static class Cat extends Pet {
            @Override
            public void setName (String name){
                super.setName("Я - кот");

            }

        }
    }

	
	package com.javarush.test.level12.lesson12.home03;

/* Добавь один метод в класс Cat
Добавь один метод в класс Cat так, чтобы программа ничего не выводила на экран.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Pet pet = new Cat();
        pet.setName("Я - пушистик");

        System.out.println(pet.getName());
    }

    public static class Pet
    {
        protected String name;

        public Pet()
        {
        }

        public String getName()
        {
            return name;
        }

        public void setName(String name)
        {
            this.name = name;
        }

    }

    public static class Cat extends Pet
    {
        public final String getName()
        {
            return "";
        }

    }
}


package com.javarush.test.level12.lesson12.home04;

/* Что это? «Кот», «Тигр», «Лев», «Бык», «хз»
Напиши метод, который определяет, какой объект передали в него.
Программа должна выводить на экран одну из надписей:
«Кот», «Тигр», «Лев», «Бык», «хз».
*/

public class Solution {
    public static void main(String[] args) {
        System.out.println(getObjectType(new Cat()));
        System.out.println(getObjectType(new Tiger()));
        System.out.println(getObjectType(new Lion()));
        System.out.println(getObjectType(new Bull()));
        System.out.println(getObjectType(new Pig()));
    }

    public static String getObjectType(Object o) {
        if (o instanceof Cat)
            return "Кот";
        else if (o instanceof Tiger)
            return "Тигр";
        else if (o instanceof Lion)
            return "Лев";
        else if (o instanceof Bull)
            return "Бык";
        else
        return "хз";
    }

    public static class Cat
    {
    }

    public static class Tiger
    {
    }

    public static class Lion
    {
    }

    public static class Bull
    {
    }

    public static class Pig
    {
    }
}



package com.javarush.test.level12.lesson12.home05;

/* Что это? «Кот», «Тигр», «Лев», «Бык», «Корова», «Животное»
Напиши метод, который определяет, какой объект передали в него.
Программа должна выводить на экран одну из надписей:
«Кот», «Тигр», «Лев», «Бык», «Корова», «Животное».
Замечание: постарайся определять тип животного как можно более точно.
*/

public class Solution
{
    public static void main(String[] args)
    {
        System.out.println(getObjectType(new Cat()));
        System.out.println(getObjectType(new Tiger()));
        System.out.println(getObjectType(new Lion()));
        System.out.println(getObjectType(new Bull()));
        System.out.println(getObjectType(new Cow()));
        System.out.println(getObjectType(new Animal()));
    }

    public static String getObjectType(Object o)
    {
        if (o instanceof Cat)
            return "Кот";
        else if (o instanceof Tiger)
            return "Тигр";
        else if (o instanceof Lion)
            return "Лев";
        else if (o instanceof Bull)
            return "Бык";
        else if (o instanceof Cow)
            return "Корова";
        else if (o instanceof Animal)
            return "Животное";

        return "Животное";
    }

    public static class Cat  extends Animal   //<--Классы наследуются!!
    {
    }

    public static class Tiger
    {
    }

    public static class Lion
    {
    }

    public static class Bull  extends Animal
    {
    }

    public static class Cow  extends Animal
    {
    }

    public static class Animal
    {
    }
}



package com.javarush.test.level12.lesson12.home06;

/* Fly, Run, Climb для классов Cat, Dog, Tiger, Duck
1. Внутри класса Solution создай интерфейс public interface Fly(летать) с методом void fly().
2. Внутри класса Solution создай интерфейс public interface Climb(лазить по деревьям) с методом void climb().
3. Внутри класса Solution создай интерфейс public interface Run(бегать) с методом void run().
4. Подумай логически, какие именно интерфейсы нужно добавить для каждого класса.
5. Добавь интерфейсы классам Cat(кот), Dog(собака), Tiger(тигр), Duck(Утка).
*/

public class Solution {

    public interface Fly{
        void fly();
    }
    public interface Climb{
        void climb();
    }
    public interface Run{
        void run();
    }



    public class Cat implements Run, Climb
    {

        @Override
        public void climb() {

        }

        @Override
        public void run() {

        }
    }

    public class Dog implements Run
    {

        public void run(){

        }
    }

    public class Tiger extends Cat implements Run, Climb
    {

    }

    public class Duck implements Run, Fly
    {
        @Override
        public void fly() {

        }

        @Override
        public void run() {

        }
    }
}


package com.javarush.test.level12.lesson12.home07;

/* Fly, Run, Swim для классов Duck, Penguin, Toad
Есть интерфейсы Fly(летать), Swim(плавать), Run(бегать).
Добавь эти интерфейсы классам Duck(утка), Penguin(пингвин), Toad(жаба)
*/

public class Solution
{
    public static void main(String[] args)
    {

    }

    public interface Fly
    {
        public void fly();
    }

    public interface Run
    {
        public void run();
    }

    public interface Swim
    {
        public void swim();
    }

    public class Duck implements Fly, Run, Swim
    {

        @Override
        public void fly() {

        }

        @Override
        public void run() {

        }

        @Override
        public void swim() {

        }
    }

    public class Penguin implements Run, Swim
    {

        @Override
        public void run() {

        }

        @Override
        public void swim() {

        }
    }

    public class Toad implements Swim
    {
        @Override
        public void swim() {

        }
    }
}


package com.javarush.test.level12.lesson12.home08;

/* Интерфейсы к классу Human
Добавь как можно больше интерфейсов к классу Human, но чтобы он не стал абстрактным классом.
Добавлять методы в класс Human запрещается.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Human human = new Human();
        System.out.println(human);
    }

    public static interface Worker
    {
        public void workLazy();
    }

    public static interface Businessman
    {
        public void workHard();
    }

    public static interface Secretary
    {
        public void workLazy();
    }

    public static interface Miner
    {
        public void workVeryHard();
    }

    public static class Human implements Worker, Businessman, Secretary
    {

        public void workHard()
        {
        }

        public void workLazy()
        {
        }
    }
}



package com.javarush.test.level12.lesson12.home09;

/* Родитель класса CTO
Добавь такой класс-родитель к классу CTO(технический директор), чтобы класс перестал быть абстрактным.
Добавлять/реализовывать методы в классе CTO запрещается.
*/

public class Solution
{

    public static void main(String[] args)
    {
        CTO cto = new CTO();
        System.out.println(cto);
    }

    public static interface Businessman
    {
        public void workHard();
    }

    public static class Worker implements Businessman
    {
        @Override
        public void workHard() {

        }
    }

    //Если нельзя реализовать метод в классе СТО, а в интерфейсе компилятор не позволяет - вывод напрашивается один - еще один класс.
    // Создай свой любой статический класс имплиментирующий интерфейс, реализуй в нем метод интерфейса и наследуй от него свой СТО.

    public static class CTO extends Worker {

    }


}





http://java-course.ru/begin/override-overload/



package edu.javacourse.robot;
 
public class Robot
{
    private double x = 0;
    private double y = 0;
    protected double course = 0;
 
    public Robot(double x, double y) {
        this.x = x;
        this.y = y;
    }
 
    // Передвижение на дистанцию distance
    public void forward(int distance) {
        x = x + distance * Math.cos(course / 180 * Math.PI);
        y = y + distance * Math.sin(course / 180 * Math.PI);
    }
 
    // Печать координат робота
    public void printCoordinates() {
        System.out.println(x + "," + y);
    }
 
    public double getX() {
        return x;
    }
 
    public double getY() {
        return y;
    }
 
    public double getCourse() {
        return course;
    }
 
    public void setCourse(double course) {
        this.course = course;
    }
}
Наш робот умеет перемещаться, но у него нет умения, которое может потребоваться — он не считает пройденное расстояние. 
Данный класс принципиально не умеет этого делать. Для создания робота, который все-таки умеет считать расстояние, 
можно пойти по следующему пути: унаследоваться от класса Robot, дополнить новый класс переменной, например totalDistance
 и при перемещении увеличивать ее на пройденную дистанцию. Т.е. нам надо переопределить метод forward, в котором надо рассчитать 
 новые координаты и прибавить к переменной totalDistance величину входного параметра distance. Как видим все достаточно логично, 
 за исключением одного неприятного момента — у нас УЖЕ есть алгоритм, который считает новые координаты и не использовать его было бы странно. 
 Нужен механизм, который позволит вызывать методы предка. И этот механизм существует. Смотрим код нового класса RobotTotal.


package edu.javacourse.robot;

public class RobotTotal extends Robot
{
    // Вводим поле дляхранения пройденной дистанции
    private double totalDistance = 0;

    // Конструктор тоже надо переопределить
    public RobotTotal(double x, double y) {
        super(x, y);
    }

    @Override
    public void forward(int distance) {
        // Вызов нашего метода у класса предка.
        // Нужно указать зарезервированное слово super
        super.forward(distance);
        totalDistance += distance;
    }

    public double getTotalDistance() {
        return totalDistance;
    }

	
	
	
package edu.javacourse.robot;
 
public class RobotTotal extends Robot
{
    // Вводим поле дляхранения пройденной дистанции
    private double totalDistance = 0;
 
    // Конструктор тоже надо переопределить
    public RobotTotal(double x, double y) {
        super(x, y);
    }
 
    @Override
    public void forward(int distance) {
        // Вызов нашего метода у класса предка.
        // Нужно указать зарезервированное слово super
        super.forward(distance);
        totalDistance += distance;
    }
 
    public double getTotalDistance() {
        return totalDistance;
    }
}




http://ru.vingrad.com/






package com.javarush.test.level12.lesson12.home10;

/* Метод, который выводит на экран число 10
Добавь еще один метод, чтобы программа выводила на экран число 10.
Подсказка: используй перегрузку методов.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Integer i = 5;
        int x = transformValue(i);

        System.out.println(x);
    }



    public static int transformValue(int i)
    {
        return i*i;
    }
    public static int transformValue(Integer i)
    {

        return i*2;
    }
}



package com.javarush.test.level13.lesson02.task01;

/* Пиво
1. Подумай, какой из двух интерфейсов нужно реализовать в классе Beer.
2. Добавь к классу Beer этот интерфейс и реализуйте все нереализованные методы.
3. Подумай, как связаны переменная  READY_TO_GO_HOME и метод isReadyToGoHome.
4. Верни значение переменной READY_TO_GO_HOME в методе isReadyToGoHome.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    public interface Drink
    {
        void askMore(String message);

        void sayThankYou();

        boolean isReadyToGoHome();
    }

    public interface Alcohol extends Drink
    {
        boolean READY_TO_GO_HOME = false;

        void sleepOnTheFloor();
    }

    public static class Beer implements Alcohol
    {


        @Override
        public void sleepOnTheFloor() {

        }

        @Override
        public void askMore(String message) {

        }

        @Override
        public void sayThankYou() {

        }

        @Override
        public boolean isReadyToGoHome() {
            return false;
        }
    }

}


package com.javarush.test.level13.lesson02.task02;

/* Пиво: возвращение
Добавь к классу AlcoholicBeer интерфейс Drink и реализуй все нереализованные методы.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        Drink beer = new AlcoholicBeer();
        System.out.println(beer.toString());
    }

    public interface Drink
    {
        boolean isAlcoholic();
    }

    public static class AlcoholicBeer implements Drink
    {
        @Override
        public String toString()
        {
            if (isAlcoholic()) {
                return "Напиток алкогольный";
            }
            else {
                return "Напиток безалкогольный";
            }

        }

        @Override
        public boolean isAlcoholic() {
            return true;
        }
    }
}


package com.javarush.test.level13.lesson02.task03;

/* Пиво и кола
Реализуй интерфейс Drink в классах Beer и Cola.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {

        print(new Beer());
        print(new Cola());

    }

    private static void print(Drink drink)
    {
        System.out.println(drink.getClass().getSimpleName());
    }

    public interface Drink
    {
        boolean isAlcoholic();
    }

    public static class Beer implements Drink {
        @Override
        public boolean isAlcoholic() {
            return true;
        }
    }

    public static class Cola implements Drink
    {
        @Override
        public boolean isAlcoholic() {
            return false;
        }
    }
}



package com.javarush.test.level13.lesson02.task04;

/* Selectable и Updatable
1. Создай класс Screen.
2. Реализуй в нем интерфейсы Selectable с методом onSelect, Updatable с методом refresh.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    interface Selectable
    {
        void onSelect();
    }

    interface Updatable
    {
        void refresh();
    }

    public static class Screen implements Selectable, Updatable
    {

        @Override
        public void onSelect() {
            
        }

        @Override
        public void refresh() {

        }
    }
}


package com.javarush.test.level13.lesson02.task05;

/* 4 ошибки
Исправь 4 ошибки в программе, чтобы она компилировалась.
Объявление интерфейсов не изменять.
*/

public class Solution
{

    public static void main(String[] args) throws Exception
    {

        System.out.println(Dream.HOBBIE.toString());
        System.out.println(new Hobbie().toString());

    }

        interface Desire
        {
        }

        interface Dream
        {
            public Hobbie HOBBIE = new Hobbie();
        }

        static class Hobbie implements Desire, Dream
        {
            static int INDEX = 1;

            @Override
            public String toString()
            {
                INDEX++;
                return "" + INDEX;
            }
        }

}



package com.javarush.test.level13.lesson02.task05;

/* 4 ошибки
Исправь 4 ошибки в программе, чтобы она компилировалась.
Объявление интерфейсов не изменять.
*/

public class Solution
{

    public static void main(String[] args) throws Exception
    {

        System.out.println(Dream.HOBBIE.toString());
        System.out.println(new Hobbie().toString());

    }

        interface Desire
        {
        }

        interface Dream
        {
            public Hobbie HOBBIE = new Hobbie();
        }

        static class Hobbie implements Desire, Dream
        {
            static int INDEX = 1;

            @Override
            public String toString()
            {
                INDEX++;
                return "" + INDEX;
            }
        }

}




package com.javarush.test.level13.lesson02.task06;

/* Баг в initializeIdAndName
1. Подумать, что в программе неправильно.
2. Вынести реализацию метода initializeIdAndName в класс User.
3. initializeIdAndName в классе User должен возвращать тип User.
4. Поправить программу, чтобы компилировалась и работала.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        System.out.println(Matrix.NEO);
        System.out.println(Matrix.TRINITY);
    }

    static class Matrix
    {
        public static DBObject NEO = new User().initializeIdAndName(1, "Neo");
        public static DBObject TRINITY = new User().initializeIdAndName(2, "Trinity");
    }

    public interface DBObject
    {
        DBObject initializeIdAndName(long id, String name);
    }

    static class User extends Matrix implements DBObject {
        long id;
        String name;

        @Override
        public String toString()
        {
            return String.format("User has name %s, id = %d", name, id);
        }

        @Override
        public DBObject initializeIdAndName(long id, String name) {
            this.id = id;
            this.name = name;
            return this;
        }
    }

}




ДЖЕНЕРИКИ______________________________________________________________________________________ДЖЕНЕРИКИ________________________
Обобщённое программирование — это такой подход к описанию данных и алгоритмов, 
который позволяет их использовать с различными типами данных без изменения их описания. 
В Java, начиная с версии J2SE 5.0, добавлены средства обобщённого программирования, 
синтаксически основанные на C++. Ниже будут рассматриваться generics (дженерики) или <<контейнеры типа T>> — подмножество 
обобщённого программирования.

Допустим мы ничего не знаем о дженериках и нам необходимо реализовать специфический вывод на 
консоль информации об объектах различного типа (с использованием фигурных скобок).

Ниже пример реализации:

package test; 
 
class BoxPrinter { 
    private Object val; 
 
    public BoxPrinter(Object arg) { 
        val = arg; 
    } 
 
    public String toString() { 
        return "{" + val + "}"; 
    } 
 
    public Object getValue() { 
        return val; 
    } 
} 
 
class Test { 
    public static void main(String[] args) { 
        BoxPrinter value1 = new BoxPrinter(new Integer(10)); 
        System.out.println(value1); 
        Integer intValue1 = (Integer) value1.getValue(); 
        BoxPrinter value2 = new BoxPrinter("Hello world"); 
        System.out.println(value2); 
 
        // Здесь программист допустил ошибку, присваивая 
        // переменной типа Integer значение типа String. 
        Integer intValue2 = (Integer) value2.getValue(); 
    } 
} 
В вышеприведённом коде была допущена ошибка, из-за которой на консоли мы увидим следующее:

{10} 
{Hello world} 
Exception in thread "main" java.lang.ClassCastException: java.lang.String incompatible with java.lang.Integer 
    at test.Test.main(Test.java:29) 
Теперь на время забудем об этом примере и попробуем реализовать тот же функционал с использованием дженериков (и повторим ту же ошибку):

package test; 
 
class BoxPrinter<T> { 
    private T val; 
 
    public BoxPrinter(T arg) { 
        val = arg; 
    } 
 
    public String toString() { 
        return "{" + val + "}"; 
    } 
 
    public T getValue() { 
        return val; 
    } 
} 
 
class Test { 
    public static void main(String[] args) { 
        BoxPrinter<Integer> value1 = new BoxPrinter<Integer>(new Integer(10)); 
        System.out.println(value1); 
        Integer intValue1 = value1.getValue(); 
        BoxPrinter<String> value2 = new BoxPrinter<String>("Hello world"); 
        System.out.println(value2); 
         
        // Здесь повторяется ошибка предыдущего фрагмента кода 
        Integer intValue2 = value2.getValue(); 
    } 
} 

Самое существенное отличие (для меня) в том, что при ошибке, аналогичной предыдущей, проблемный код не скомпилируется:

Exception in thread "main" java.lang.Error: Unresolved compilation problem:  
    Type mismatch: cannot convert from String to Integer 
 
    at test.Test.main(Test.java:28) 
Думаю, многие согласятся, что ошибка компиляции «лучше» ошибки времени выполнения, т.к. чисто теоретически скомпилированный 
код с ошибкой может попасть туда, куда ему лучше бы и не попадать. Это очевидное достоинство дженериков. 
Теперь подробнее рассмотрим конструкции, относящиеся к дженерикам в этом примере. Для того, чтобы код скомпилировался, достаточно заменить строку

Integer intValue2 = value2.getValue(); 
на
String stringValue = value2.getValue(); 
Посмотрим на декларацию BoxPrinter:

class BoxPrinter<T> 
После имени класса в угловых скобках "<" и ">" указано имя типа "Т", которое может использоваться внутри класса. 
Фактически Т – это тип, который должен быть определён позже (при создании объекта класса).

Внутри класса первое использование T в объявлении поля:

private T val; 
Здесь объявляется переменная дженерик-типа (generic type), т.о. её тип будет указан позже, при создании объекта класса BoxPrinter.

В main()-методе происходит следующее объявление:

BoxPrinter <Integer>  value1 
Здесь указывается, что Т имеет тип Integer. Грубо говоря, для объекта value1 все поля Т-типа его класса 
BoxPrinter становятся полями типа Integer (private Integer val;).
Ещё одно место, где используется T:

public BoxPrinter(T arg) { 
        val = arg; 
    } 
Как и в декларации val с типом Т, вы говорите, что аргумент для конструктора BoxPrinter имеет тип T. 
Позже в main()-методе, когда будет вызван конструктор в new, указывается, что Т имеет тип Integer:

new BoxPrinter<Integer>(new Integer(10)); 
Теперь, внутри конструктора BoxPrinter, arg и val должны быть одного типа, так как оба имеют тип T. 
Например следующее изменение конструктора:

new BoxPrinter<String>(new Integer(10)); 
приведёт к ошибке компиляции.

Последнее место использования Т в классе – метод getValue():

public T getValue() { 
        return val; 
    } 
Тут вроде тоже всё ясно – этот метод для соответствующего объекта будет возвращать значение того типа, 
который будет задан при его (объекта) создании.

При создании дженерик-классов мы не ограничены одним лишь типом (Т) – их может быть несколько:

package test; 
 
class Pair<T1, T2> { 
    T1 object1; 
    T2 object2; 
 
    Pair(T1 one, T2 two) { 
        object1 = one; 
        object2 = two; 
    } 
 
    public T1 getFirst() { 
        return object1; 
    } 
 
    public T2 getSecond() { 
        return object2; 
    } 
} 
 
class Test { 
    public static void main(String[] args) { 
        Pair<Integer, String> pair = new Pair<Integer, String>(6, 
                " Apr"); 
        System.out.println(pair.getFirst() + pair.getSecond()); 
    } 
} 
Нет ограничений и на количество переменных с использующих такой тип:

class PairOfT<T> { 
    T object1; 
    T object2; 
 
    PairOfT(T one, T two) { 
        object1 = one; 
        object2 = two; 
    } 
 
    public T getFirst() { 
        return object1; 
    } 
 
    public T getSecond() { 
        return object2; 
    } 


http://www.quizful.net/post/java-generics-tutorial           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!







package com.javarush.test.level13.lesson02.task07;

/* Параметризованый интерфейс
В классе StringObject реализуй интерфейс SimpleObject с параметром типа String.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    interface SimpleObject<T>
    {
        SimpleObject<T> getInstance();
    }

    class StringObject implements SimpleObject<String>
    {

        @Override
        public SimpleObject<String> getInstance() {

            return null;
        }
    }
}



package com.javarush.test.level13.lesson02.task08;

/* Жив или нет
1. Создай интерфейс Person.
2. Добавь в него метод isAlive(), который проверяет, жив человек или нет.
3. Подумай, какой тип должен возвращать этот метод.
4. Создай интерфейс Presidentable.
5. Унаследуй интерфейс Presidentable от интерфейса Person.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {

    }
    public interface Person{
        boolean isAlive(boolean s);
    }

    public interface Presidentable extends Person{

    }

}



package com.javarush.test.level13.lesson02.task09;

/* Наследование интерфейса
1. Создать интерфейс Movable с методом speed.
2. Метод speed возвращает значение типа Double и не принимает параметров.
3. Создать и унаследовать интерфейс Runable от интерфейса Movable.
4. Добавить в интерфейс Runable метод speed.
5. Метод speed возвращает значение типа Double и принимает один параметр типа Runable.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {

    }

    public interface Movable{
        Double speed();
    }

    public interface Runable extends Movable{

        Double speed (Runable a);
    }



}



package com.javarush.test.level13.lesson02.task10;

/* CleverMan и SmartGirl
1. Добавь интерфейсы Secretary и Boss к классам CleverMan и SmartGirl. По одному на каждый. Подумай, кому какой.
2. Унаследуй  интерфейсы Secretary и Boss от интерфейсов Person и Workable так,
чтобы все методы у классов CleverMan и SmartGirl оказались объявленными в каком-то интерфейсе.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    interface Person
    {
        void use(Person person);
        void startToWork();
    }

    interface Workable
    {
        boolean wantGetExtraWork();
    }

    interface Secretary extends Person
    {
    }

    interface Boss extends Workable, Person
    {
    }

    class CleverMan implements Boss
    {
        public void use(Person person)
        {
            person.startToWork();
        }

        public void startToWork()
        {
        }

        public boolean wantGetExtraWork()
        {
            return true;
        }
    }

    class SmartGirl implements Secretary
    {
        public void use(Person person)
        {
        }

        public void startToWork()
        {
        }
    }
}




package com.javarush.test.level13.lesson04.task01;

/* Переводчик с английского
1. Создать класс EnglishTranslator, который наследуется от Translator.
2. Реализовать все абстрактные методы.
3. Подумай, что должен возвращать метод getLanguage.
4. Программа должна выводить на экран "Я переводчик с английского".
5. Метод main менять нельзя.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        EnglishTranslator englishTranslator = new EnglishTranslator();
        System.out.println(englishTranslator.translate());
    }

    public static abstract class Translator
    {
        public abstract String getLanguage();

        public String translate()
        {
            return "Я переводчик с " + getLanguage();
        }
    }

    public static class EnglishTranslator extends Translator{

        @Override
        public String getLanguage() {
            return "английского";
        }
    }

}




package com.javarush.test.level13.lesson04.task02;

/* Исправление кода
Исправить код так, чтобы программа выполнялась и выводила "Я переводчик с английского".
Метод main менять нельзя!
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        Translator translator = new Translator();
        System.out.println(translator.translate());
    }

    public static class Translator
    {
        public String translate()
        {
            return "Я переводчик с английского";
        }
    }


}





package com.javarush.test.level13.lesson04.task03;

import java.awt.*;

/* Интерфейс Animal
1. Унаследовать Fox от интерфейса Animal.
2. Поменяй код так, чтобы в классе Fox был только один метод - getName.
3. Создавать дополнительные классы и удалять методы нельзя!
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    public interface Animal
    {
        Color getColor();
    }

    public static abstract class Fox implements Animal {
        public String getName()
        {
            return "Fox";
        }
    }
}




______________________________________________________________________________________________________СМОТРЕТЬ.ИМПОРТ ЦВЕТОВ!!!
package com.javarush.test.level13.lesson04.task04;

import java.awt.*;

/* Класс BigFox
1. Исправь класс BigFox так, чтобы программа компилировалась.
2. Метод main менять нельзя.
*/

public class Solution
{

    public static void main(String[] args) throws Exception
    {

        Fox bigFox = new BigFox();
        System.out.println(bigFox.getName());
        System.out.println(bigFox.getColor());

    }

    public interface Animal
    {
        Color getColor();
    }

    public static abstract class Fox implements Animal
    {
        public String getName() {
            return "Fox";
        }
    }

    //add your code below
    public static class BigFox extends Fox
    {
        public Color getColor() {
            return Color.GRAY;
        }
    }

}






package com.javarush.test.level13.lesson06.task01;

/* Dog, Cat и Mouse
1. Создать классы Dog, Cat и Mouse.
2. Реализовать интерфейсы в добавленных классах, учитывая что:
- Кот(Cat) может передвигаться, может кого-то съесть и может быть сам съеден.
- Мышь(Mouse) может передвигаться и может быть съедена.
- Собака(Dog) может передвигаться и съесть кого-то.
*/

public class Solution
{

    public interface Moveable //может двигаться
    {
        void move();
    }

    public interface Eatable  //может быть съеден
    {
        void eaten();
    }

    public interface Eat  //может кого-нибудь съесть
    {
        void eat();
    }

    public abstract class Dog implements Moveable, Eat
    {

    }

    public abstract class Cat implements Moveable, Eatable, Eat
    {

    }

    public abstract class Mouse implements Moveable, Eatable
    {

    }


}




package com.javarush.test.level13.lesson11.home01;

/* Некорректные строки
Удали все некорректные строки в интерфейсе Button.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        System.out.println(SimpleObject.NAME);
        System.out.println(Button.NAME);
    }

    interface SimpleObject
    {
        String NAME = "SimpleObject";
        void onPress();
    }

    interface Button extends SimpleObject
    {

        final String NAME = "Submit";

        void onPress();


    }
}





public static void main(String[] args) throws IOException
{
 InputStream inStream = new FileInputStream("c:/source.txt");
 OutputStream outStream = new FileOutputStream("c:/result.txt");

 while (inStream.available() > 0)
 {
  int data = inStream.read(); //читаем один байт из потока для чтения
  outStream.write(data); //записываем прочитанный байт в другой поток.
 }

 inStream.close(); //закрываем потоки
 outStream.close();
}






Представь, что мы написали класс, и добавили ему способности InputStream и OutputStream.

Если мы корректно реализовали поддержку этих интерфейсов, то объекты нашего класса теперь можно сохранить в файл на диске.
 Просто вычитав их содержимое через метод read. Или загрузить из файла, создав объект и записав в него содержимое файла через метод write.

- А можно пример?

- Можно.

Код	Описание
class MyClass
{
 private ArrayList<Integer> list;
}	Для простоты представим, что наш класс содержит в себе один объект – ArrayList типа Integer.
Теперь добавим в него методы read и write

Код	Описание
class MyClass
{
 private ArrayList<Integer> list;

 public void write(int data)
 {
  list.add(data);
 }
 public int read()
 {
  int first = list.get(0);
  list.remove(0);
  return first;
 }

 public int available()
 {
  return list.size();
 }
}	Теперь у нас в классе реализован метод read, который позволяет последовательно вычитать все содержимое нашего списка list.

И метод write, который позволяет записывать в наш list значения.
Это, конечно, не реализация интерфейсов InputStream и OutputStream, но очень похоже.

- Да, это понятно. А как все-таки сохранить содержимое такого объекта в файл?

- Давай я напишу тебе пример:

Запись объекта MyClass в файл
public static void main(String[] args)
{
 MyClass myObject = new MyClass();
 OutputStream outStream = new FileOutputStream ("c:/my-object-data.txt");

 while (myObject.available() > 0)
 {
  int data = myObject.read(); //читаем один int из потока для чтения
  outStream.write(data); //записываем прочитанный int в другой поток.
 }

 outStream.close();
}
Чтение объекта MyClass из файла
public static void main(String[] args)
{
 InputStream inStream = new FileInputStream("c:/my-object-data.txt");
 MyClass myObject = new MyClass();

 while (inStream.available() > 0)
 {
  int data = inStream.read(); //читаем один int из потока для чтения
  myObject.write(data); //записываем прочитанный int в другой поток.
 }

 inStream.close(); //закрываем потоки
}




____________________________________________________________________________________________________________
package com.javarush.test.level13.lesson11.home02;

/* Погода
1. В классе Today реализовать интерфейс Weather.
2. Подумай, как связан параметр String type с методом getWeatherType().
3. Интерфейсы Weather и WeatherType уже реализованы.
*/

public class Solution
{
    public static void main(String[] args)
    {
        System.out.println(new Today(WeatherType.CLOUDY));
        System.out.println(new Today(WeatherType.FOGGY));
        System.out.println(new Today(WeatherType.FROZEN));
    }

    static class Today implements Weather
    {
        private String type;

        Today(String type)
        {
            this.type = type;
        }

        @Override
        public String toString()
        {
            return String.format("%s for today", this.getWeatherType());
        }

        @Override
        public String getWeatherType() {
            return type;
        }
    }
}

public interface WeatherType
{
    String CLOUDY = "Cloudy";
    String FOGGY = "Foggy";
    String FROZEN = "Frozen";
}

public interface Weather
{
    String getWeatherType();
}
________________________________________________________________________________________________________________________





package com.javarush.test.level13.lesson11.home03;

/* Чтение файла
1. Считать с консоли имя файла.
2. Вывести в консоль(на экран) содержимое файла.
3. Не забыть освободить ресурсы. Закрыть поток чтения с файла и поток ввода с клавиатуры. (ПУНКТ НЕ ВЫПОЛНЯЕТСЯ В ДАННОМ РЕШЕНИИ)_________
*/

import java.io.*;
import java.util.logging.FileHandler;

public class Solution
{

    public static void main(String[] args) throws IOException{

                BufferedReader yesorno = new BufferedReader(new InputStreamReader(System.in));
                File f = new File("F:/fgg.txt");
                BufferedReader reader = new BufferedReader(new FileReader(f));
                String name;
                String line;
                System.out.println("Print File "+f.getName()+"? y/n");
                name = yesorno.readLine();
                if(name.equals("y"))
                    while ((line = reader.readLine()) != null) System.out.println(line);
            }

}



__________________________________________________________________________________ПОТИМАЛЬНЫЙ ВАРИАНТ ЧТЕНИЯ УКАЗЫВАЕМОГО ФАЙЛА НА ДАННЫЙ МОМЕНТ
package com.javarush.test.level13.lesson11.home03;

/* Чтение файла
1. Считать с консоли имя файла.
2. Вывести в консоль(на экран) содержимое файла.
3. Не забыть освободить ресурсы. Закрыть поток чтения с файла и поток ввода с клавиатуры.
*/

import java.io.*;

public class Solution {

    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String fn = reader.readLine();
        //--------------------------------------
        InputStream text = new FileInputStream(fn);     //  читаем файл
        while (text.available() > 0)                    //  читаем пока не закончатся символы
        {
            System.out.print((char) text.read());       // выводим прочитанный символ
        }
        //--------------------------------
        reader.close();                                 // закрываем поток чтения с клавиатуры
        text.close();                                   // закрываем поток чтения из файла
    }
}

Зачем столько мудрить?

В блоке try:

Считываем имя файла (если нет, то catch)

Пока не будет введено "exit" + "\n" :

считываем строку + "\n"
переводим её в массив символов (sring.toCharArray())
в цикле посимвольно записываем в файл (перевод строки "\n" тоже запишется)
закрываем поток
всё





!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Escape Sequences
Escape Sequence Description
\t  Insert a tab in the text at this point.
\b  Insert a backspace in the text at this point.
\n  Insert a newline in the text at this point.
\r  Insert a carriage return in the text at this point.
\f  Insert a formfeed in the text at this point.
\'  Insert a single quote character in the text at this point.
\"  Insert a double quote character in the text at this point.
\\  Insert a backslash character in the text at this point.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!







____________________________________________________________________________________ВВЕСТИ ИНФОРМАЦИЮ(СТРОКИ) В ФАЙЛ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
package com.javarush.test.level13.lesson11.home04;

/* Запись в файл
1. Прочесть с консоли имя файла.
2. Считывать строки с консоли, пока пользователь не введет строку "exit".
3. Вывести абсолютно все введенные строки в файл, каждую строчку с новой стороки.
*/

import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        String fileName = scanner.nextLine();
        ArrayList<String> strings = new ArrayList<String>();
        while (true)
        {
            String string = scanner.nextLine();
            if(!string.equals("exit"))
                strings.add(string);
            else
                break;
        }
        FileWriter fileWriter = new FileWriter(fileName);
        for (int a = 0; a < strings.size(); a++)
        {
            byte[] byteArray = strings.get(a).getBytes();
            String lineSeparator = System.lineSeparator();
            fileWriter.write(strings.get(a));
            fileWriter.write(lineSeparator);
            fileWriter.flush();
        }
        fileWriter.write("exit");
        fileWriter.close();
    }
}






package com.javarush.test.level13.lesson11.home04;

/* Запись в файл
1. Прочесть с консоли имя файла.
2. Считывать строки с консоли, пока пользователь не введет строку "exit".
3. Вывести абсолютно все введенные строки в файл, каждую строчку с новой стороки.
*/

import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        String fileName = scanner.nextLine();
        ArrayList<String> strings = new ArrayList<String>();
        while (true)
        {
            String string = scanner.nextLine();
            if(!string.equals("exit"))
                strings.add(string);
            else
                break;
        }
        FileWriter fileWriter = new FileWriter(fileName);
        for (int a = 0; a < strings.size(); a++)
        {
            byte[] byteArray = strings.get(a).getBytes();
            String lineSeparator = System.lineSeparator();
            fileWriter.write(strings.get(a));
            fileWriter.write(lineSeparator);
            fileWriter.flush();
        }
        fileWriter.write("exit");
        fileWriter.close();
    }
}



package com.javarush.test.level13.lesson11.home06;

/* Исправление ошибок
1. Переделай наследование в классах и интерфейсах так, чтобы программа компилировалась и продолжала делать то же самое.
2. Класс Hobbie должен наследоваться от интерфейсов Desire, Dream.
*/

public class Solution
{

    public static void main(String[] args) throws Exception
    {
        System.out.println(Hobbie.HOBBIE.toString());
        System.out.println(new Hobbie().INDEX);
    }

    interface Desire
    {
    }

    interface Dream
    {

    }

    static class Hobbie implements Desire, Dream
    {
        static Hobbie HOBBIE = new Hobbie();

        static int INDEX = 1;

        @Override
        public String toString()
        {
            INDEX++;
            return "" + INDEX;
        }
    }

}


______________________________________________________________________________________________РЕФАКТОРИНГ
package com.javarush.test.level13.lesson11.home07;

/* Интерфейс SimpleObject
1. Создай класс StringObject.
2. В классе StringObject реализуй интерфейс SimpleObject с параметром типа String.
3. Программа должна компилироваться.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
       SimpleObject<String> stringObject = new StringObject<Object>();
    }

    interface SimpleObject<T>
    {
        SimpleObject<T> getInstance();
    }

    public static class StringObject<Object> implements SimpleObject<String>
    {

        @Override
        public SimpleObject<String> getInstance() {
            return this;
        }
    }

}



package com.javarush.test.level13.lesson11.home08;

/* Интерфейс Updatable в классе Screen
Реализовать интерфейс Updatable в классе Screen.
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    interface Selectable
    {
        void onSelect();
    }

    interface Updatable extends Selectable
    {
        void refresh();
    }

    class Screen implements Updatable
    {

        @Override
        public void refresh() {
            
        }

        @Override
        public void onSelect() {

        }
    }
}



АБСТРАКЦИЯ КЛАССА
package com.javarush.test.level13.lesson11.home09;

import java.awt.*;

/* Один метод в классе
1. Унаследовать Fox от интерфейса Animal.
2. Поменяй код так, чтобы в классе Fox был только один метод - getName.
3. Методы удалять нельзя!
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
    }

    public interface Animal
    {
        Color getColor();

        Integer getAge();
    }

    abstract class Fox implements Animal
    {
        public String getName()
        {
            return "Fox";
        }
    }
}



package com.javarush.test.level13.lesson11.home10;

import java.awt.*;

/* Компиляция программы
1. Исправь классы Fox и BigFox так, чтобы программа компилировалась. Задача не предполагает создания экземпляров базового класса.
2. Метод main менять нельзя.
*/

public class Solution
{

    public static void main(String[] args) throws Exception
    {
       Fox bigFox = new BigFox();
       System.out.println(bigFox.getName());
       System.out.println(bigFox.getColor());
    }

    public interface Animal
    {
        Color getColor();
    }

      public abstract static class Fox implements Animal
      {
          public String getName() {
              return "Fox";
          }

      }

    public static class BigFox extends Fox
    {
        
        @Override
        public Color getColor() {
            return new Color(1,1,1);
        }

    }

}




_____________________________________________________________Class Colour
package com.javarush.test.level13.lesson04.task04;

import java.awt.*;

/* Класс BigFox
1. Исправь класс BigFox так, чтобы программа компилировалась.
2. Метод main менять нельзя.
*/

public class Solution
{

    public static void main(String[] args) throws Exception
    {

        Fox bigFox = new BigFox();
        System.out.println(bigFox.getName());
        System.out.println(bigFox.getColor());

    }

    public interface Animal
    {
        Color getColor();
    }

    public static abstract class Fox implements Animal
    {
        public String getName() {
            return "Fox";
        }
    }

    //add your code below
    public static class BigFox extends Fox
    {
        public Color getColor() {
            return Color.GRAY;
        }
    }

}



package com.javarush.test.level12.lesson12.bonus01;

/* Нужно исправить программу, чтобы компилировалась и работала
Расставить правильно ключевые слова abstract, чтобы программа компилировалась (там где надо и не надо).
*/

public class Solution
{

    public static void main(String[] args)
    {
        Horse horse = new Pegas();
        horse.run();
    }

    public static interface Fly
    {
        public abstract void fly();
    }

    public static abstract class Horse
    {
        public void run()
        {

        }
    }

    public static class Pegas extends Horse implements Fly
    {
        public void fly()
        {

        }
    }

    public static class SwimPegas extends Pegas
    {
        public void swim() {

        }
    }

}




БОЛЬШАЯ
package com.javarush.test.level13.lesson11.bonus02;

import java.util.ArrayList;
import java.util.List;

/* Репка
Сказка Репка:
1. Реализовать интерфейс RepkaItem в классе Person.
2. В классе Person реализовать метод pull(Person person), который выводит фразу типа '<name> за <person>'. Пример:
Бабка за Дедку
Дедка за Репку
3. Исправить логическую ошибку цикла в методе tell класса RepkaStory.
4. Выполнить метод main и наслаждаться сказкой!
*/

public class Solution
{
    public static void main(String[] args)
    {
        List<Person> plot = new ArrayList<Person>();
        plot.add(new Person("Репка", "Репку"));
        plot.add(new Person("Дедка", "Дедку"));
        plot.add(new Person("Бабка", "Бабку"));
        plot.add(new Person("Внучка", "Внучку"));
        RepkaStory.tell(plot);
    }
}
---------------------------------------------------------------------------------------
package com.javarush.test.level13.lesson11.bonus02;

import java.util.List;

public class RepkaStory
{
    static void tell(List<Person> items) {

        Person first;
        Person second;
        for (int i = items.size() - 1; i > 0; i--) {
                first = items.get(i-1);
                second = items.get(i);
                second.pull(first);
        }
    }
}
------------------------------------------------------------------------
package com.javarush.test.level13.lesson11.bonus02;

public class Person implements RepkaItem
{
    private String name;
    private String namePadezh;

    public Person(String name, String namePadezh)
    {
        this.name = name;
        this.namePadezh = namePadezh;
    }

    @Override
    public String getNamePadezh() {
        return namePadezh;
    }

    public void pull(Person person) {
        System.out.println(name + " за " + person.getNamePadezh());

    }
}
-----------------------------------------------------------------
package com.javarush.test.level13.lesson11.bonus02;

public interface RepkaItem
{
    public String getNamePadezh();
}
----------------------------------------------------------------------------------------------------------------






package com.javarush.test.level12.lesson12.bonus02;

/* Нужно добавить в программу новую функциональность
Сделать класс Pegas(пегас) на основе класса Horse(лошадь) и интерфейса Fly(летать).
*/

public class Solution
{
    public static void main(String[] args)
    {
        Pegas horse = new Pegas();
    }

    public static interface Fly
    {
        public void fly();
    }

    public static class Horse
    {
        public void run()
        {

        }
    }

    public static class Pegas extends Horse implements Fly{

        @Override
        public void fly() {

        }
    }

}





БОЛЬШАЯ
package com.javarush.test.level13.lesson11.bonus03;

/* Битва роботов
1 Разобраться в том, что тут написано.
2 http://info.javarush.ru/uploads/images/00/00/07/2014/08/12/50f3e37f94.png
3 Смириться со своей участью и продолжить разбираться в коде.
4 ...
5 Порадоваться, что мы все поняли.

6 Изменить код согласно новой архитектуре и добавить новую логику:
6.1 Сделать класс AbstractRobot абстрактным, вынести логику атаки и защиты из Robot в AbstractRobot.
6.2 Отредактировать класс Robot учитывая AbstractRobot.
6.3 Расширить класс BodyPart новой частью тела "грудь".
6.4 Добавить новую часть тела в реализацию интерфейсов Attackable и Defensable (в классе AbstractRobot).

7 http://info.javarush.ru/uploads/images/00/00/07/2014/08/12/3b9c65580b.png
*/

public class Solution
{
    public static void main(String[] args)
    {
        Robot amigo = new Robot("Амиго");
        Robot enemy = new Robot("Сгибальщик-02");

        doMove(amigo, enemy);
        doMove(amigo, enemy);
        doMove(enemy, amigo);
        doMove(amigo, enemy);
        doMove(enemy, amigo);
        doMove(amigo, enemy);
        doMove(enemy, amigo);
        doMove(amigo, enemy);
    }

    public static void doMove(AbstractRobot robotFirst, AbstractRobot robotSecond) {
        BodyPart attacked = robotFirst.attack();
        BodyPart defenced = robotFirst.defense();
        System.out.println(String.format("%s атаковал робота %s, атакована %s, защищена %s",
                robotFirst.getName(), robotSecond.getName(), attacked, defenced));
    }
}
------------------------------------------------
package com.javarush.test.level13.lesson11.bonus03;

public final class BodyPart
{
    final static BodyPart LEG = new BodyPart("нога");
    final static BodyPart HEAD = new BodyPart("голова");
    final static BodyPart ARM = new BodyPart("рука");
    final static BodyPart CHEST = new BodyPart("грудь");

    private String bodyPart;

    private BodyPart(String bodyPart)
    {
        this.bodyPart = bodyPart;
    }

    @Override
    public String toString()
    {
        return this.bodyPart;
    }
}
-----------------------------------------------------
package com.javarush.test.level13.lesson11.bonus03;

public interface Attackable
{
    BodyPart attack();
}
--------------------------------------------------
package com.javarush.test.level13.lesson11.bonus03;

public interface Defensable
{
    BodyPart defense();
}
--------------------------------------------------
package com.javarush.test.level13.lesson11.bonus03;

public class Robot extends AbstractRobot implements Attackable, Defensable
{
    private static int hitCount;
    private String name;

    public Robot(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }

    public BodyPart attack()
    {
        BodyPart attackedBodyPart = null;
        hitCount = hitCount + 1;

        if (hitCount == 1)
        {
            attackedBodyPart =  BodyPart.ARM;
        } else if (hitCount == 2)
        {
            attackedBodyPart =  BodyPart.HEAD;
        } else if (hitCount == 3)
        {
            attackedBodyPart =  BodyPart.LEG;
        } else if (hitCount == 4)
        {
             hitCount = 0;
             attackedBodyPart =  BodyPart.CHEST;
        }
        return attackedBodyPart;
    }

    public BodyPart defense()
    {
        BodyPart defencedBodyPart = null;
        hitCount = hitCount + 1;

        if (hitCount == 1)
        {
            defencedBodyPart =  BodyPart.HEAD;
        } else if (hitCount == 2)
        {
            defencedBodyPart =  BodyPart.LEG;
        } else if (hitCount == 3)
        {
            defencedBodyPart =  BodyPart.ARM;
        }
        else if (hitCount == 4)
        {
            hitCount = 0;
            defencedBodyPart =  BodyPart.CHEST;
        }
        return defencedBodyPart;
    }
}
-----------------------------------------------
package com.javarush.test.level13.lesson11.bonus03;

public abstract class AbstractRobot implements Attackable, Defensable
{

    public abstract BodyPart attack();

    public abstract BodyPart defense();


    public String getName() {
        return null;
    }
}
--------------------------------------------------





_______________________________________________________________-INSTANCEOF

class Pet
{
}
class Cat extends Pet
{
}
class Tiger extends Cat
{
}	Тут мы видим три объявленных класса: животное, кот и тигр. Кот наследуется от Животного. А Тигр от Кота.
Object o = new Tiger();
boolean isCat = o instanceof Cat;
boolean isTiger = o instanceof Tiger;
boolean isPet = o instanceof Pet;	isCat будет равно true.
isTiger будет равно true.
isPet будет равно true.
Object o = new Pet();
boolean isCat = o instanceof Cat;
boolean isTiger = o instanceof Tiger;
boolean isPet = o instanceof Pet;	isCat будет равно false.
isTiger будет равно false.
isPet будет равно true.


Object o = new Integer(3);
boolean isInt = o instanceof Integer;	isInt будет равно true. Объект, на который ссылается переменная o, является объектом класса Integer.
Object o = "Mama";
boolean isInt = o instanceof Integer;	isInt будет равно false. Объект, на который ссылается переменная o, не является объектом класса Integer, он является объектом класса String.
InputStream is = new FileInputStream("");
boolean isFIS = is instanceof FileInputStream;	isFIS будет равно true. Объект, на который ссылается переменная o, является объектом класса FileInputStream.

interface Moveable
{
}
class Cat
{
}
class TomCat extends Cat implements Moveable
{
}	Создадим два класса: Cat, TomCat и интерфейс Moveable
Cat o = new TomCat();
boolean isCat = o instanceof Cat;
boolean isMoveable = o instanceof Moveable;
boolean isTom = o instanceof TomCat;	isCat будет равно true.
isMoveable будет равно true.
isTom будет равно true.
Cat o = new Cat();
boolean isCat = o instanceof Cat;
boolean isMoveable = o instanceof Moveable;
boolean isTom = o instanceof TomCat;	isCat будет равно true.
isMoveable будет равно false.
isTom будет равно false.
Оператор instanceof имеет вид: a instanceof B.

Другими словами, оператор instanceof вернет значение true, если:

1) переменная а хранит ссылку на объект типа B

2) переменная а хранит ссылку на объект, класс которого унаследован от B

3) переменная а хранит ссылку на объект реализующий интерфейс B

Иначе оператор instanceof вернет значение false.







package com.javarush.test.level14.lesson02.task01;

/* Bingo
Исправь строчку 'Object o = new Pet();' в методе main так, чтобы программа вывела "Bingo!"
*/

public class Solution
{
    public static void main(String[] args)
    {
        Object o = new Tiger();
        boolean isCat = o instanceof Cat;
        boolean isTiger = o instanceof Tiger;
        boolean isPet = o instanceof Pet;

        printResults(isCat, isTiger, isPet);
    }

    private static void printResults(boolean cat, boolean tiger, boolean pet)
    {
        if (cat && tiger && pet) System.out.println("Bingo!");
    }

    static class Pet
    {
    }

    static class Cat extends Pet
    {
    }

    static class Tiger extends Cat
    {
    }

}



package com.javarush.test.level14.lesson02.task02;

/* Bingo-2
Исправь строчку 'Cat o = new Cat();' так, чтобы программа вывела "Bingo!"
*/

public class Solution
{
    public static void main(String[] args)
    {
        Cat o = new TomCat();

        boolean isCat = o instanceof Cat;
        boolean isMoveable = o instanceof Moveable;
        boolean isTom = o instanceof TomCat;

        if (isCat && isMoveable && isTom) System.out.println("Bingo!");

    }

    interface Moveable
    {
    }

    static class Cat
    {
    }

    static class TomCat extends Cat implements Moveable
    {

    }
}








РАСШИРЕНИЕ ТИПА

class Pet
{
 public void doPetActions();
}

class Cat extends Pet
{
 public void doCatActions();
}

class Tiger extends Cat
{
 public void doTigerActions();
}

!!!!!!!!Движение вверх по цепочке наследования называется сужением, т.к. теряется возможность вызвать методы, которые были добавлены в класс при наследовании.

Код	Описание
public static void main(String[] args)
{
 Object obj = new Tiger();
 Pet pet = (Pet) obj;
 Cat cat = (Cat) obj;
 Tiger tiger = (Tiger) pet;
 Tiger tiger2 = (Tiger) cat;
}	При расширении типа, нужно использовать оператор преобразования типа.

При этом Java-машина выполняет проверку, а действительно ли данный объект унаследован от Типа, к которому мы хотим его преобразовать.

Такое небольшое нововведение уменьшило количество ошибок в преобразовании типов в разы, и существенно повысило стабильность работы Java-программ.
public static void main(String[] args)
{
 Object obj = new Tiger();
 if (obj instanceof Cat)
 {
  Cat cat = (Cat) obj;
  cat.doCatActions();
 }

}	Еще лучше – использовать проверку instanceof
public static void main(String[] args)
{
 Pet pet = new Tiger();
 doAllAction(pet);

 Pet pet2 = new Cat();
 doAllAction(pet2);

 Pet pet3 = new Pet();
 doAllAction(pet3);
}

public static void doAllAction(Pet pet)
{
 if (pet instanceof Tiger)
 {
  Tiger tiger = (Tiger) pet;
  tiger.doTigerActions();
 }

 if (pet instanceof Cat)
 {
  Cat cat = (Cat) pet;
  cat.doCatActions();
 }

 pet.doPetActions();
}	И вот почему. Смотрим на пример слева.

Мы (наш код) не всегда знаем, с объектом какого типа мы работаем. Это может быть как объект того же типа, что и переменная (Pet), так и любой тип-наследник (Cat, Tiger).

Рассмотрим метод doAllAction. Он корректно работает в независимости от того, объект какого типа в него передали.

Т.е. он корректно работает для всех трех типов Pet, Cat, Tiger.
public static void main(String[] args)
{
 Cat cat = new Tiger();
 Pet pet = cat;
 Object obj = cat;
}	Тут мы видим три присваивания. Все они являются примерами сужения типа.

Оператор преобразования типа тут не нужен, т.к. не нужна проверка. Ссылку на объект всегда можно сохранить в переменную любого его базового типа.





package com.javarush.test.level14.lesson04.task01;

/* Building и School
1. Расставь правильно наследование между Building(здание) и School(здание школы).
2. Подумай, объект какого класса должны возвращать методы getSchool и getBuilding.
3. Измени null на объект класса Building или School.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Building school = getSchool();
        Building shop = getBuilding();

        System.out.println(school);
        System.out.println(shop);
    }



    public static Building getSchool()
    {
        return new School();
    }

    public static Building getBuilding()
    {
        return new Building();

    }

    static class School extends Building
    {
        @Override
        public String toString()
        {
            return "School";
        }
    }

    static class Building
    {
        @Override
        public String toString()
        {
            return "Building";
        }
    }
}






package com.javarush.test.level14.lesson04.task02;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Коты
1. Считывать строки(параметры) с консоли, пока пользователь не введет пустую строку(Enter).
2. Каждый параметр соответствует имени кота.
Для каждого параметра:
3. Создать объект cat класса Cat, который равен коту из getCatByKey(String параметр).
4. Вывести на экран cat.toString().
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

         boolean enter = true;

        while(enter){
            String catName = reader.readLine();
            if(!catName.isEmpty()){
                Cat cat = CatFactory.getCatByKey(catName);
                System.out.println(cat.toString());
            }
            else{
                    break;
            }
        }
    }

    static class CatFactory
    {

        static Cat getCatByKey(String key)
        {
            Cat cat = null;
            if ("vaska".equals(key))
            {
                cat = new MaleCat("Василий");
            } else if ("murka".equals(key))
            {
                cat = new FemaleCat("Мурочка");
            } else if ("kiska".equals(key))
            {
                cat = new FemaleCat("Кисюлька");
            } else
            {
                cat = new Cat(key);
            }

            return cat;
        }
    }

    static class Cat
    {
        private String name;

        protected Cat(String name)
        {
            this.name = name;
        }

        public String getName()
        {
            return this.name;
        }

        public String toString()
        {
            return "Я уличный кот " + getName();
        }
    }

    static class MaleCat extends Cat
    {
        MaleCat(String name)
        {
            super(name);
        }

        public String toString()
        {
            return "Я - солидный кошак по имени " + getName();
        }
    }

    static class FemaleCat extends Cat
    {
        FemaleCat(String name)
        {
            super(name);
        }

        public String toString()
        {
            return "Я - милая кошечка по имени " + getName();
        }
    }
}




package com.javarush.test.level14.lesson04.task03;

/* Food
1. Реализовать интерфейс Selectable в классе Food.
2. Метод onSelect() должен писать в консоль "food is selected".
3. Подумай, какие методы можно вызвать для переменной food и какие для selectable.
4. В методе foodMethods вызови методы onSelect, eat, если это возможно.
5. В методе selectableMethods вызови методы onSelect, eat, если это возможно.
6. Явное приведение типов не использовать.
*/

public class Solution {
    public static void main(String[] args) {
        Food food = new Food();
        Selectable selectable = new Food();
        Food newFood = (Food) selectable;

        foodMethods(food);
        selectableMethods(selectable);
    }

    public static void foodMethods(Food food) {
        food.eat();

        food.onSelect();
    }
    public static void selectableMethods(Selectable selectable) {

        selectable.onSelect();
    }

    interface Selectable
    {
        void onSelect();
    }

    static class Food implements Selectable
    {
        public void eat()
        {
            System.out.println("food is eaten");
        }

        @Override
        public void onSelect() {
            System.out.println("food is selected");
        }
    }
}




package com.javarush.test.level14.lesson04.task04;

/* Без ошибок
Инициализировать объект obj таким классом, чтобы метод main выполнился без ошибок.
*/



public class Solution
{
    public static void main(String[] args)
    {
        Object obj = new Jerry();

        Mouse mouse = (Mouse) obj;
        GreyMouse greyMouse = (GreyMouse) mouse;
        Jerry jerry = (Jerry) greyMouse;

        printClasses(obj, mouse, greyMouse, jerry);

    }

    public static void printClasses(Object obj, Mouse mouse, GreyMouse greyMouse, Jerry jerry)
    {
        System.out.println(jerry.getClass().getSimpleName());
        System.out.println(greyMouse.getClass().getSimpleName());
        System.out.println(mouse.getClass().getSimpleName());
        System.out.println(obj.getClass().getSimpleName());
    }

    static class Mouse
    {
    }

    static class GreyMouse extends Mouse
    {
    }

    static class Jerry extends GreyMouse
    {
    }
}



package com.javarush.test.level14.lesson04.task05;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Player and Dancer
1. Подумать, что делает программа.
2. Изменить метод haveRest так, чтобы он вызывал метод
- play, если person имеет тип Player
- dance, если person имеет тип Dancer
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        Person person = null;
        String key;
        while (!(key = reader.readLine()).equals("exit")) {
            if ("player".equals(key)) {
                person = new Player();
            } else if ("dancer".equals(key)) {
                person = new Dancer();
            } else {
                haveRest(person);
            }
        }
    }

    public static void haveRest(Person person)
    {
        if(person instanceof  Player){
            ((Player) person).play();
        }
        else if(person instanceof  Dancer){
            ((Dancer) person).dance();
        }
    }

    interface Person
    {
    }

    static class Player implements Person
    {
        void play()
        {
            System.out.println("playing");
        }
    }

    static class Dancer implements Person
    {
        void dance()
        {
            System.out.println("dancing");
        }
    }
}









БОЛЬШОЕ КУРИНАЯ ФАБРИКА________________________________________________________________________________________________
package com.javarush.test.level14.lesson06.home01;

/* Куриная фабрика
Написать Фабрику(Factory) по производству кур(Hen)
1. Создать класс Hen
1.1. Сделать его абстрактным
1.2. Добавить в класс абстрактный метод  int getCountOfEggsPerMonth()
1.3. Добавить в класс метод String getDescription(), который возвращает строку "Я курица."

2. Создать класс RussianHen, который наследуется от Hen
3. Создать класс UkrainianHen, который наследуется от Hen
4. Создать класс MoldovanHen, который наследуется от Hen
5. Создать класс BelarusianHen, который наследуется от Hen

6. В каждом из четырех последних классов написать свою реализацию метода getCountOfEggsPerMonth.
Методы должны возвращать количество яиц в месяц от данного типа куриц.

7. В каждом из четырех последних классов написать свою реализацию метода getDescription.
Методы должны возвращать строку вида:
<getDescription() родительского класса>  + <" Моя страна - Sssss. Я несу N яиц в месяц.">
где Sssss - название страны
где N - количество яиц в месяц

8. В классе HenFactory реализовать метод getHen, который возвращает соответствующую стране породу кур
9. Все созданные вами классы должны быть в отдельных файлах
*/


public class Solution {
    public static void main(String[] args) {

        Hen hen = HenFactory.getHen(Country.BELARUS);
        System.out.println(hen.getDescription());
        Hen hen1 = HenFactory.getHen(Country.RUSSIA);
        System.out.println(hen1.getDescription());
        Hen hen2 = HenFactory.getHen(Country.UKRAINE);
        System.out.println(hen2.getDescription());
        Hen hen3 = HenFactory.getHen(Country.MOLDOVA);
        System.out.println(hen3.getDescription());
        hen.getCountOfEggsPerMonth();
    }

    public static class HenFactory {

        public static Hen getHen(String country) {

            Hen hen = null;

            if (country.equals(Country.RUSSIA)) {
                hen = new RussianHen();
            } else if (country.equals(Country.BELARUS)) {
                hen = new BelarusianHen();
            } else if (country.equals(Country.MOLDOVA)) {
                hen = new MoldovanHen();
            } else if (country.equals(Country.UKRAINE)) {
                hen = new UkrainianHen();
            } else {
                hen = null;

            }
            return hen;
        }
    }
}
----------------------------------------------
package com.javarush.test.level14.lesson06.home01;

public interface Country
{
    String UKRAINE = "Ukraine";
    String RUSSIA = "Russia";
    String MOLDOVA = "Moldova";
    String BELARUS = "Belarus";
}
------------------------------------------------
package com.javarush.test.level14.lesson06.home01;

/**
 * Created by Кира on 19.04.2016.
 */
public abstract class Hen {

        abstract int getCountOfEggsPerMonth();

        String getDescription() {
            return "Я курица.";
        }
}

-----------------------------------------------------
package com.javarush.test.level14.lesson06.home01;

/**
 * Created by Кира on 19.04.2016.
 */
public class BelarusianHen extends Hen {

    @Override
    int getCountOfEggsPerMonth() {
        return 7;
    }

    String getDescription() {
        return super.getDescription() + (" Моя страна - " + Country.BELARUS + ". Я несу " + getCountOfEggsPerMonth() + " яиц в месяц.");
    }
}
------------------------------------------------
package com.javarush.test.level14.lesson06.home01;

/**
 * Created by Кира on 19.04.2016.
 */
public class MoldovanHen extends Hen {

    @Override
    int getCountOfEggsPerMonth() {
        return 8;
    }

    String getDescription() {
        return super.getDescription() + (" Моя страна - " + Country.MOLDOVA + ". Я несу " + getCountOfEggsPerMonth() + " яиц в месяц.");
    }
}
--------------------------------
package com.javarush.test.level14.lesson06.home01;

/**
 * Created by Кира on 19.04.2016.
 */
public class UkrainianHen extends Hen {

    @Override
    int getCountOfEggsPerMonth() {
        return 13;
    }

    String getDescription() {
        return super.getDescription() + (" Моя страна - " + Country.UKRAINE + ". Я несу " + getCountOfEggsPerMonth() + " яиц в месяц.");
    }
}
---------------------------------
package com.javarush.test.level14.lesson06.home01;

/**
 * Created by Кира on 19.04.2016.
 */
public class RussianHen extends Hen {

    @Override
    int getCountOfEggsPerMonth() {
        return 5;
    }

    String getDescription() {
        return super.getDescription() + (" Моя страна - " + Country.RUSSIA + ". Я несу " + getCountOfEggsPerMonth() + " яиц в месяц.");
    }
}










package com.javarush.test.level14.lesson08.home01;

/* Мосты
1. Создать интерфейс Bridge с методом int getCarsCount().
2. Создать классы WaterBridge и SuspensionBridge, которые реализуют интерфейс Bridge.
3. Метод getCarsCount() должен возвращать любое захардкоженое значение типа int
4. Метод getCarsCount() должен возвращать различные значения для различных классов
5. В классе Solution создать публичный метод println(Bridge bridge).
6. В методе println вывести на консоль значение getCarsCount() для объекта bridge.
7. Каждый класс и интерфейс должны быть в отдельных файлах.
*/

public class Solution
{
    public static void main(String[] args)
    {
        println(new WaterBridge());
        println(new SuspensionBridge());
    }

    public static void println(Bridge bridge){
        System.out.println(bridge.getCarsCount());

    }
}
--------------------------------
package com.javarush.test.level14.lesson08.home01;

/**
 * Created by Кира on 20.04.2016.
 */
public interface Bridge {
    int getCarsCount();
}
--------------------------------
package com.javarush.test.level14.lesson08.home01;

/**
 * Created by Кира on 20.04.2016.
 */
public class SuspensionBridge implements Bridge {

    @Override
    public int getCarsCount() {
        return 8;
    }
}
-----------------------------
package com.javarush.test.level14.lesson08.home01;

/**
 * Created by Кира on 20.04.2016.
 */
public class WaterBridge implements Bridge {
    @Override
    public int getCarsCount() {
        return 06;
    }
}






package com.javarush.test.level14.lesson08.home02;

/* Дегустация вин
1. Создать абстрактный класс Drink с реализованным методом public void taste(), который выводит в консоль "Вкусно"
2. Создать класс Wine, который наследуется от Drink, с реализованным методом public String getHolidayName(), который возвращает строку "День рождения"
3. Создать класс BubblyWine, который наследуется от Wine, с реализованным методом public String getHolidayName(), который возвращает строку "Новый год"
4. Написать реализацию методов getDeliciousDrink, getWine, getBubblyWine
5. Каждый класс и интерфейс должны быть в отдельных файлах
6. Метод main менять нельзя!
*/

public class Solution {
    public static void main(String[] args) {
        getDeliciousDrink().taste();
        System.out.println(getWine().getHolidayName());
        System.out.println(getBubblyWine().getHolidayName());
        System.out.println(getWine().getHolidayName());
    }

    public static Drink getDeliciousDrink() {

        return new Wine();
    }

    public static Wine getWine() {

        return new Wine();
    }

    public static Wine getBubblyWine() {

        return new BubblyWine();
    }
}
---------------------------
package com.javarush.test.level14.lesson08.home02;

/**
 * Created by Кира on 20.04.2016.
 */
public abstract class Drink {
    public void taste(){
        System.out.println("Вкусно");
    }
}
--------------------------------
package com.javarush.test.level14.lesson08.home02;

/**
 * Created by Кира on 20.04.2016.
 */
public class Wine extends Drink{
    public String getHolidayName(){
        return "День рождения";
    }
}
------------------------------
package com.javarush.test.level14.lesson08.home02;

/**
 * Created by Кира on 20.04.2016.
 */
public class BubblyWine extends Wine {
    public String getHolidayName(){
        return "Новый год";
    }
}
--------------------------------




package com.javarush.test.level14.lesson08.home03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* User, Looser, Coder and Proger
1. Ввести [в цикле] с клавиатуры несколько строк (ключей).
Строки(ключи) могут быть такими: "user", "looser", "coder", "proger".
Ввод окончен, когда строка не совпадает ни с одной из выше указанных.

2. Для каждой введенной строки нужно:
2.1. Создать соответствующий объект [см Person.java], например, для строки "user" нужно создать объект класса User.
2.2. Передать этот объект в метод doWork.

3. Написать реализацию метода doWork, который:
3.1. Вызывает метод live() у переданного обекта, если этот объект (person) имеет тип User.
3.2. Вызывает метод doNothing(), если person имеет тип Looser.
3.3. Вызывает метод coding(), если person имеет тип Coder.
3.4. Вызывает метод enjoy(), если person имеет тип Proger.
*/

public class Solution
{
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        Person person = null;
        String key = null;

        while (true) {
            key = reader.readLine();
            if ("user".equals(key) || "looser".equals(key) || "coder".equals(key) || "proger".equals(key)) {

                if (key.equals("user")) {
                    person = new Person.User();
                    doWork(person);
                } else if (key.equals("looser")) {
                    person = new Person.Looser();
                    doWork(person);
                } else if (key.equals("coder")) {
                    person = new Person.Coder();
                    doWork(person);
                } else if (key.equals("proger")) {
                    person = new Person.Proger();
                    doWork(person);
                }
            } else {
                break;

            }
        }
    }


    public static void doWork(Person person)
    {
        if(person instanceof Person.User){
            ((Person.User) person).live();
        }
        if(person instanceof Person.Looser){
            ((Person.Looser) person).doNothing();
        }
        if(person instanceof Person.Coder){
            ((Person.Coder) person).coding();
        }
        if(person instanceof Person.Proger){
            ((Person.Proger) person).enjoy();
        }
    }
}
------------------------
package com.javarush.test.level14.lesson08.home03;

public interface Person
{
    public static class User implements Person
    {
        void live()
        {
            System.out.println("Usually I just live");
        }
    }

    public static class Looser implements Person
    {
        void doNothing()
        {
            System.out.println("Usually I do nothing");
        }
    }

    public static class Coder implements Person
    {
        void coding()
        {
            System.out.println("Usually I create code");
        }
    }

    public static class Proger implements Person
    {
        void enjoy()
        {
            System.out.println("Wonderful life!");
        }
    }

}









__________________________________________________________________________СМОТРЕТЬ СМОТРЕТЬ И ЕЩЕ РАЗ СМОТРЕТЬ!!!!!!!ПАРСИНГ!!!!!!
package com.javarush.test.level15.lesson12.home09;

/* Парсер реквестов
Считать с консоли URl ссылку.
Вывести на экран через пробел список всех параметров (Параметры идут после ? и разделяются &, например, lvl=15).
URL содержит минимум 1 параметр.
Если присутствует параметр obj, то передать его значение в нужный метод alert.
alert(double value) - для чисел (дробные числа разделяются точкой)
alert(String value) - для строк

Пример 1
Ввод:
http://javarush.ru/alpha/index.html?lvl=15&view&name=Amigo
Вывод:
lvl view name

Пример 2
Ввод:
http://javarush.ru/alpha/index.html?obj=3.14&name=Amigo
Вывод:
obj name
double 3.14
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class Solution {
    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] parameters = reader.readLine().split("\\?")[1].split("&");
        ArrayList<String> objList = new ArrayList<String>();
        String[] parURL;
        int i = 0;

        for (String s : parameters)
        {
            i++;
            parURL = s.split("=");
            if (parURL.length == 2 && parURL[0].equals("obj")) 
                objList.add(parURL[1]);
            if (i == parameters.length) 
                System.out.print(parURL[0]);
            else System.out.print(parURL[0] + " ");
        }
        if (!objList.isEmpty()) System.out.println();
        for (String s : objList)
        {
            try {
                double doubleVal = Double.parseDouble(s);
                alert(doubleVal);
            } catch (NumberFormatException e) {
                alert(s);
            }
        }
    }


    public static void alert(double value) {
        System.out.println("double " + value);
    }

    public static void alert(String value) {
        System.out.println("String " + value);
    }
}











package com.javarush.test.level15.lesson12.bonus02;

/* Template pattern
1. В отдельном файле создать класс DrinkMaker с тремя абстрактными методами:
- void getRightCup() - выбрать подходящую чашку
- void putIngredient() - положить ингредиенты
- void pour() - залить жидкостью
2. В классе DrinkMaker создать и реализовать метод void makeDrink(), который готовит напиток в такой последовательности: выбирает чашку, кладет ингредиенты, заливает жидкостью.
3. В отдельных файлах создать классы LatteMaker и TeaMaker, которые наследуются от DrinkMaker.
4. Распредели следующие фразы между всеми методами в классах LatteMaker и TeaMaker, различные фразы для различных методов.
5. Каждый метод должен выводить в консоль свою фразу не пересекаясь с другими методами.
6. Фразы:
"Заливаем водой"
"Берем чашку для латте"
"Насыпаем чай"
"Берем чашку для чая"
"Заливаем молоком с пенкой"
"Делаем кофе"
*/

public class Solution {
    public static void main(String[] args) {

        TeaMaker tea = new TeaMaker();
        LatteMaker latte = new LatteMaker();

        tea.makeDrink();
        latte.makeDrink();


    }
}
---------------------------
package com.javarush.test.level15.lesson12.bonus02;

/**
 * Created by User on 23.04.2016.
 */
public class TeaMaker extends DrinkMaker {
    @Override
    void getRightCup() {

        System.out.println("Берем чашку для чая");

    }

    @Override
    void putIngredient() {

        System.out.println("Насыпаем чай");
    }

    @Override
    void pour() {

        System.out.println("Заливаем водой");
    }
}
----------------------------
package com.javarush.test.level15.lesson12.bonus02;

/**
 * Created by User on 23.04.2016.
 */
public class LatteMaker extends DrinkMaker {
    @Override
    void getRightCup() {

        System.out.println("Берем чашку для латте");
    }

    @Override
    void putIngredient() {

        System.out.println("Делаем кофе");
    }

    @Override
    void pour() {

        System.out.println("Заливаем молоком с пенкой");
    }
}
-------------------------
package com.javarush.test.level15.lesson12.bonus02;

/**
 * Created by User on 23.04.2016.
 */
public abstract class DrinkMaker {

    abstract void getRightCup();

    abstract void putIngredient();

    abstract void pour();

    void makeDrink(){
        getRightCup();
        putIngredient();
        pour();
    }

}









package com.javarush.test.level15.lesson12.bonus01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Осваивание статического блока
1. В отдельных файлах создать классы Plane и Helicopter, реализующие интерфейс Flyable.
2. Класс Plane должен иметь 1 конструктор с параметром int - количество перевозимых пассажиров.
3. В статическом методе reset класса Solution:
3.1. Считать с консоли параметр типа String. Параметр может быть "plane" или "helicopter".
3.2. Если параметр равен "helicopter", то статическому объекту Flyable result присвоить объект класса Helicopter.
3.3. Если параметр равен "plane", то считать второй параметр типа int, статическому объекту Flyable result присвоить объект класса Plane.
4. В статическом блоке инициализировать Flyable result вызвав метод reset.
5. Закрыть поток ввода методом close().
*/

public class Solution {

    static {

        try {
            reset();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static Flyable result;

    public static void reset() throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String read = reader.readLine();

            if(read.equals("helicopter")){
                result = new Helicopter();
            }
            if(read.equals("plane")){
                result = new Plane(Integer.parseInt(reader.readLine()));
            }
            else{
                reader.close();
            }
        }

}
-----------------------
package com.javarush.test.level15.lesson12.bonus01;

public interface Flyable {
    void fly();
}

-----------------------
package com.javarush.test.level15.lesson12.bonus01;

/**
 * Created by User on 23.04.2016.
 */
public class Helicopter implements Flyable {
    @Override
    public void fly() {

    }
}
--------------------------
public class Plane implements Flyable {

    int amount;
    Plane(int amount)
    {
        this.amount = amount;
    }
    public void fly(){}
}

















_________________________________________________________________________________________ТРЭДЫ
package com.javarush.test.level16.lesson03.task01;

/* My first thread
Создать public static class TestThread - нить с помощью интерфейса Runnable.
TestThread должен выводить в консоль "My first thread".
*/
public class Solution {
    public static void main(String[] args) {

        TestThread task = new TestThread();
            new Thread(task).start();
    }

    public static class TestThread implements Runnable{

        @Override
        public void run() {
            System.out.println("My first thread");
        }

    }
}










package com.javarush.test.level16.lesson03.task02;

/* My second thread
1. Создать public static класс TestThread унаследовавшись от класса Thread.
2. Создать статик блок внутри TestThread, который выводит в консоль "it's static block inside TestThread".
3. Метод run должен выводить в консоль "it's run method".
*/

public class Solution {
    public static void main(String[] args) {
        TestThread thread = new TestThread();
        thread.start();
    }

    public static class TestThread extends Thread {

        static{
            System.out.println("it's static block inside TestThread");
        }
        public void run() {
            System.out.println("it's run method");
        }
    }
}










package com.javarush.test.level16.lesson03.task03;

import java.util.ArrayList;
import java.util.List;

/* Список и нити
В методе main добавить в статический объект list 5 нитей SpecialThread - различных объектов.
*/

public class Solution {
    public static volatile List<Thread> list = new ArrayList<Thread>(5);

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            Runnable one = new SpecialThread();
            list.add(new Thread(one));

        }
    }
        public static class SpecialThread implements Runnable{
            public void run() {
                System.out.println("it's run method inside SpecialThread");
            }
    }
}










package com.javarush.test.level16.lesson03.task04;

/* Вывод стек-трейса
1. Создать таск - класс public static SpecialThread - на основании интерфейса Runnable
2. SpecialThread должен выводить в консоль свой стек-трейс.
Подсказка: main thread уже выводит в консоль свой стек-трейс.
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new SpecialThread());
        thread.start();

        System.out.println("*****************");

        for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
            System.out.println(element);
        }
    }

    public static class SpecialThread implements Runnable {
        @Override
        public void run() {

            for (StackTraceElement element : Thread.currentThread().getStackTrace())
            {
                System.out.println(element);

            }
        }
    }
}







package com.javarush.test.level16.lesson03.task05;

import java.util.Date;

/* Поговорим о музыке?
1. Измените класс Violin так, чтоб он стал таском для нити. Используйте интерфейс MusicalInstrument
2. Реализуй необходимый метод в нити Violin. Реализация должна быть следующей:
2.1. Считай время начала игры - метод startPlaying().
2.2. Подожди 1 секунду - метод sleepNSeconds(int n), где n - количество секунд.
2.3. Считай время окончания игры - метод stopPlaying().
2.4. Выведи на консоль продолжительность игры в миллисекундах. Пример "Playing 1002 ms".
*/

public class Solution {
    public static void main(String[] args) {
        Thread violin = new Thread(new Violin("Player"));
        violin.start();

    }

    public static class Violin implements MusicalInstrument {
        private String owner;

        public Violin(String owner) {
            this.owner = owner;
        }

        public Date startPlaying() {
            System.out.println(this.owner + " starts playing");
            return new Date();
        }


        public Date stopPlaying() {
            System.out.println(this.owner + " stops playing");
            return new Date();
        }

        @Override
        public void run() {

            Date start = startPlaying();
            sleepNSeconds(1);
            Date stop = stopPlaying();
            System.out.println("Playing " + (stop.getTime() - start.getTime()) + " ms");
        }
    }
    public static int delay = 1000;

    public static void sleepNSeconds(int n) {
        try {
            Thread.sleep(n * delay);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static interface MusicalInstrument extends Runnable {
        Date startPlaying();

        Date stopPlaying();
    }
}










package com.javarush.test.level16.lesson05.task01;

import java.util.ArrayList;
import java.util.List;

/* join
Подумайте, в каком месте и для какого объекта нужно вызвать метод join, чтобы результат выводился по-порядку
сначала для firstThread, а потом для secondThread.
Вызовите метод join в нужном месте.
Пример вывода:
firstThread : String 1
firstThread : String 2
...
firstThread : String 19
firstThread : String 20
secondThread : String 1
...
secondThread : String 20
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        PrintListThread firstThread = new PrintListThread("firstThread");
        PrintListThread secondThread = new PrintListThread("secondThread");
        firstThread.start();
        firstThread.join();
        secondThread.start();
    }

    public static class PrintListThread extends Thread {
        public PrintListThread(String name) {
            super(name);
        }

        public void run() {
            printList(getList(20), getName());
        }
    }

    public static void printList(List<String> list, String threadName) {
        for (String item : list) {
            System.out.println(String.format("%s : %s", threadName, item));
        }
    }

    public static List<String> getList(int n) {
        List<String> result = new ArrayList<String>();
        if (n < 1) return result;

        for (int i = 0; i < n; i++) {
            result.add(String.format("String %d", (i + 1)));
        }
        return result;
    }
}










_____________________________________________________________________________________________ПРОГРАММА ПРО ЛОШАДЕЙ!!!!СМОТРЕТЬ!!!!!!!!!


package com.javarush.test.level16.lesson05.task02;

import java.util.ArrayList;
import java.util.List;

/* Horse Racing
Разберись, что делает программа.
Реализуй метод calculateHorsesFinished. Он должен:
1. Посчитать количество финишировавших лошадей и возвратить его. Используй метод isFinished().
2. Если лошадь еще не пришла к финишу (!isFinished()), то:
2.1. Вывести в консоль "Waiting for " + horse.getName().
2.2. Подождать, пока она завершит гонку. Подумай, какой метод нужно использовать для этого.
*/

public class Solution {

    public static int countHorses = 10;

    public static void main(String[] args) throws InterruptedException {
        List<Horse> horses = prepareHorsesAndStart();
        while (calculateHorsesFinished(horses) != countHorses) {
        }
    }

    public static int calculateHorsesFinished(List<Horse> horses) throws InterruptedException {
        int countFinished = 0;

        for(int i = 0; i < horses.size(); i++){
            if(horses.get(i).isFinished){
                countFinished++;
            }
            if(!horses.get(i).isFinished()){
                System.out.println("Waiting for" + horses.get(i).getName());
                horses.get(i).join();
            }
        }


        return countFinished;
    }

    public static class Horse extends Thread {

        public Horse(String name) {
            super(name);
        }

        private boolean isFinished;

        public boolean isFinished() {
            return isFinished;
        }

        public void run() {
            String s = "";
            for (int i = 0; i < 1001; i++) {   //delay
                s += new String("" + i);
                if (i == 1000) {
                    s = " has finished the race!";
                    System.out.println(getName() + s);
                    isFinished = true;
                }
            }
        }
    }

    public static List<Horse> prepareHorsesAndStart() {
        List<Horse> horses = new ArrayList<Horse>(countHorses);
        String number;
        for (int i = 1; i < countHorses + 1; i++) {
            if (i < 10) number = ("0" + i);
            else number = "" + i;
            horses.add(new Horse("Horse_" + number));
        }

        for (int i = 0; i < countHorses; i++) {
            horses.get(i).start();
        }
        return horses;
    }
}









package com.javarush.test.level16.lesson05.task03;

/* Продвижение на политических дебатах
1. Разберитесь, что делает программа.
2. Нужно сделать так, чтобы Иванов сказал больше всего речей на политических дебатах.
3. Подумай, какой метод можно вызвать у объекта ivanov, чтобы Иванов разговаривал, пока не завершится всё свободное время.
*/

public class Solution {
    public static int totalCountSpeeches = 200;
    public static int soundsInOneSpeech = 1000000;

    public static void main(String[] args) throws InterruptedException {
        Politic ivanov = new Politic("Иванов");
        Politic petrov = new Politic("Петров");
        Politic sidorov = new Politic("Сидоров");

        Thread thread1 = new Thread(ivanov);
        thread1.start();
        thread1.join();
        Thread thread2 = new Thread(petrov);
        thread2.start();
        Thread thread3 = new Thread(sidorov);
        thread3.start();


        while (ivanov.getCountSpeaches() + petrov.getCountSpeaches() + sidorov.getCountSpeaches() < totalCountSpeeches) {
        }

        System.out.println(ivanov);
        System.out.println(petrov);
        System.out.println(sidorov);

    }

    public static class Politic extends Thread {

        private int countSounds;

        public Politic(String name) {
            super(name);
            start();

        }

        public void run() {
            while (countSounds < totalCountSpeeches * soundsInOneSpeech) {
                countSounds++;
            }
        }

        public int getCountSpeaches() {
            return countSounds / soundsInOneSpeech;
        }

        @Override
        public String toString() {
            return String.format("%s сказал речь %d раз", getName(), getCountSpeaches());
        }
    }
}











package com.javarush.test.level16.lesson05.task04;

/* Справедливость
1. Разберитесь, что делает программа.
2. Нужно сделать так, чтобы все мыши ели одновременно.
3. Подумай, какой метод позволяет альфа-самцу мыши есть первым, и почему остальные мыши ждут.
4. Удали вызов этого метода.
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        Mouse alpha = new Mouse("#1");
		                                    // - alpha.join();
        Mouse mouse1 = new Mouse("#2");
        Mouse mouse2 = new Mouse("#3");
    }

    public static class Mouse extends Thread {
        public Mouse(String name) {
            super(name);
            start();
        }

        public void run() {
            System.out.println(getName() + " starts eating");
            eating();
            System.out.println(getName() + " finished");
        }
    }
    private static void eating() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
    }
}










Работа с InterruptedException
Если выдача InterruptedException означает, что метод является блокирующим, то вызов метода блокирования означает, что ваш метод также является блокирующим, 
и у вас должна быть стратегия для работы с InterruptedException. Зачастую наиболее простой стратегией является генерирование собственного InterruptedException
, как показано в методах putTask() и getTask() в Листинге 1. Выполняя это, вы также делаете ваш метод восприимчивым к прерыванию, и это для этого требуется
 всего-навсего добавить InterruptedException в вашу конструкцию throws.
Листинг 1. Распространение InterruptedException на вызывающие операторы без его перехвата
public class TaskQueue {
    private static final int MAX_TASKS = 1000;

    private BlockingQueue<Task> queue 
        = new LinkedBlockingQueue<Task>(MAX_TASKS);

    public void putTask(Task r) throws InterruptedException { 
        queue.put(r);
    }

    public Task getTask() throws InterruptedException { 
        return queue.take();
    }
}
Иногда необходимо произвести некоторую очистку, прежде чем распространить исключение. В этом случае вы можете перехватить InterruptedException, выполнить очистку,
 а затем повторно сгенерировать исключение. В Листинге 2, механизме подбора игроков в онлайновом игровом портале, показана именно такая технология. 
 Метод matchPlayers() ожидает прибытия двух игроков, а затем начинает новую игру. Если она прервана после того, как появился один игрок, но до появления второго,
 то он ставит игрока в конец очереди, прежде чем повторно выдать InterruptedException, так, чтобы запрос игрока не был утерян.
Листинг 2. Выполнение специализированной (task-specific) очистки перед повторной выдачей InterruptedException
public class PlayerMatcher {
    private PlayerSource players;

    public PlayerMatcher(PlayerSource players) { 
        this.players = players; 
    }

    public void matchPlayers() throws InterruptedException { 
        try {
             Player playerOne, playerTwo;
             while (true) {
                 playerOne = playerTwo = null;
                 // Wait for two players to arrive and start a new game
                 playerOne = players.waitForPlayer(); // could throw IE
                 playerTwo = players.waitForPlayer(); // could throw IE
                 startNewGame(playerOne, playerTwo);
             }
         }
         catch (InterruptedException e) {  
             // If we got one player and were interrupted, put that player back
             if (playerOne != null)
                 players.addFirst(playerOne);
             // Then propagate the exception
             throw e;
         }
    }
}
Не поглощайте прерывания
Иногда генерирование InterruptedException не является опцией, как в случае задачи, определяемой Runnable, которая вызывает прерываемый метод. 
В этом случае вы не можете повторно выдать InterruptedException, но вообще ничего не делать нельзя. Когда метод блокирования обнаруживает прерывание 
и выдает InterruptedException, то он очищает статус прерывания. Если вы перехватили InterruptedException, но не можете повторно его сгенерировать, 
то вы должны сохранить подтверждение того, что прерывание произошло так, чтобы вышестоящий в стеке вызовов код мог узнать о прерывании и среагировать 
на него, если он хочет это сделать. Эта задача выполняется с помощью вызова interrupt(), чтобы "повторно прервать" текущий поток, как показано в Листинге 3.
 По крайней мере, когда бы вы ни перехватили InterruptedException и не выдали его повторно, еще раз прервите текущий поток перед возвратом.
Листинг 3. Восстановление статуса прерывания после перехвата InterruptedException
public class TaskRunner implements Runnable {
    private BlockingQueue<Task> queue;

    public TaskRunner(BlockingQueue<Task> queue) { 
        this.queue = queue; 
    }

    public void run() { 
        try {
             while (true) {
                 Task task = queue.take(10, TimeUnit.SECONDS);
                 task.execute();
             }
         }
         catch (InterruptedException e) { 
             // Restore the interrupted status
             Thread.currentThread().interrupt();
         }
    }
}







package com.javarush.test.level16.lesson05.task05;

/* Расставь вызовы методов join()
1. Разберитесь, что делает программа.
2. Расставь вызовы методов join() так, чтобы для каждой кошки выполнялось следующее:
2.1. Сначала кошка рожает котят.
2.2. Потом все котята вылазят из корзинки в произвольном порядке.
2.3. В конце кошка собирает их назад в корзинку.
2.4. Все события для одной кошки могут быть перемешаны с событями для другой кошки.
2.5. Добавить сон котят (200 мс) в investigateWorld
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        Cat cat1 = new Cat("Мурка");
        Cat cat2 = new Cat("Пушинка");

        Thread catOne = new Thread(cat1);
        catOne.start();
        Thread catTwo = new Thread(cat2);
        catTwo.start();
    }

    public static class Cat extends Thread {
        protected Kitten kitten1;
        protected Kitten kitten2;

        public Cat(String name) {
            super(name);
            kitten1 = new Kitten("Котенок 1, мама - " + getName());
            kitten2 = new Kitten("Котенок 2, мама - " + getName());
            start();
        }

        public void run() {
            System.out.println(getName() + " родила 2 котенка");
            try {
                initAllKitten();
            } catch (InterruptedException e) {

                System.out.println(e);                                                   //Thread.currentThread().interrupt(); - в зависимости от ситуации
            }
            System.out.println(getName() + ": Все котята в корзинке. " + getName() + " собрала их назад");
        }

        private void initAllKitten() throws InterruptedException {
            kitten1.start();
            kitten1.join();
            kitten2.start();
            kitten2.join();
        }
    }

    public static class Kitten extends Thread {
        public Kitten(String name) {
            super(name);
        }

        public void run() {
            System.out.println(getName() + ", вылез из корзинки");
            investigateWorld();
        }
    }

    private static void investigateWorld() {

        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {

            System.out.println(e);                              //Thread.currentThread().interrupt(); - в зависимости от ситуации
        }
    }
}







package com.javarush.test.level16.lesson07.task01;

/* Часы
1. Разберись, что делает программа.
2. Реализуйте логику метода printTikTak:
2.1. Через первые полсекунды должна выводиться в консоль фраза: Tik.
2.2. Через вторые полсекунды должна выводиться в консоль фраза: Tak.
*/

public class Solution {

    public static volatile boolean isStopped = false;

    public static void main(String[] args) throws InterruptedException {
        Clock clock = new Clock();
        Thread.sleep(2000);
        isStopped = true;
        System.out.println("Clock has to be stopped");
        Thread.sleep(1000);
        System.out.println("Double-check");
    }

    public static class Clock extends Thread {

        public Clock() {
            setPriority(MAX_PRIORITY);
            start();
        }

        public void run() {
            try {
                while (!isStopped) {
                    printTikTak();
                }
            } catch (InterruptedException e) {
                System.out.println(e);
            }
        }

        private void printTikTak() throws InterruptedException {
            Thread.sleep(500);
            System.out.println("Tik");
            Thread.sleep(500);
            System.out.println("Tak");
        }
    }
}










package com.javarush.test.level16.lesson07.task02;

/* Stopwatch (Секундомер)
1. Разберись, что делает программа.
2. Реализуй логику метода doSeveralSteps так, чтобы учитывалась скорость бегуна.
2.1. Метод getSpeed() в классе Runner показывает, сколько шагов в секунду делает бегун.
Нужно, чтобы бегун действительно делал заданное количество шагов в секунду.
Если Иванов делает 4 шага в секунду, то за 2 секунды он сделает 8 шагов.
Если Петров делает 2 шага в секунду, то за 2 секунды он сделает 4 шага.
2.2. Метод sleep в классе Thread принимает параметр типа long.
*/

public class Solution {
    public static volatile boolean isStopped = false;

    public static void main(String[] args) throws InterruptedException {
        Runner ivanov = new Runner("Ivanov", 4);
        Runner petrov = new Runner("Petrov", 2);
        //на старт!
        //внимание!
        //марш!
        ivanov.start();
        petrov.start();
        Thread.sleep(2000);
        isStopped = true;
        Thread.sleep(1000);
    }

    public static class Stopwatch extends Thread {
        private Runner owner;
        private int stepNumber;

        public Stopwatch(Runner runner) {
            this.owner = runner;
        }

        public void run() {
            try {
                while (!isStopped) {
                    doSeveralSteps();
                }
            } catch (InterruptedException e) {
            }
        }

        private void doSeveralSteps() throws InterruptedException {
            stepNumber++;

            Thread.sleep((long) (1000 / owner.getSpeed()));


            System.out.println(owner.getName() + " делает шаг №" + stepNumber + "!");
        }
    }

    public static class Runner {
        private String name;
        private double speed;
        Stopwatch stopwatch;

        public Runner(String name, double speed) {
            this.name = name;
            this.speed = speed;
            this.stopwatch = new Stopwatch(this);
        }

        public String getName() {
            return name;
        }

        public double getSpeed() {
            return speed;
        }

        public void start() {
            stopwatch.start();
        }
    }
}
--------------------------------------


ЕЩЕ ВАРИАНТ, С ПРОВЕРКОЙ НУЛЕВОЙ СКОРОСТИ


package com.javarush.test.level16.lesson07.task02;

/* Stopwatch (Секундомер)
1. Разберись, что делает программа.
2. Реализуй логику метода doSeveralSteps так, чтобы учитывалась скорость бегуна.
2.1. Метод getSpeed() в классе Runner показывает, сколько шагов в секунду делает бегун.
Нужно, чтобы бегун действительно делал заданное количество шагов в секунду.
Если Иванов делает 4 шага в секунду, то за 2 секунды он сделает 8 шагов.
Если Петров делает 2 шага в секунду, то за 2 секунды он сделает 4 шага.
2.2. Метод sleep в классе Thread принимает параметр типа long.
*/

public class Solution {
    public static volatile boolean isStopped = false;

    public static void main(String[] args) throws InterruptedException {
        Runner ivanov = new Runner("Ivanov", 4);
        Runner petrov = new Runner("Petrov", 2);
        //на старт!
        //внимание!
        //марш!
        ivanov.start();
        petrov.start();
        Thread.sleep(2000);
        isStopped = true;
        Thread.sleep(1000);
    }

    public static class Stopwatch extends Thread {
        private Runner owner;
        private int stepNumber;

        public Stopwatch(Runner runner) {
            this.owner = runner;
        }

        public void run() {
            try {
                while (!isStopped) {
                    doSeveralSteps();
                }
            } catch (InterruptedException e) {
            }
        }

        private void doSeveralSteps() throws InterruptedException {
            stepNumber++;

            Thread.sleep(1000 / ((long) owner.getSpeed() != 0 ? (long) owner.getSpeed() : 1));               !!!!!!!!


            System.out.println(owner.getName() + " делает шаг №" + stepNumber + "!");
        }
    }

    public static class Runner {
        private String name;
        private double speed;
        Stopwatch stopwatch;

        public Runner(String name, double speed) {
            this.name = name;
            this.speed = speed;
            this.stopwatch = new Stopwatch(this);
        }

        public String getName() {
            return name;
        }

        public double getSpeed() {
            return speed;
        }

        public void start() {
            stopwatch.start();
        }
    }
}










____________________________________________________________________________________________________________________________ЧАСЫ!!!!!!!!!
package com.javarush.test.level16.lesson07.task03;

/* Big Ben clock
1. Разберись, что делает программа.
2. Реализуй логику метода printTime так, чтобы каждую секунду выдавалось время начиная с установленного в конструкторе
Пример:
В г. Лондон сейчас 23:59:58!
В г. Лондон сейчас 23:59:59!
В г. Лондон сейчас полночь!
В г. Лондон сейчас 0:0:1!
*/

public class Solution {

    public static volatile boolean isStopped = false;

    public static void main(String[] args) throws InterruptedException {
        Clock clock = new Clock("Лондон", 23, 59, 57);
        Thread.sleep(4000);
        isStopped = true;
        Thread.sleep(1000);
    }

    public static class Clock extends Thread {
        private String cityName;
        private int hours;
        private int minutes;
        private int seconds;

        public Clock(String cityName, int hours, int minutes, int seconds) {
            this.cityName = cityName;
            this.hours = hours;
            this.minutes = minutes;
            this.seconds = seconds;
            start();
        }

        public void run() {
            try {
                while (!isStopped) {
                    printTime();
                }
            } catch (InterruptedException e) {

            }
        }

        private void printTime() throws InterruptedException {


            seconds++;
            Thread.sleep(1000);
            if (seconds == 60) {
                seconds = 0;
                minutes++;
            }
            if (minutes == 60) {
                minutes = 0;
                hours++;
            }
            if (hours == 24) {
                hours = 0;
            }


            if (hours == 0 && minutes == 0 && seconds == 0) {

                System.out.println(String.format("В г. %s сейчас полночь!", cityName));
            } else {

                System.out.println(String.format("В г. %s сейчас %d:%d:%d!", cityName, hours, minutes, seconds));
            }
        }
    }
}









package com.javarush.test.level16.lesson07.task04;

import java.util.ArrayList;
import java.util.List;

/* Обратный отсчет
1. Разберись, что делает программа.
2. Реализуй логику метода printCountdown так, чтобы каждые полсекунды выводился объект из
переменной list в обратном порядке - от переданного индекса до нуля.
Пример: Передан индекс 3
Пример вывода в консоль:
Строка 2
Строка 1
Строка 0
*/

public class Solution {
    public static volatile List<String> list = new ArrayList<String>(5);

    static {
        for (int i = 0; i < 5; i++) {
            list.add("Строка " + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new Countdown(3));
        t.start();
    }

    public static class Countdown implements Runnable {
        private int countFrom;

        public Countdown(int countFrom) {
            this.countFrom = countFrom;
        }

        public void run() {
            try {
                while (countFrom > 0) {
                    printCountdown();
                }
            } catch (InterruptedException e) {
            }
        }

        public void printCountdown() throws InterruptedException {

            for (countFrom = countFrom - 1; countFrom >= 0; countFrom--) {
                System.out.println(list.get(countFrom));
                Thread.sleep(500);

            }
        }
    }
}







____________________________________________________________________________СМОТРЕТЬ
package com.javarush.test.level16.lesson07.task05;

/* Аэропорт
1. Разберись, что делает программа.
2. Исправь метод takingOff(взлет) - сейчас он работает оооочень долго. Взлет должен занимать 100 миллисекунд.
3. Реализуй метод waiting по аналогии с методом takingOff. Время ожидания не должно превышать время взлета.
*/
public class Solution {
    public static volatile Runway RUNWAY = new Runway();   //1 взлетная полоса

    public static void main(String[] args) throws InterruptedException {
        Plane plane1 = new Plane("Самолет #1");
        Plane plane2 = new Plane("Самолет #2");
        Plane plane3 = new Plane("Самолет #3");
    }

    public static class Plane extends Thread {
        public Plane(String name) {
            super(name);
            start();
        }

        public void run() {
            boolean  isAlreadyTakenOff = false;
            while (!isAlreadyTakenOff) {
                if (RUNWAY.getTakingOffPlane() == null) {  
                    //если взлетная полоса свободна
                    
                    RUNWAY.setTakingOffPlane(this);
                    System.out.println(getName() + " взлетает");
                    takingOff();//взлетает
                    System.out.println(getName() + " уже в небе");
                    isAlreadyTakenOff = true;
                    RUNWAY.setTakingOffPlane(null);
                    
                } else if (!this.equals(RUNWAY.getTakingOffPlane())) {
                    //если взлетная полоса занята самолетом
                    
                    System.out.println(getName() + " ожидает");
                    waiting(); //ожидает
                }
            }
        }
    }

    private static void waiting() {
        try {
            Thread.sleep(99);
        } catch (InterruptedException e) {
        }
    }

    private static void takingOff() {
        //fix this method - исправь этот метод
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
    }

    public static class Runway { //взлетная полоса
        private Thread t;

        public Thread getTakingOffPlane() {
            return t;
        }

        public void setTakingOffPlane(Thread t) {
            synchronized (this) {
                this.t = t;
            }
        }
    }
}










class Clock implements Runnable
{
 public void run()
 {
  while (true)
  {
   Thread.sleep(1000);
   System.out.println("Tik");

  if (!ClockManager.isClockRun)
   return;
  }
 }
}	Класс Clock (часы) будет вечно писать в консоль раз в секунду слово «Tik»

Если переменная ClockManager.isClockRun равна false – метод run завершится.
class ClockManager
{
 public static boolean isClockRun = true;
public static void main(String[] args)
{
  Clock clock = new Clock();
  Thread clockThread = new Thread(clock);
  clockThread.start();

  Thread.sleep(10000);
  isClockRun = false;
}

}	Главная нить, запускает дочернюю нить – часы, которая должна работать вечно.

Ждет 10 секунд и подает часам сигнал на завершение.

Главная нить завершает свою работу.

Нить часов завершает свою работу.
- А если у нас несколько нитей, что тогда?

- Тогда лучше завести такую переменную для каждой нити. Удобнее всего будет добавить ее прямо в класс. Можно добавить туда переменную boolean isRun.
 Хотя лучше добавить переменную boolean isCancel, которая будет принимать значение true, если задание отменено.

 
 
 
 
 
 _____________________________________________________________________________________________НОРМАЛЬНЫЕ ПОСЕКУНДНЫЕ ЧАСЫ(МЕТРОНОМ)
Код	Описание
class Clock implements Runnable
{
 private boolean isCancel = false;

 public void cancel() 
 {
  this.isCancel = true;
 }

 public void run()
 {
  while (!isCancel)
  {
   Thread.sleep(1000);
   System.out.println("Tik");
  }
 }
}	Класс Clock (часы) будет писать в консоль раз в секунду слово «Тик», пока переменная isCancel равна false.

Когда переменная isCancel станет равной true, метод run завершится.
public static void main(String[] args)
{
 Clock clock = new Clock();
 Thread clockThread = new Thread(clock);
 clockThread.start();

 Thread.sleep(10000);
 clock.cancel();
}












___________________________________________________________________________________ВРЕМЯ ДО ВВОДА СТРОКИ

package com.javarush.test.level16.lesson10.task01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


/* Считаем секунды
1. Напиши реализацию метода run в нити Stopwatch (секундомер).
2. Stopwatch должен посчитать количество секунд, которое прошло от создания нити до ввода строки.
3. Выведи количество секунд в консоль.
*/

public class Solution {
    public static void main(String[] args) throws IOException {
        InputStreamReader in = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(in);
        //create and run thread
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.start();
        //read a string
        reader.readLine();
        stopwatch.interrupt();
        //close streams
        reader.close();
        in.close();
    }

    public static class Stopwatch extends Thread {
        private int seconds;

        public void run() {
            try {

                while(!currentThread().isInterrupted()){

                    Thread.sleep(1000);
                    seconds++;
                }

            } catch (InterruptedException e) {
                System.out.println(seconds);
            }
        }
    }
}











package com.javarush.test.level16.lesson10.task02;

/* Отсчет на гонках
1. Разберись, что делает программа.
2. Реализуй логику метода run так, чтобы каждую секунду через пробел
выдавался отсчет начиная с countSeconds до 1, а потом слово [Марш!] (см примеры).
3. Если нить работает 3.5 секунды или более, прерви ее методом interrupt и внутри нити выведи в консоль слово [Прервано!].
Пример для countSeconds=4 : [4 3 2 1 Прервано!]
4. Если нить работает менее 3.5 секунд, она должна завершиться сама.
Пример для countSeconds=3 : [3 2 1 Марш!]
PS: метод sleep выбрасывает InterruptedException.
*/

public class Solution {
    public static volatile int countSeconds = 3;

    public static void main(String[] args) throws InterruptedException {
        RacingClock clock = new RacingClock();
        Thread.sleep(3500);
        clock.interrupt();
    }

    public static class RacingClock extends Thread {
        public RacingClock() {
            start();
        }

        public void run() {

            Thread current = Thread.currentThread();

            while (!current.isInterrupted()) {

                try {
                    while (countSeconds > 0) {
                        System.out.print(countSeconds + " ");
                        Thread.sleep(1000);
                        countSeconds--;
                    }

                } catch (InterruptedException e) {
                    System.out.print("Прервано!");
                    break;
                }
                    if(countSeconds == 0){
                        System.out.print("Марш!");
                        break;
                    }
                }
            }
        }
    }
	
	
	
	
	
	
	
	
	
	
	
package com.javarush.test.level16.lesson10.task03;

/* Снова interrupt
Создай нить TestThread.
В методе main создай экземпляр нити, запусти, а потом прерви ее используя метод interrupt().
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        TestThread testThread = new TestThread();
        testThread.start();
        Thread.sleep(1000);
        testThread.interrupt();
    }

    //Add your code below - добавь код ниже
    public static class TestThread extends Thread{

        public TestThread(){
        }

        @Override
        public void run() {

        }
    }
}











package com.javarush.test.level16.lesson10.task04;

/* А без interrupt слабо?
Разберись, как работает программа.
Сделай так, чтобы в методе ourInterruptMethod можно было сделать так, чтобы нить TestThread завершилась сама.
Нельзя использовать метод interrupt.
*/

public class Solution {

    public static boolean b = true;

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new TestThread());
        t.start();
        Thread.sleep(3000);
        ourInterruptMethod();
    }

    public static void ourInterruptMethod(){

        b = false;
    }

    public static class TestThread implements Runnable {


        public void run() {

            while (b) {
                try {
                    System.out.println("he-he");
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                }
            }
        }
    }
}







package com.javarush.test.level16.lesson10.task05;

import java.util.ArrayList;
import java.util.List;

/* Один для всех, все - для одного
1. Разберись, как работает программа.
1.1. Обрати внимание, что объект Water - один для всех нитей.

2. Реализуй метод ourInterruptMethod, чтобы он прерывал все нити из threads.
3. В методе run исправь значения переменных:
3.1. isCurrentThreadInterrupted - должна равняться значению метода isInterrupted у текущей нити.
3.2. threadName - должна равняться значению метода getName (реализовано в классе Thread) у текущей нити.
*/

public class Solution {
    public static byte countThreads = 3;
    static List<Thread> threads = new ArrayList<Thread>(countThreads);

    public static void main(String[] args) throws InterruptedException {
        initThreadsAndStart();
        Thread.sleep(3000);
        ourInterruptMethod();
    }

    public static void ourInterruptMethod() {
        for (int i1 = 0, threadsSize = threads.size(); i1 < threadsSize; i1++) {
            Thread i = threads.get(i1);
            i.interrupt();
        }
    }

    private static void initThreadsAndStart() {
        Water water = new Water("water");
        for (int i = 0; i < countThreads; i++) {
            threads.add(new Thread(water, "#" + i));
        }

        for (int i = 0; i < countThreads; i++) {
            threads.get(i).start();
        }
    }

    public static class Water implements Runnable {
        private String commonResource;

        public Water(String commonResource) {
            this.commonResource = commonResource;
        }

        public void run() {
            //fix 2 variables - исправь 2 переменных
            Thread current = Thread.currentThread();
            boolean isCurrentThreadInterrupted = current.isInterrupted();
            String threadName = current.getName();

            try {
                while (!isCurrentThreadInterrupted) {
                    System.out.println("Объект " + commonResource + ", нить " + threadName);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
            }
        }
    }
}











package com.javarush.test.level16.lesson13.home01;

/* Thread.currentThread - всегда возвращает текущую нить
1. В методе printMsg присвой переменной t текущую нить.
2. В методе printMsg после всех действий поставь задержку в 1 миллисекунду.
*/

public class Solution {
    static int count = 5;

    public static void main(String[] args) throws InterruptedException {
        NameOfDefferentThreads tt = new NameOfDefferentThreads();
        tt.start();
        for (int i = 0; i < count; i++) {
            tt.printMsg();
        }
    }

    public static class NameOfDefferentThreads extends Thread {
        public void run() {
            for (int i = 0; i < count; i++) {
                try {
                    printMsg();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        public void printMsg() throws InterruptedException {
            Thread t = currentThread();
            String name = t.getName();
            System.out.println("name=" + name);
            Thread.sleep(1);
        }
    }
}










package com.javarush.test.level16.lesson13.home02;

/* Последовательные выполнения нитей
1. В методе run после всех действий поставь задержку в 10 миллисекунд. Выведи "Нить прервана", если нить будет прервана.
2. Сделай так, чтобы все нити выполнялись последовательно: сначала для нити №1 отсчет с COUNT до 1, потом для нити №2 с COUNT до 1 и т.д.
Пример:
#1: 4
#1: 3
...
#1: 1
#2: 4
...
*/

public class Solution {
    public volatile static int COUNT = 4;

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < COUNT; i++) {
            Thread t = new SleepingThread();
            t.join();

        }
    }

    public static class SleepingThread extends Thread {
        private volatile int countDownIndex = COUNT;
        private static volatile int threadCount = 0;

        public SleepingThread() {
            super(String.valueOf(++threadCount));
            start();
        }

        public void run() {
            while (true) {
                System.out.println(this);
                if (--countDownIndex == 0) return;
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    System.out.println("Нить прервана");
                }

            }
        }

        public String toString() {
            return "#" + getName() + ": " + countDownIndex;
        }
    }
}








package com.javarush.test.level16.lesson13.home03;

/* Рекурсивное создание нитей
1. Измени класс GenerateThread так, чтобы он стал нитью.
2. Создай конструктор GenerateThread, который должен:
2.1. Вызвать конструктор суперкласса с параметром String - номером созданной нити. Используй countCreatedThreads.
2.2. Запустить текущую нить.
2.3. Номер первой нити должен начинается с 1.
3. Переопредели метод toString, для этого внутри GenerateThread нажми Alt+Insert -> Override Methods. Начни печатать toString.
3.1. Метод toString должен возвращать № текущей нити и слово " created". Используй getName(). Пример: [8 created]
4. Пока количество созданных нитей меньше Solution.count метод run должен:
4.1. создать новую нить типа GenerateThread.
4.2. Вывести в консоль созданную в пункте 4.1. нить.
5. В итоге должно быть выведено в консоль 15 строк.
*/

public class Solution {
    static int count = 15;
    static volatile int countCreatedThreads;

    public static void main(String[] args) {
        System.out.println(new GenerateThread());


    }

    public static class GenerateThread extends Thread {

        public GenerateThread(){
            super(String.valueOf(++countCreatedThreads));
            this.start();


        }

        @Override
        public String toString() {
            return (this.getName() + " created");
        }

        @Override
        public void run() {
            while(countCreatedThreads < count){
                System.out.println(new GenerateThread());
            }
        }


    }
}













package com.javarush.test.level16.lesson13.home04;

/* Последовательные выполнения нитей
1. Разберись, что делает программа.
2. Сделай так, чтоб программа сначала выводила результат нити, а когда нить завершится - продолжила метод main.
3. Пример выходных данных:
inside MyThread 0
inside MyThread 1
...
inside MyThread 9
inside main 0
inside main 1
...
inside main 9
*/

public class Solution {

    public static MyThread t = new MyThread();
    static String message = "inside main ";

    public static void main(String a[]) throws Exception {
        t.start();
        t.join();
        for (int i = 0; i < 10; i++) {
            System.out.println(message + i);
            sleep();

        }
    }

    static class MyThread extends Thread {
        String message = "inside MyThread ";

        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println(message + i);

            }
        }
    }

    public static void sleep() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }
    }
}






package com.javarush.test.level16.lesson13.home05;

/* Взаимная блокировка
1. Разберись, как работает программа.
2. Не меняя классы T1 и T2 сделай так, чтобы они завершились, не обязательно успешно.
3. метод sleep не использовать.
*/

public class Solution {
    static Thread t1 = new T1();
    static Thread t2 = new T2();

    public static void main(String[] args) throws InterruptedException {
        t1.start();
        t2.start();
        t2.interrupt();


    }

    public static class T1 extends Thread {
        @Override
        public void run() {
            try {
                t2.join();
                System.out.println("T1 finished");
            } catch (InterruptedException e) {
                System.out.println("T1 was interrupted");
            }
        }
    }

    public static class T2 extends Thread {
        @Override
        public void run() {
            try {
                t1.join();
                System.out.println("T2 finished");
            } catch (InterruptedException e) {
                System.out.println("T2 was interrupted");
            }
        }
    }
}











package com.javarush.test.level16.lesson13.home06;

/* Создание по образцу
Разберись, как работает программа.
По образу и подобию CountDownRunnable создай нить CountUpRunnable, которая выводит значения в нормальном порядке - от 1 до number
*/

public class Solution {
    public static int number = 5;

    public static void main(String[] args) {
        new CountDownRunnable("было");
        new CountUpRunnable("стало");
    }

    //Add your code below - добавьте код ниже
    public static class CountUpRunnable implements Runnable {

        private int countIndexUp = 0;
        private Thread t;

        public CountUpRunnable(String name) {
            t = new Thread(this, name);
            t.start();
        }

        public void run() {
            try {
                while (countIndexUp < number) {

                    countIndexUp += 1;
                    System.out.println(toString());
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
            }
        }

        public String toString() {
            return t.getName() + ": " + countIndexUp;
        }
    }

    public static class CountDownRunnable implements Runnable {
        private int countIndexDown = Solution.number;
        private Thread t;

        public CountDownRunnable(String name) {
            t = new Thread(this, name);
            t.start();
        }

        public void run() {
            try {
                while (true) {
                    System.out.println(toString());
                    countIndexDown -= 1;
                    if (countIndexDown == 0) return;
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
            }
        }

        public String toString() {
            return t.getName() + ": " + countIndexDown;
        }
    }
}









package com.javarush.test.level16.lesson13.home07;

import java.util.ArrayList;
import java.util.List;

/* Поиграем?
Три человека играют в игру. Каждый игрок(Gamer) характеризуется двумя параметрами: фамилией(name) и количеством действий в секунду (rating).
Нужно вывести в консоль ход игры и определить победителя и проигравших.
Итак...
1. Разберись, что делает программа.
1.1. List<String> steps хранит последовательность действий, которое каждый игрок выполняет от 0 до последнего.
1.2. isWinnerFound показывает, найден победитель или нет.
1.3. метод sleep выбрасывает InterruptedException и принимает параметр типа long.
1.4. Игроки играют независимо друг от друга.

2. Реализуйте логику метода run так, чтобы для каждого игрока:
2.1. За 1 секунду через равные интервалы времени выводились в консоль действия, описанные в steps. Количество выведенных действий должно равняться rating.
2.2. Любой текст должен начинаться с фамилии игрока (метод getName()), потом следовать двоеточие, а затем сам текст. Пример: [Ivanov:Начало игры].
2.3. Когда игрок выполнит все действия из steps, то он считается победителем. Выведите [getName() + ":победитель!"].
2.4. Когда найден победитель, то игра останавливается, и остальные игроки считаются побежденными. Выведите для них [getName() + ":проиграл"].
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        OnlineGame onlineGame = new OnlineGame();
        onlineGame.start();
    }

    public static class OnlineGame extends Thread {

        public static volatile boolean isWinnerFound = false;

        public static List<String> steps = new ArrayList<String>();

        static {
            steps.add("Начало игры");
            steps.add("Сбор ресурсов");
            steps.add("Рост экономики");
            steps.add("Убийство врагов");
        }

        protected Gamer gamer1 = new Gamer("Ivanov", 3);
        protected Gamer gamer2 = new Gamer("Petrov", 1);
        protected Gamer gamer3 = new Gamer("Sidorov", 5);

        public void run() {
            gamer1.start();
            gamer2.start();
            gamer3.start();

            while (!isWinnerFound) {
            }
            gamer1.interrupt();
            gamer2.interrupt();
            gamer3.interrupt();
        }
    }

    public static class Gamer extends Thread {

        private int rating;

        public Gamer(String name, int rating) {
            super(name);
            this.rating = rating;
        }

        @Override
        public void run() {

            try {
                for(int i = 0; i < OnlineGame.steps.size(); i++)
                {
                    System.out.println(getName()+":"+OnlineGame.steps.get(i));

                    sleep(1000/rating);

                    rating++;
                }
                OnlineGame.isWinnerFound = true;

                System.out.println(getName()+":победитель!");

            } catch (InterruptedException e) {

                System.out.println(getName() + ":проиграл");
            }
        }
    }
}








package com.javarush.test.level16.lesson13.home08;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Кто первый встал - того и тапки
1. Разберись, что делает программа.
1.1. Каждая нить должна читать с консоли слова. Используйте готовый static BufferedReader reader.
1.2. Используй static byte countReadStrings, чтобы посчитать, сколько слов уже считано с консоли всеми нитями.

2. Реализуйте логику метода run:
2.1. Пока нить не прервана (!isInterrupted) читайте с консоли слова и добавляйте их в поле List<String> result.
2.2. Используй countReadStrings для подсчета уже считанных с консоли слов.
*/

public class Solution {
    public static volatile byte countReadStrings;

    public static volatile BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws IOException {
        //read count of strings
        int count = Integer.parseInt(reader.readLine());

        //init threads
        ReaderThread consolReader1 = new ReaderThread();
        ReaderThread consolReader2 = new ReaderThread();
        ReaderThread consolReader3 = new ReaderThread();

        while (count > countReadStrings) {
        }

        consolReader1.interrupt();
        consolReader2.interrupt();
        consolReader3.interrupt();
        System.out.println("#1:" + consolReader1);
        System.out.println("#2:" + consolReader2);
        System.out.println("#3:" + consolReader3);

        reader.close();
    }

    public static class ReaderThread extends Thread {
        private List<String> result = new ArrayList<String>();

        public ReaderThread() {
            start();
        }

        public void run() {


            try {
                while (!isInterrupted()) {
                    result.add(reader.readLine());
                    countReadStrings ++;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


        @Override
        public String toString() {
            String s = result.toString();
            return s.substring(1, s.length() - 1);
        }
    }
}










package com.javarush.test.level16.lesson13.home09;

/* Только по-очереди!
1. В классе Solution создать нить public static Read3Strings унаследовавшись от Thread.
2. В методе run реализовать чтение с консоли трех строк.
3. Три подряд введенных строки должны считываться в одной нити и объединяться в одну строку через пробел.
4. В методе main вывести результат для каждой нити.
5. Используйте join

Пример:
Входные данные
a
b
c
d
e
f
Выходные данные:
a b c
d e f
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Solution {
    public static volatile BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

    public static void main(String[] args) throws InterruptedException {
        Read3Strings t1 = new Read3Strings();
        Read3Strings t2 = new Read3Strings();
        t1.start();
        t1.join();
        t2.start();
        t2.join();
        System.out.println(t1.s);
        System.out.println(t2.s);
    }

    private static class Read3Strings extends Thread {


        String s = "";

        @Override
        public void run() {



                try {
                    s = reader.readLine() + " " + reader.readLine() + " " + reader.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }

	
	
	
	
	
	

	
	
	Классы StringBuffer и StringBuilder
Класс String представляет собой неизменяемые последовательности символов постоянной длины и частое использование объектов класса занимают много места в памяти. 
Класс StringBuffer представляет расширяемые и доступные для изменений последовательности символов, позволяя вставлять символы и подстроки в существующую строку 
и в любом месте. Данный класс гораздо экономичнее в плане потребления памяти и настоятельно рекомендуется к использованию.


Существует четыре конструктора класса:

StringBuffer() - резервирует место под 16 символов без перераспределения памяти
StringBuffer(int capacity) - явно устанавливает размер буфера
StringBuffer(String string) - устанавливает начальное содержимое и резервирует 16 символов без повторого резервирования
StringBuffer(CharSequence cs) - создаёт объект, содержащий последовательность символов и резервирует место ещё под 16 символов
Методы класса StringBuffer
length()
Метод позволяет получить текущую длину объекта.


StringBuffer sb = new StringBuffer("Котэ");
tvInfo.setText("Длина: " + sb.length());
capacity()
Метод позволяет получить текущий объём выделенной памяти.


StringBuffer sb = new StringBuffer("Котэ");
tvInfo.setText("Объём памяти: " + sb.capacity()); // вернёт 20
Обратите внимание, что хотя слово состоит из четырёх символов, в памяти выделено запасное пространство для дополнительных 16 символов. Для такой 
простейшей операции выигрыша нет, но в сложных примерах, когда приходится на лету соединять множество строк, производительность резко возрастает.

ensureCapacity()
Можно предварительно выделить место для определённого количества символов, если собираетесь добавлять большое количество маленьких строк.

setLength(int length)
Устанавливает длину строки. Значение должно быть неотрицательным.

charAt(int index) и setCharAt(int index, char ch)
Можно извлечь значение отдельного символа с помощью метода charAt() и установить новое значение символа с помощью метода setCharAt(), указав индекс
 символа и его значение.


StringBuffer sb = new StringBuffer("Кит");
sb.setCharAt(1, 'o');
tvInfo.setText(sb.toString());
getChars()
Позволяет скопировать подстроку из объекта класса StringBuffer в массив. Необходимо позаботиться, чтобы массив был достаточного размера для приёма 
нужного количества символов указанной подстроки.

append()
Метод соединяет представление любого другого типа данных. Есть несколько перегруженных версий.

StringBuffer append(String string)
StringBuffer append(int number)
StringBuffer append(Object object)
Строковое представление каждого параметра за кулисами получают через метод String.valueOf() и затем полученные строки склеиваются в итоговую строку.


String str1 = "У кота ";
String str2 = " лапы";
int paws = 4;
StringBuffer sb = new StringBuffer(20);
sb.append(str1).append(paws).append(str2);
tvInfo.setText(sb.toString());
insert()
Вставляет одну строку в другую. Также можно вставлять значения других типов, которые будут автоматически преобразованы в строки. Вам надо указать 
индекс позиции, куда будет вставляться строка.


StringBuffer sb = new StringBuffer("Я Котов");
sb.insert(2, "Люблю ");
tvInfo.setText(sb.toString());
reverse()
Позволяет изменить порядок символов на обратный.


StringBuffer sb = new StringBuffer("МОКНЕТ ОКСАНА С КОТЕНКОМ");
sb.reverse();
tvInfo.setText(sb.toString());
У меня получилось практически то же самое, может метод глючит?

delete() и deleteCharAt()
Метод delete() удаляет последовательность символов, вам надо задать индекс первого символа, который надо удалить, а также индекс символа, следующего
 за последним из удаляемых. Метод deleteCharAt() удаляет один символ из указанной позиции.

replace()
Позволяет заменить один набор символов на другой. Нужно указать начальный и конечный индекс и строку замены.

substring()
Позволяет получить часть содержимого. Есть две формы метода. В первом случае нужно указать индекс начала позиции, с которой нужно получить подстроку.
 Во втором варианте указывается начальный индекс и конечный индекс, если нужно получить текст из середины строки.

Есть и другие методы

StringBuilder
Класс StringBuilder идентичен классу StringBuffer и обладает большей производительностью. Однако он не синхронизирован, поэтому его не нужно использовать
 в тех случаях, когда к изменяемой строке обращаются несколько потоков.

Создадим новый объект.


StringBuilder builder = new StringBuilder();
Добавляем новый фрагмент в существующую строку:


builder.append(ch); // можно добавить один символ
builder.append(sometext); // а можно добавить готовую строку
String completedString = builder.toString(); // результирующая строка

















package com.javarush.test.level16.lesson13.home10;

import java.io.*;


/* Последовательный вывод файлов
1. Разберись, что делает программа.
2. В статическом блоке считай 2 имени файла firstFileName и secondFileName.
3. Внутри класса Solution создай нить public static ReadFileThread, которая реализует
интерфейс ReadFileInterface (Подумай, что больше подходит - Thread или Runnable).
3.1. Метод setFileName должен устанавливать имя файла, из которого будет читаться содержимое.
3.2. Метод getFileContent должен возвращать содержимое файла.
3.3. В методе run считай содержимое файла, закрой поток. Раздели пробелом строки файла.
4. Подумай, в каком месте нужно подождать окончания работы нити, чтобы обеспечить последовательный вывод файлов.
4.1. Для этого добавь вызов соответствующего метода.
Ожидаемый вывод:
[все тело первого файла]
[все тело второго файла]
*/

public class Solution {

    public static String firstFileName;
    public static String secondFileName;

    static {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        try {
            firstFileName = reader.readLine();
            secondFileName = reader.readLine();
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static class ReadFileThread extends Thread implements ReadFileInterface {
        String name;
        String vivod = "";
        String fin;

        @Override
        public void setFileName(String fullFileName) {
            this.name = fullFileName;
        }

        @Override
        public String getFileContent() {

            return vivod;
        }

        @Override
        public void run() {
            try {

                BufferedReader myfile = new BufferedReader(new FileReader(name));
                while ((fin = myfile.readLine()) != null) {
                    vivod += fin + " ";

                }
                myfile.close();

            } catch (IOException e) {
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        systemOutPrintln(firstFileName);
        systemOutPrintln(secondFileName);

    }

    public static void systemOutPrintln(String fileName) throws InterruptedException {

        ReadFileInterface f = new ReadFileThread();
        f.setFileName(fileName);
        f.start();
        f.join();
        System.out.println(f.getFileContent());

    }

    public static interface ReadFileInterface {
        void setFileName(String fullFileName);

        String getFileContent();

        void join() throws InterruptedException;

        void start();
    }

	
	
	
	
	
	
	
	
	

	
package com.javarush.test.level16.lesson13.bonus02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/* Клубок
1. Создай 5 различных своих нитей c отличным от Thread типом:
1.1. нить 1 должна бесконечно выполняться;
1.2. нить 2 должна выводить "InterruptedException" при возникновении исключения InterruptedException;
1.3. нить 3 должна каждые полсекунды выводить "Ура";
1.4. нить 4 должна реализовать интерфейс Message, при вызове метода showWarning нить должна останавливаться;
1.5. нить 5 должна читать с консоли цифры пока не введено слово "N", а потом вывести в консоль сумму введенных цифр.
2. В статическом блоке добавь свои нити в List<Thread> threads в перечисленном порядке.
3. Нити не должны стартовать автоматически.
Подсказка: Нить 4 можно проверить методом isAlive()
*/

public class Solution {


    public static List<Thread> threads = new ArrayList<Thread>(5);

    static{
        threads.add(new Eternity());
        threads.add(new Interrupted());
        threads.add(new Yra());
        threads.add(new Messag());
        threads.add(new Read());


    }

    public static void main(String[] args) {



    }

    public static class Eternity extends Thread implements Runnable {


        @Override
        public void run() {

            while (!isInterrupted()){

            }

        }
    }

    public static class Interrupted extends Thread implements Runnable {


        @Override
        public void run() {


            try{
                while(true){
                    sleep(500);
                }
            }
            catch(InterruptedException e){
                System.out.println("InterruptedException");
            }

        }
    }

    public static class Yra extends Thread implements Runnable {

        @Override
        public void run() {


            while (true)
            {
                try {
                    System.out.println("Ура");
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                }

            }
        }
    }

    public static class Messag extends Thread implements Runnable, Message {


        @Override
        public void showWarning() {

            interrupt();
            try {
                join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void run() {

            while(!isInterrupted()){

            }

        }
    }

    public static class Read extends Thread implements Runnable {

        @Override
        public void run() {

            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
                String buffer = reader.readLine();
                int sum = 0;
                while (!buffer.equals("N"))
                {
                    sum=sum+Integer.parseInt(buffer);
                    buffer=reader.readLine();
                }
                System.out.println(sum);
            }
            catch (IOException e) {
            }

        }
    }
}
----------------------
package com.javarush.test.level16.lesson13.bonus02;

public interface Message {
    void showWarning();
}















package com.javarush.test.level16.lesson13.bonus01;

import com.javarush.test.level16.lesson13.bonus01.ImageReaderFactory;
import com.javarush.test.level16.lesson13.bonus01.common.ImageReader;
import com.javarush.test.level16.lesson13.bonus01.common.ImageTypes;

/* Factory method pattern
1. Внимательно посмотри, какие классы у тебя есть.
2. В отдельных файлах в пакете common создай классы JpgReader, PngReader, BmpReader, которые реализуют интерфейс ImageReader.
3. В отдельном файле в пакете bonus01 создай класс ImageReaderFactory с одним методом.
3.1. Подумай, как он должен называться.
3.2. Подумай, какие модификаторы должны быть у этого метода.
4. Этот метод должен:
4.1. для каждого значения из ImageTypes возвращать соответствующий Reader, например, для ImageTypes.JPG - JpgReader;
4.2. если передан неправильный параметр, то выбросить исключение IllegalArgumentException("Неизвестный тип картинки").
*/

public class Solution {
    public static void main(String[] args) {
        ImageReader reader = ImageReaderFactory.getReader(ImageTypes.JPG);
    }
}
------------------------------
package com.javarush.test.level16.lesson13.bonus01;

import com.javarush.test.level16.lesson13.bonus01.common.*;


/**
 * Created by Кира on 26.04.2016.
 */
public class ImageReaderFactory {


    public static ImageReader getReader(ImageTypes type) {

        if (type == ImageTypes.JPG) {
            return new JpgReader();
        } else if (type == ImageTypes.PNG) {
            return new PngReader();
        } else if (type == ImageTypes.BMP){
            return new BmpReader();
        } else {
            throw new IllegalArgumentException("Неизвестный тип картинки");
        }

    }
}
--------------------------------
package com.javarush.test.level16.lesson13.bonus01.common;

/**
 * Created by Кира on 26.04.2016.
 */
public class BmpReader implements ImageReader {

    public BmpReader(){

    }
}
--------------------------------
package com.javarush.test.level16.lesson13.bonus01.common;

/**
 * Created by Кира on 26.04.2016.
 */
public class PngReader implements ImageReader {

    public PngReader(){

    }
}
---------------------------------
package com.javarush.test.level16.lesson13.bonus01.common;

/**
 * Created by Кира on 26.04.2016.
 */
public class JpgReader implements ImageReader {

    public JpgReader(){

    }
}
---------------------------------
package com.javarush.test.level16.lesson13.bonus01.common;

public enum ImageTypes implements ImageReader {
    BMP,
    JPG,
    PNG;
}
----------------------------------
package com.javarush.test.level16.lesson13.bonus01.common;

public interface ImageReader {
}














package com.javarush.test.level16.lesson13.bonus03;

/* Отдебажим все на свете
Разобраться, что делает програма.
Почитать про UncaughtExceptionHandler - это важно.
Еще раз внимательно посмотреть программу.
Разобраться - продебажить - почему наш OurUncaughtExceptionHandler не срабатывает.
Исправить ошибку, т.е. все должно работать. :)

Ожидаемый результат в произвольном порядке:
Нить 1: My exception message
Нить 2: My exception message
*/

public class Solution {
    public static Thread.UncaughtExceptionHandler handler = new OurUncaughtExceptionHandler();

    public static void main(String[] args) {
        TestedThread commonThread = new TestedThread(handler);

        Thread threadA = new Thread(commonThread, "Нить 1");
        Thread threadB = new Thread(commonThread, "Нить 2");

        threadA.start();
        threadB.start();

        threadA.setUncaughtExceptionHandler(handler);
        threadB.setUncaughtExceptionHandler(handler);
        threadA.interrupt();
        threadB.interrupt();
    }

    public static class TestedThread extends Thread {
        public TestedThread(UncaughtExceptionHandler handler) {
            setUncaughtExceptionHandler(handler);
            start();
        }

        public void run() {
            try {
                sleep(3000);
            } catch (InterruptedException x) {
                throw new RuntimeException("My exception message");
            }
        }
    }

    public static class OurUncaughtExceptionHandler implements TestedThread.UncaughtExceptionHandler {
        @Override
        public void uncaughtException(Thread t, Throwable e) {

            System.out.println(t.getName() + ": " + e.getMessage());
        }
    }
}




МЕТОД setUncaughtExceptionHandler()
The java.lang.Thread.setUncaughtExceptionHandler() method set the handler invoked when this thread abruptly terminates due to an uncaught exception.
import java.lang.*;

public class ThreadDemo {

   public static void main(String[] args) {

   Thread t = new Thread(new adminThread());
   t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {

   public void uncaughtException(Thread t, Throwable e) {
   System.out.println(t + " throws exception: " + e);
   }
   });
   // this will call run() function
   t.start();
   }
}

class adminThread implements Runnable {

   public void run() {
   throw new RuntimeException();
   }
} 








package com.javarush.test.level17.lesson02.task01;

import java.util.ArrayList;
import java.util.List;

/* Заметки
1. Класс Note будет использоваться нитями.
2. Создай public static нить NoteThread (Runnable не является нитью),
которая в методе run 1000 раз (index = 0-999) сделает следующие действия:
2.1. используя метод addNote добавит заметку с именем [getName() + "-Note" + index], например, при index=4
"Thread-0-Note4"
2.2. используя метод removeNote удалит заметку
2.3. в качестве первого параметра в removeNote передай имя нити - метод getName()
*/

public class Solution {
    public static void main(String[] args) {

        NoteThread thread1 = new NoteThread();
        NoteThread thread2 = new NoteThread();
        thread1.start();
        thread2.start();

    }

    public static class Note {

        public static final List<String> notes = new ArrayList<String>();

        public static void addNote(String note) {
            notes.add(0, note);
        }

        public static void removeNote(String threadName) {
            String note = notes.remove(0);
            if (note == null) {
                System.out.println("Другая нить удалила нашу заметку");
            } else if (!note.startsWith(threadName)) {
                System.out.println("Нить [" + threadName + "] удалила чужую заметку [" + note + "]");
            }
        }
    }

    public static class NoteThread extends Thread{

        public NoteThread() {

        }

        public void run(){


            for(int index = 0; index < 1000; index++){

                try
                {
                    Note.addNote(getName() + "-Note" + index);
                }
                catch (IndexOutOfBoundsException e)
                {
                }
            }
            for (int index = 0; index < 1000; index++)
            {
                try
                {
                    Note.removeNote(getName());
                }
                catch (IndexOutOfBoundsException e) {
                }
            }

        }
    }
}








package com.javarush.test.level17.lesson02.task02;

import java.util.ArrayList;
import java.util.List;

/* Вместе быстрее? Ща проверим :)
1. Разберись, что и как работает
2. Создай public static нить SortThread, которая в методе run отсортирует статический массив testArray используя метод sort
*/

public class Solution {
    public static int countThreads = 10;
    public static int[] testArray = new int[1000];

    static {
        for (int i = 0; i < Solution.testArray.length; i++) {
            testArray[i] = i;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        initThreads();
    }

    public static void initThreads() throws InterruptedException {
        List<Thread> threads = new ArrayList<Thread>(countThreads);
        for (int i = 0; i < countThreads; i++)
            threads.add(new SortThread());
        for (Thread thread : threads) thread.start();
        for (Thread thread : threads) thread.join();
    }

    public static void sort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = i + 1; j < array.length; j++) {
                if (array[i] < array[j]) {
                    int k = array[i];
                    array[i] = array[j];
                    array[j] = k;
                }
            }
        }
    }

    public static class SortThread extends Thread {

        public void run(){

            sort(testArray);

        }

    }
}











package com.javarush.test.level17.lesson04.task01;

import java.util.ArrayList;
import java.util.List;

/* Синхронизированные заметки
1. Класс Note будет использоваться нитями. Поэтому сделай так, чтобы обращения к листу notes блокировали мютекс notes, не this
2. Все System.out.println не должны быть заблокированы (синхронизированы), т.е. не должны находиться в блоке synchronized
*/

public class Solution {


    public static class Note extends Thread{


        public final List<String> notes = new ArrayList<String>();

        public void addNote(int index, String note) {
            System.out.println("Сейчас будет добавлена заметка [" + note + "] На позицию " + index);
            synchronized (notes) {
                notes.add(index, note);
            }
            System.out.println("Уже добавлена заметка [" + note + "]");
        }

        public void removeNote(int index) {
            System.out.println("Сейчас будет удалена заметка с позиции " + index);
            synchronized (notes) {
                String note = notes.remove(index);

                System.out.println("Уже удалена заметка [" + note + "] с позиции " + index);
            }
            }
    }

}












package com.javarush.test.level17.lesson04.task02;

import java.util.ArrayList;
import java.util.List;

/* Синхронизированные заметки 2
Класс Note будет использоваться нитями. Поэтому сделай так, чтобы вcе методы были синхронизированы
*/

public class Solution {
    public static class Note extends Thread {

        public final List<String> notes = new ArrayList<String>();


        public synchronized void addNote(int index, String note) {
                System.out.println("Сейчас будет добавлена заметка [" + note + "] На позицию " + index);
                notes.add(index, note);
                System.out.println("Уже добавлена заметка [" + note + "]");

        }

        public synchronized void removeNote(int index) {
                System.out.println("Сейчас будет удалена заметка с позиции " + index);
                String note = notes.remove(index);
                System.out.println("Уже удалена заметка [" + note + "] с позиции " + index);
        }
    }
}











package com.javarush.test.level17.lesson04.task03;

import java.util.ArrayList;
import java.util.List;

/* Сад-огород
1. Создайте метод public void addFruit(int index, String fruit) - который добавляет параметр fruit в лист fruits на позицию index
2. Создайте метод public void removeFruit(int index) - который удаляет из fruits элемент с индексом index
3. Создайте метод public void addVegetable(int index, String vegetable) - который добавляет параметр vegetable в лист vegetables на позицию index
4. Создайте метод public void removeVegetable(int index) - который удаляет из vegetables элемент с индексом index
5. Класс Garden будет использоваться нитями. Поэтому сделай так, чтобы все методы блокировали мютекс this
6. Реализуй это минимальным количеством кода
*/

public class Solution {
    public static class Garden extends Thread{

        public final List<String> fruits = new ArrayList<String>();
        public final List<String> vegetables = new ArrayList<String>();

        public synchronized void addFruit(int index, String fruit){

            fruits.add(index, fruit);

        }

        public synchronized void removeFruit(int index){

            fruits.remove(index);

        }

        public synchronized void addVegetable(int index, String vegetable){

            vegetables.add(index, vegetable);

        }

        public synchronized void removeVegetable(int index){

            vegetables.remove(index);

        }

    }
}













package com.javarush.test.level14.lesson08.home03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* User, Looser, Coder and Proger
1. Ввести [в цикле] с клавиатуры несколько строк (ключей).
Строки(ключи) могут быть такими: "user", "looser", "coder", "proger".
Ввод окончен, когда строка не совпадает ни с одной из выше указанных.

2. Для каждой введенной строки нужно:
2.1. Создать соответствующий объект [см Person.java], например, для строки "user" нужно создать объект класса User.
2.2. Передать этот объект в метод doWork.

3. Написать реализацию метода doWork, который:
3.1. Вызывает метод live() у переданного обекта, если этот объект (person) имеет тип User.
3.2. Вызывает метод doNothing(), если person имеет тип Looser.
3.3. Вызывает метод coding(), если person имеет тип Coder.
3.4. Вызывает метод enjoy(), если person имеет тип Proger.
*/

public class Solution
{
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        Person person = null;
        String key = null;

        while (true) {
            key = reader.readLine();
            if ("user".equals(key) || "looser".equals(key) || "coder".equals(key) || "proger".equals(key)) {

                if (key.equals("user")) {
                    person = new Person.User();
                    doWork(person);
                } else if (key.equals("looser")) {
                    person = new Person.Looser();
                    doWork(person);
                } else if (key.equals("coder")) {
                    person = new Person.Coder();
                    doWork(person);
                } else if (key.equals("proger")) {
                    person = new Person.Proger();
                    doWork(person);
                }
            } else {
                break;

            }
        }
    }


    public static void doWork(Person person)
    {
        if(person instanceof Person.User){
            ((Person.User) person).live();
        }
        if(person instanceof Person.Looser){
            ((Person.Looser) person).doNothing();
        }
        if(person instanceof Person.Coder){
            ((Person.Coder) person).coding();
        }
        if(person instanceof Person.Proger){
            ((Person.Proger) person).enjoy();
        }
    }
}
------------------------
package com.javarush.test.level14.lesson08.home03;

public interface Person
{
    public static class User implements Person
    {
        void live()
        {
            System.out.println("Usually I just live");
        }
    }

    public static class Looser implements Person
    {
        void doNothing()
        {
            System.out.println("Usually I do nothing");
        }
    }

    public static class Coder implements Person
    {
        void coding()
        {
            System.out.println("Usually I create code");
        }
    }

    public static class Proger implements Person
    {
        void enjoy()
        {
            System.out.println("Wonderful life!");
        }
    }

}





package com.javarush.test.level14.lesson08.home04;

/* Реализовать метод printMainInfo
1. Напиши реализацию метода printMainInfo, чтобы:
1.1. Если в метод передают объект типа Drawable, у этого объекта вызывался метод draw.
1.2. Если в метод передают объект типа Movable, у этого объекта вызывался метод move.
2. Метод main менять нельзя.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Object obj = new Circle();
        Movable movable = (Movable) obj;
        Drawable drawable = new Rectangle();

        printMainInfo(drawable);
        printMainInfo(movable);
    }

    public static void printMainInfo(Object object)
    {
        if(object instanceof Drawable){
            ((Drawable) object).draw();
        }
        if(object instanceof Movable){
            ((Movable) object).move();
        }

    }

    static interface Movable
    {

        void move();
    }

    static class Circle implements Movable
    {

        public void draw()
        {
            System.out.println("can be drawn");
        }

        public void move()
        {
            System.out.println("can be moved");
        }

    }

    static interface Drawable
    {
        void draw();
    }

    static class Rectangle implements Drawable
    {
        public void draw()
        {
            System.out.println("can be drawn");
        }

        public void move()
        {
            System.out.println("can be moved");
        }
    }
}









БОЛЬШАЯ
package com.javarush.test.level14.lesson08.home05;

/* Computer
1. Создай интерфейс CompItem.
2. Добавь в него метод String getName().
3. Создай классы Keyboard, Mouse, Monitor, которые реализуют интерфейс CompItem.
4. Метод getName() должен возвращать имя класса, например, для класса Keyboard будет "Keyboard".
5. Создай класс Computer.
6. В класс Computer добавь приватное поле типа Keyboard.
7. В класс Computer добавь приватное поле типа Mouse.
8. В класс Computer добавь приватное поле типа Monitor.
9. Создай конструктор в классе Computer используя комбинацию клавиш Alt+Insert внутри класса (команда Constructor).
10 Внутри конструктора инициализируйте все три поля (переменных) класса
11. Создай геттеры для полей класса Computer (в классе используй комбинацию клавиш Alt+Insert и выбери команду Getter).
12. Все созданные классы и интерфейс должны быть в отдельных файлах.
13. Класс Solution менять нельзя.
*/

public class Solution
{

    public static void main(String[] args)
    {
        Computer computer = new Computer();
        if (isWork(computer.getKeyboard()) &&
                isWork(computer.getMonitor()) &&
                isWork(computer.getMouse()))
        {
            System.out.println("Work!");
        }
    }

    public static boolean isWork(CompItem item)
    {
        System.out.println(item.getName());
        return item.getName() != null && item.getName().length() > 4;
    }

}
--------------------------------------
package com.javarush.test.level14.lesson08.home05;

/**
 * Created by Кира on 20.04.2016.
 */
public class Computer {
    private Keyboard keyboard;
    private Monitor monitor;
    private Mouse mouse;

    public Keyboard getKeyboard()
    {
        return keyboard;
    }
    public Monitor getMonitor()
    {
        return monitor;
    }
    public Mouse getMouse()
    {
        return mouse;
    }
    public Computer()
    {
        this.keyboard =  new Keyboard();
        this.monitor =new Monitor();
        this.mouse = new Mouse();
    }
}
--------------------------
package com.javarush.test.level14.lesson08.home05;

/**
 * Created by Кира on 20.04.2016.
 */
public class Monitor implements CompItem {
    @Override
    public String getName() {
        return "Monitor";
    }
}

package com.javarush.test.level14.lesson08.home05;

/**
 * Created by Кира on 20.04.2016.
 */
public class Mouse implements CompItem {
    @Override
    public String getName() {
        return "Mouse";
    }
}

package com.javarush.test.level14.lesson08.home05;

/**
 * Created by Кира on 20.04.2016.
 */
public class Keyboard implements CompItem {
    @Override
    public String getName() {
        return "Keyboard";
    }
}
--------------------------
package com.javarush.test.level14.lesson08.home05;

/**
 * Created by Кира on 20.04.2016.
 */
public interface CompItem {
     String getName();
}










package com.javarush.test.level14.lesson08.home06;

/* MovieFactory
Расширение функционала по аналогии, чтение с консоли:
1. Разобраться, что программа умеет делать.
2. Все классы должны быть внутри класса Solution.
3. Добавить классы Cartoon, Thriller.
4. Разобраться, как мы получаем объект класса SoapOpera по ключу "soapOpera".
Аналогично получению объекта SoapOpera сделать:
5. Добавить в MovieFactory.getMovie получение объекта Cartoon для ключа "cartoon".
6. Добавить в MovieFactory.getMovie получение объекта Thriller для ключа "thriller".

7. Считать с консоли несколько ключей (строк).
7.1. Ввод заканчивается, как только вводится строка не совпадающая с одной из: "cartoon", "thriller", "soapOpera".
8. Создать переменную movie класса Movie и для каждой введенной строки(ключа):
8.1. Получить объект используя MovieFactory.getMovie и присвоить его переменной movie.
8.2. Вывести на экран movie.getClass().getSimpleName().
*/

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String key;
        Movie movie;

        while (true)
        {
            key = reader.readLine();
            if (!key.equals("soapOpera") && !key.equals("cartoon") && !key.equals("thriller"))
            {
                break;
            } else movie = MovieFactory.getMovie(key);
            System.out.println(movie.getClass().getSimpleName());
        }
    }

    static class MovieFactory
    {

        static Movie getMovie(String key)
        {
            Movie movie = null;

            //создание объекта SoapOpera (мыльная опера) для ключа "soapOpera"
            if ("soapOpera".equals(key))
            {
                movie = new SoapOpera();
            }
            if ("cartoon".equals(key))
            {
                movie = new Cartoon();
            }
            if ("thriller".equals(key))
            {
                movie = new Thriller();
            }

            return movie;
        }
    }

    static abstract class Movie
    {
    }

    static class SoapOpera extends Movie
    {
    }

    static class Cartoon extends Movie{

    }

    static class Thriller extends Movie{

    }

    //Напишите тут ваши классы, пункт 3
}








package com.javarush.test.level14.lesson08.home07;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/* Клининговый центр
Клининговый центр
1. Реализовать метод cleanAllApartaments.
Для каждого объекта из apartaments:
2. Для однокомнатных квартир (Apt1Room) вызвать метод clean1Room.
т.е. если объект типа Apt1Room, то вызвать у него метод clean1Room.
3. Для двухкомнатных квартир (Apt2Room) вызвать метод clean2Rooms
т.е. если объект типа Apt2Room, то вызвать у него метод clean2Rooms.
4. Для трехкомнатных квартир (Apt3Room) вызвать метод clean3Rooms
т.е. если объект типа Apt3Room, то вызвать у него метод clean3Rooms.
*/
public class Solution
{
    public static void main(String[] args)
    {
        List<Apartament> apartaments = new ArrayList<Apartament>();
        apartaments.add(new Apt1Room());
        apartaments.add(new Apt2Room());
        apartaments.add(new Apt3Room());

        cleanAllApartaments(apartaments);
    }

    public static void cleanAllApartaments(List<Apartament> apartaments) {

        for (int i = 0, apartamentsSize = apartaments.size(); i < apartamentsSize; i++) {
            Apartament x = apartaments.get(i);

            if (x instanceof Apt1Room) {
                ((Apt1Room) x).clean1Room();
            }
            if (x instanceof Apt2Room) {
                ((Apt2Room) x).clean2Rooms();
            }
            if (x instanceof Apt3Room) {
                ((Apt3Room) x).clean3Rooms();
            }
        }
    }

    static interface Apartament
    {
    }

    static class Apt1Room implements Apartament
    {
        void clean1Room()
        {
            System.out.println("1 room is cleaned");
        }
    }

    static class Apt2Room implements Apartament
    {
        void clean2Rooms()
        {
            System.out.println("2 rooms are cleaned");
        }
    }

    static class Apt3Room implements Apartament
    {
        void clean3Rooms()
        {
            System.out.println("3 rooms are cleaned");
        }
    }
}










package com.javarush.test.level14.lesson08.home08;

/* Исправление ошибок
1. Подумать, как связаны интерфейсы Swimable(способен плавать) и Walkable(способен ходить) с классом OceanAnimal(животное океана).
2. Расставить правильно наследование интерфейсов и класса OceanAnimal.
3. Подумать, как могут быть связаны классы  Orca(Косатка), Whale(Кит), Otter(Выдра) с классом OceanAnimal.
4. Расставить правильно наследование между классами Orca, Whale, Otter и классом OceanAnimal.
5. Подумать, какой класс должен реализовать интерфейс Walkable и добавить интерфейc этому классу.
6. Подумать, какое животное еще не умеет плавать и добавить ему интерфейс Swimable.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Swimable animal = new Orca();
        animal.swim();
        animal = new Whale();
        animal.swim();
        animal = new Otter();
        animal.swim();
    }

    public static void test(Swimable animal)
    {
        animal.swim();
    }

    static interface Walkable
    {
        void walk();
    }

    static interface Swimable
    {
        void swim();
    }

    static abstract class OceanAnimal implements Swimable
    {
        public void swim()
        {
            OceanAnimal currentAnimal = (OceanAnimal) getCurrentAnimal();
            currentAnimal.swimming();
        }

        private void swimming()
        {
            System.out.println(getCurrentAnimal().getClass().getSimpleName() + " is swimming");
        }

        abstract Swimable getCurrentAnimal();
    }

    static class Orca extends OceanAnimal
    {

        @Override
        Swimable getCurrentAnimal() {
            return this;
        }
    }

    static class Whale extends OceanAnimal
    {


        @Override
        Swimable getCurrentAnimal() {
            return this;
        }
    }

    static class Otter implements Swimable, Walkable
    {

        @Override
        public void walk() {

        }

        @Override
        public void swim() {

        }
    }
}





package com.javarush.test.level14.lesson08.home09;

import java.util.ArrayList;
import java.util.List;

/* Валюты
1. Реализуй метод getAmount в классе Money:
1.1. Подумай, какого типа нужно создать приватную переменную, если метод getAmount будет ее возвращать.
1.2. Создай приватную переменную этого типа и верни ее в методе getAmount.
1.3. В конструкторе присвой ей значение, полученное параметром.
2. В отдельном файле создай класс Hrivna.
3. Наследуй класс Hrivna от класса Money.
4. В классе Hrivna реализуй метод getCurrencyName, который возвращает "HRN".
5. В отдельном файле создай класс USD.
6. Наследуй класс USD от класса Money.
7. В классе USD реализуй метод getCurrencyName, который возвращает "USD".
8. Подумай, объекты каких классов можно добавить в список(лист) allMoney.
9. Добавь в конструктор класса Person заполнение листа allMoney объектами всех возможных классов.
*/

public class Solution
{
    public static void main(String[] args)
    {
        Person ivan = new Person("Иван");
        for (Money money : ivan.getAllMoney())
        {
            System.out.println(ivan.name + " имеет заначку в размере " + money.getAmount() + " " + money.getCurrencyName());
        }
    }

    static class Person
    {
        public String name;

        Person(String name)
        {
            this.name = name;
            this.allMoney = new ArrayList<Money>();
            allMoney.add(new USD(1));
            allMoney.add(new Hrivna(2));
        }

        private List<Money> allMoney;

        public List<Money> getAllMoney()
        {
            return allMoney;
        }
    }
}
-------------------------
package com.javarush.test.level14.lesson08.home09;

public abstract class Money
{
    public Money(double amount)
    {
        amount = 100;
    }

    private double amount = 100;

    public double getAmount(){
        return amount;
    }


    public abstract String getCurrencyName();
}

--------------------------
package com.javarush.test.level14.lesson08.home09;

/**
 * Created by Кира on 21.04.2016.
 */
public class USD extends Money {

    public USD(double amount) {
        super(amount);
    }

    @Override
    public String getCurrencyName() {
        return "USD";
    }
}
------------------------
package com.javarush.test.level14.lesson08.home09;

/**
 * Created by Кира on 21.04.2016.
 */
public class Hrivna extends Money {
    public Hrivna(double amount) {
        super(amount);
    }

    @Override
    public String getCurrencyName() {
        return "HRN";
    }
}













____________________________________________________________________________________________________________ПРОСМОТРЕТЬ___(НЕ ПРИНЯЛО СЕРВЕРОМ)
package com.javarush.test.level14.lesson08.home10;

import java.util.LinkedList;
import java.util.List;

/* Исправить 4 ошибки
Исправить 4 ошибки в конструкторе NotIncapsulatedClass и отрефактори код
1. В класе NotIncapsulatedClass создать private методы initList(List<Number> list), printListValues, processCastedObjects.
2. Метод initList должен заполнять значениями входящий параметр list:
- найди нужный блок кода в конструкторе, в котором list заполняется значениями
- перенеси его в метод initList
- верни заполненный list.
3. Метод printListValues должен принимать параметр list и вывести в консоль все элементы из списка list:
- метод ничего не возвращает
- найди нужный блок кода в конструкторе, в котором в цикле из списка list выводятся в консоль все значения
- перенеси его в метод printListValues
- исправь 2 ошибки в этом методе.
4. Метод processCastedObjects:
- входящий параметр метода имеет тип List<Number> list
- метод ничего не возвращает
- найди нужный блок кода в конструкторе, в котором в цикле для каждого объекта из списка list проверяется его тип
- перенеси этот блок в метод processCastedObjects
- исправь 2 ошибки в этом методе
- учти, что для объекта типа Float нужно вывести "Is float value defined? " + [Float_object].isNaN()
- учти, что для объекта типа Double нужно вывести "Is double value infinite? " + [Double_object].isInfinite().
*/

public class Solution {
    public static void main(String[] args) {
        new NotIncapsulatedClass();
    }

    public static class NotIncapsulatedClass
    {
        public NotIncapsulatedClass()
        {
            List<Number> list = new LinkedList<Number>();
            //1
            initList(list); // здесь надо просто позвать метод initList
            printListValues(list); // почему тут правильно позвал метод ?
            //3
            for (Number object : list)
            {
                //Исправь 2 ошибки
                processCastedObjects(object);
            }
        }
        private List<Number> initList(List<Number> list){ // если кто вызовет этот метод он
            list.add(new Double(1000f));  // получит заполненную коллекцию этими данными
            list.add(new Double("123e-445632"));
            list.add(new Float(-90 / -3));
            list.remove(new Double("123e-445632")); // верните обратно уберите //
            return list;  // и получит её обратно
        }
        private void printListValues(List<Number> list){
            for (int i = 0; i < list.size(); i++)
            {
                System.out.println(list.get(i));
            }
        }
        private void processCastedObjects(Number object){
            if (object instanceof Double)
            {
                Double a = (Double) object;
                System.out.println("Is double value infinite? " + a.isInfinite());
            }
            else if (object instanceof Float)
            {
                Float a = (Float) object;
                System.out.println("Is float value defined? " + a.isNaN());
            }
        }
    }
}





____________________________________________________________________________________________________________ПРОСМОТРЕТЬ___(ПРИНЯЛО СЕРВЕРОМ)
package com.javarush.test.level14.lesson08.home10;

import java.util.LinkedList;
import java.util.List;

/* Исправить 4 ошибки
Исправить 4 ошибки в конструкторе NotIncapsulatedClass и отрефактори код
1. В класе NotIncapsulatedClass создать private методы initList(List<Number> list), printListValues, processCastedObjects.
2. Метод initList должен заполнять значениями входящий параметр list:
- найди нужный блок кода в конструкторе, в котором list заполняется значениями
- перенеси его в метод initList
- верни заполненный list.
3. Метод printListValues должен принимать параметр list и вывести в консоль все элементы из списка list:
- метод ничего не возвращает
- найди нужный блок кода в конструкторе, в котором в цикле из списка list выводятся в консоль все значения
- перенеси его в метод printListValues
- исправь 2 ошибки в этом методе.
4. Метод processCastedObjects:
- входящий параметр метода имеет тип List<Number> list
- метод ничего не возвращает
- найди нужный блок кода в конструкторе, в котором в цикле для каждого объекта из списка list проверяется его тип
- перенеси этот блок в метод processCastedObjects
- исправь 2 ошибки в этом методе
- учти, что для объекта типа Float нужно вывести "Is float value defined? " + [Float_object].isNaN()
- учти, что для объекта типа Double нужно вывести "Is double value infinite? " + [Double_object].isInfinite().
*/

public class Solution {
    public static void main(String[] args) {
        new NotIncapsulatedClass();
    }

    public static class NotIncapsulatedClass {

        public NotIncapsulatedClass() {
            List<Number> list = new LinkedList<Number>();
            //1
            initList(list);
            //2 - Исправь 2 ошибки
            printListValues(list);
            //3
            processCastedObjects(list);
        }

        private List<Number> initList(List<Number> list) {
            list.add(new Double(1000f));
            list.add(new Double("123e-445632"));
            list.add(new Float(-90 / -3));
            list.remove(new Double("123e-445632"));
            return list;
        }

        private void printListValues(List list) {
            for (int i = 0; i < list.size(); i++) {
                System.out.println(list.get(i));
            }
        }

        private void processCastedObjects(List<Number> list) {
            for (Number object : list) {
                //Исправь 2 ошибки
                if (object instanceof Double) {
                    Double a = (Double) object;
                    System.out.println("Is double value infinite? " + a.isInfinite());
                } else if (object instanceof Float) {
                    Float a = (Float) object;
                    System.out.println("Is float value defined? " + a.isNaN());
                }
            }
        }
    }
}





____________________________________________________________________________-SINGLETON
package com.javarush.test.level14.lesson08.bonus03;

/* Singleton
Класс является синглтоном (реализует паттерн(шаблон) Singleton), если позволяет создать всего один объект своего типа.

Реализовать Singleton pattern:
1. Создай класс Singleton в отдельном файле.
2. Добавь в него статический метод getInstance().
3. Метод getInstance должен возвращать один и тот же объект класса Singleton при любом вызове метода getInstance.
4. Подумай, каким образом можно запретить создание других объектов этого класса.
5. Сделай все конструкторы в классе Singleton приватными (private).

6. В итоге должна быть возможность создать объект (экземпляр класса) ТОЛЬКО используя метод getInstance.
*/
public class Solution
{
    public static void main(String[] args)
    {
        Singleton.getInstance();
    }
}
----------------------------------
package com.javarush.test.level14.lesson08.bonus03;

/**
 * Created by Кира on 21.04.2016.
 */
public class Singleton {

    private final static Singleton turtle = new Singleton();

    private Singleton(){

    }
    public static Singleton getInstance(){
        return turtle;
    }
}







package com.javarush.test.level14.lesson08.bonus01;

import java.util.ArrayList;
import java.util.List;

/* Нашествие эксепшенов
Заполни массив exceptions 10 различными эксепшенами.
Первое исключение уже реализовано в методе initExceptions.
*/

public class Solution
{
    public static List<Exception> exceptions = new ArrayList<Exception>();

    public static void main(String[] args)
    {
        initExceptions();

        for (Exception exception : exceptions)
        {
            System.out.println(exception);
        }
    }

    private static void initExceptions()
    {   //it's first exception
        try
        {
            float i = 1 / 0;

        }
        catch (Exception e)
        {
            exceptions.add(e);
        }
        try{
            float i = 2/0;
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            int i = 2/0;
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            double i = 2/0;
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            byte i = (byte) (2/0);
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            char i = (char) (2/0);
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            long i = 2/0;
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            String i = String.valueOf(2/0);
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            float i = 22/0;
        }
        catch(Exception e1){
            exceptions.add(e1);
        }
        try{
            float i = 26/0;
        }
        catch(Exception e1){
            exceptions.add(e1);
        }

    }
}




package com.javarush.test.level15.lesson02.task01;

/* ООП - Расставить интерфейсы
1. Добавить все возможные интерфейсы из Movable, Sellable, Discountable в класс Clothes.
2. Реализовать их методы.
*/

public class Solution {
    public static interface Movable {
        boolean getAllowedAction(String name);
    }

    public static interface Sellable {
        Object getAllowedAction(String name);
    }

    public static interface Discountable {
        Object getAllowedAction();
    }

    public static class Clothes implements Sellable, Discountable
    {
        @Override
        public Object getAllowedAction() {
            return null;
        }

        @Override
        public Object getAllowedAction(String name) {
            return null;
        }
    }
}






package com.javarush.test.level15.lesson02.task02;

/* ООП - наследование животных
1. Создать public static класс Goose(Гусь).
2. Создать public static класс Dragon(Дракон).
3. Унаследовать класс Goose от BigAnimal или SmallAnimal, подумать, какой логически больше подходит.
4. Унаследовать класс Dragon от BigAnimal или SmallAnimal, подумать, какой логически больше подходит.
5. В классах Goose и Dragon переопределить метод String getSize(), расширить видимость до максимальной.
6. В классе Goose метод getSize должен возвращать строку "Гусь маленький, " + [getSize родительского класса].
7. В классе Dragon метод getSize должен возвращать строку "Дракон большой, " + [getSize родительского класса].
*/

public class Solution {
    public static class Goose extends SmallAnimal
    {
        public String getSize() {
            return "Гусь маленький, " + super.getSize();
        }

    }

    public static class Dragon extends BigAnimal
    {
        public String getSize() {
            return "Дракон большой, " + super.getSize();
        }

    }

    public static class BigAnimal {
        String getSize() {
            return "как динозавр";
        }
    }

    public static class SmallAnimal {
        String getSize() {
            return "как кошка";
        }
    }
}









package com.javarush.test.level15.lesson02.task03;

/* ООП - машинки
1. Для вывода использовать можно только переменные из класса Constants.
2. В классе Ferrari реализуйте метод printlnDesire, чтобы он выводил на экран "Я хочу ездить на Феррари".
3. В классе Lanos реализуйте метод printlnDesire, чтобы он выводил на экран "Я хочу ездить на Ланосе".
4. Создайте public static класс LuxuriousCar(РоскошнаяМашина).
5. Создайте public static класс CheapCar(ДешеваяМашина).
6. Унаследуйте Ferrari и Lanos от CheapCar и LuxuriousCar, подумайте, какой класс для кого.
7. В классе LuxuriousCar реализуйте метод printlnDesire, чтобы он выводил на экран "Я хочу ездить на роскошной машине".
8. В классе CheapCar реализуйте метод printlnDesire, чтобы он выводил на экран "Я хочу ездить на дешевой машине".
9. В класах LuxuriousCar и CheapCar для метода printlnDesire расставьте различными способами модификаторы доступа так,
чтобы в классах Ferrari и Lanos выполнялось расширение видимости.
*/

public class Solution {
    public static void main(String[] args) {
        new Solution.LuxuriousCar().printlnDesire();
        new Solution.CheapCar().printlnDesire();
        new Solution.Ferrari().printlnDesire();
        new Solution.Lanos().printlnDesire();
    }

    public static class CheapCar extends Constants{
        void printlnDesire() {
            System.out.println(WANT_STRING + CHEAP_CAR);
        }
    }

    public static class LuxuriousCar extends Constants{
        protected void printlnDesire() {
            System.out.println(WANT_STRING + LUXURIOUS_CAR);
        }
    }

    public static class Ferrari extends LuxuriousCar{
        public void printlnDesire() {
            System.out.println(WANT_STRING + FERRARY_NAME);
        }
    }

    public static class Lanos extends CheapCar{
        public void printlnDesire() {
            System.out.println(WANT_STRING + LANOS_NAME);
        }
    }

    public static class Constants {
        public static String WANT_STRING = "Я хочу ездить на ";
        public static String LUXURIOUS_CAR = "роскошной машине";
        public static String CHEAP_CAR = "дешевой машине";
        public static String FERRARY_NAME = "Феррари";
        public static String LANOS_NAME = "Ланосе";
    }
}




package com.javarush.test.level15.lesson02.task04;

/* ООП - книги
1. Создайте public static класс MarkTwainBook, который наследуется от Book. Имя автора [Mark Twain]. Параметр конструктора - имя книги.
2. В классе MarkTwainBook реализуйте все абстрактные методы.
3. Для метода getBook расширьте тип возвращаемого результата.
4. Создайте по аналогии AgathaChristieBook. Имя автора [Agatha Christie].
5. В классе Book реализуйте тело метода getOutputByBookType так, чтобы он возвращал:
5.1. agathaChristieOutput для книг Агаты Кристи;
5.2. markTwainOutput для книг Марка Твена.
*/

import java.util.LinkedList;
import java.util.List;

public class Solution {
    public static void main(String[] args) {
        List<Book> books = new LinkedList<Book>();
        books.add(new MarkTwainBook("Tom Sawyer"));
        books.add(new AgathaChristieBook("Hercule Poirot"));
        System.out.println(books);
    }

    public static class MarkTwainBook extends Book{

        public MarkTwainBook(String author) {
            super("Mark Twain");
        }

        public MarkTwainBook getBook() {
            return this;
        }

        @Override
        public String getName() {
            return "Tom Sawyer";
        }
    }

    public static class AgathaChristieBook extends Book{

        public AgathaChristieBook(String author) {
            super("Agatha Christie");
        }


        public AgathaChristieBook getBook() {
            return this;
        }

        @Override
        public String getName() {
            return "Hercule Poirot";
        }
    }

    public abstract static class Book {
        private String author;

        public Book(String author) {
            this.author = author;
        }

        public abstract Book getBook();

        public abstract String getName();

        private String getOutputByBookType() {
            String agathaChristieOutput = author + ", " + getBook().getName() + " is a detective";
            String markTwainOutput = getBook().getName() + " book was written by " + author;
            String output = "output";
            if (this instanceof AgathaChristieBook ){
                output = agathaChristieOutput;}//Add your code here
            else if (this instanceof MarkTwainBook ){
                output = markTwainOutput;}//Add your code here
            return output;
        }

        public String toString() {
            return getOutputByBookType();
        }
    }
}






___________________________________________________________________________________________ООП
package com.javarush.test.level15.lesson02.task04;

/* ООП - книги
1. Создайте public static класс MarkTwainBook, который наследуется от Book. Имя автора [Mark Twain]. Параметр конструктора - имя книги.
2. В классе MarkTwainBook реализуйте все абстрактные методы.
3. Для метода getBook расширьте тип возвращаемого результата.
4. Создайте по аналогии AgathaChristieBook. Имя автора [Agatha Christie].
5. В классе Book реализуйте тело метода getOutputByBookType так, чтобы он возвращал:
5.1. agathaChristieOutput для книг Агаты Кристи;
5.2. markTwainOutput для книг Марка Твена.
*/

import java.util.LinkedList;
import java.util.List;

public class Solution {
    public static void main(String[] args) {
        List<Book> books = new LinkedList<Book>();
        books.add(new MarkTwainBook("Tom Sawyer"));
        books.add(new AgathaChristieBook("Hercule Poirot"));
        System.out.println(books);
    }

    public static class MarkTwainBook extends Book
    {
        public String name;

        protected MarkTwainBook(String name)
        {
            super("Mark Twain");
            this.name = name;
        }
        public MarkTwainBook getBook()
        {
            return this;
        }
        public String getName()
        {
            return name;
        }
    }
    public static class AgathaChristieBook extends Book{

        public String name;

        protected AgathaChristieBook(String name)
        {
            super("Agatha Christie");
            this.name = name;
        }
        public AgathaChristieBook getBook()
        {
            return this;
        }
        public String getName()
        {
            return name;
        }
    }

    public abstract static class Book
    {
        private String author;
        public Book(String author)
        {
            this.author = author;
        }
        public abstract Book getBook();
        public abstract String getName();
        private String getOutputByBookType()
        {
            String agathaChristieOutput = author + ", " + getBook().getName() + " is a detective";
            String markTwainOutput = getBook().getName() + " book was written by " + author;
            String output = "";
            if (this instanceof AgathaChristieBook)
            {output = agathaChristieOutput;}
            else {output = markTwainOutput;}
            return output;
        }
        public String toString()
        {
            return getOutputByBookType();
        }
    }

}







package com.javarush.test.level15.lesson02.task05;

import java.util.ArrayList;
import java.util.List;

/* ООП - исправь ошибки в наследовании
Исправь метод containsBones и всю связанную с ним логику так, чтобы:
1. Поведение программы осталось прежним, т.е. она должна выдавать то же самое, что и выдает сейчас
2. Метод containsBones должен возвращать тип Object и значение "Yes" вместо true, "No" вместо false
*/

public class Solution {

    public static interface Alive {
        Object containsBones();
    }

    public static class BodyPart implements Alive {
        private String name;

        public BodyPart(String name) {
            this.name = name;
        }

        public Object containsBones() {
            return "Yes";
        }

        public String toString() {
            if (containsBones().equals("Yes")) return name + " содержит кости";
            else return name + " не содержит кости";
        }
    }

    public static class Finger extends BodyPart {
        private boolean isFoot;

        public Finger(String name, boolean isFoot) {
            super(name);
            this.isFoot = isFoot;
        }

        public Object containsBones() {
            {
                Object s = null;
                if (isFoot)
                    s = "No";
                else if (!isFoot)
                    s = "Yes";
                return s;

            }
        }

        public static void main(String[] args) {
            printlnFingers();
            printlnBodyParts();
            printlnAlives();
        }

        private static void printlnAlives() {
            System.out.println(new BodyPart("Рука").containsBones());
        }

        private static void printlnBodyParts() {
            List<BodyPart> bodyParts = new ArrayList<BodyPart>(5);
            bodyParts.add(new BodyPart("Рука"));
            bodyParts.add(new BodyPart("Нога"));
            bodyParts.add(new BodyPart("Голова"));
            bodyParts.add(new BodyPart("Тело"));
            System.out.println(bodyParts.toString());
        }

        private static void printlnFingers() {
            List<Finger> fingers = new ArrayList<Finger>(5);
            fingers.add(new Finger("Большой", true));
            fingers.add(new Finger("Указательный", true));
            fingers.add(new Finger("Средний", true));
            fingers.add(new Finger("Безымянный", false));
            fingers.add(new Finger("Мизинец", true));
            System.out.println(fingers.toString());
        }
    }

	
	
	
	
	package com.javarush.test.level15.lesson04.task01;

/* Что-то лишнее
1. Программа должна выводить следующее:
Это double
Это Object
Это double
Это Integer
Это double

2 Удалите реализации всех лишних методов
*/

public class Solution {
    public static void main(String[] args) {
        print((short) 1);
        print((Number) 1);
        print(1);
        print((Integer) 1);
        print((int) 1);
    }

    public static void print(Integer i) {
        System.out.println("Это Integer");
    }


    public static void print(Object i) {
        System.out.println("Это Object");
    }

    public static void print(double i) {
        System.out.println("Это double");
    }
}








package com.javarush.test.level15.lesson04.task02;

/* ООП - Перегрузка
Перегрузите метод printMatrix 8 различными способами. В итоге должно получиться 10 различных методов printMatrix.
*/

public class Solution {
    public static void main(String[] args) {
        printMatrix(2, 3, "8");
    }

    public static void printMatrix(int m, int n, String value) {
        System.out.println("Заполняем объектами String");
        printMatrix(m, n, (Object) value);
    }

    public static void printMatrix(int n, int m, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, int n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(short m, int n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, short n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(long m, int n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, long n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, byte n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, int n, String value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }
    public static void printMatrix(short m, short n, String value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }
}




package com.javarush.test.level15.lesson04.task03;

/* ООП - Перегрузка - убираем лишнее
1. Подумайте, какая из реализаций метода print будет вызвана.
2. Удалите все лишние реализации метода print.
*/

public class Solution {
    public static void main(String[] args) {
        print(1);
    }

    public static void print(long l) {
        System.out.println("Я буду Java прогером!");
    }
}









package com.javarush.test.level15.lesson04.task04;

/* Мужчина или женщина?
1. В методе main создать 2 человека man и woman. man с типом Man, woman с типом Woman.
2. Изменить метод printName так, чтобы он выполнялся для man и woman.
3. Реализация метода printName должна быть одна.
*/

public class Solution {
    public static void main(String[] args) {
        Man man = new Man();
        Woman woman = new Woman();

        printName(man);
        printName(woman);
    }

    public static void printName(Human human) {

    }

    public static class Human {

        public Human() {
        }
    }

    public static class Man extends Human {

        protected Man() {
            super();
        }


    }

    public static class Woman extends Human {

        protected Woman() {
            super();
        }
    }
}







package com.javarush.test.level15.lesson04.task05;

/* Все лишнее - прочь!
Убрать в методе main лишние строки, для которых метод add нереализован.
*/

public class Solution {
    public static void main(String[] args) {
        add((short) 1, 2f);
        add(1, 2);
        add(2d, 2);
        add("1",2d);
        add((byte) 1, 2d);
    }

    public static void add(int i, int j) {
        System.out.println("Integer addition");
    }

    public static void add(int i, double j) {
        System.out.println("Integer and double addition");
    }

    public static void add(double i, double j) {
        System.out.println("Double addition");
    }
}




package com.javarush.test.level15.lesson04.task05;

/* Все лишнее - прочь!
Убрать в методе main лишние строки, для которых метод add нереализован.
*/

public class Solution {
    public static void main(String[] args) {
        add((short) 1, 2f);
        add(1, 2);
        add(2d, 2);
        add((byte) 1, 2d);
    }

    public static void add(int i, int j) {
        System.out.println("Integer addition");
    }

    public static void add(int i, double j) {
        System.out.println("Integer and double addition");
    }

    public static void add(double i, double j) {
        System.out.println("Double addition");
    }
}





package com.javarush.test.level15.lesson06.task01;

import java.io.Serializable;

/* Максимально простой код 1
Упрости код - убери все наследования и реализации, которые и так будут добавлены автоматически при компиляции
PS: Взаимосвязь между объектами me и zapp - Has-a (использует): http://ru.wikipedia.org/wiki/Has-a
*/

public class Solution {
    public static void main(String[] args) {
        JuniorJavaDev me = new JuniorJavaDev();
        System.out.println(me.askHubert("What do you think about level15.lesson06.task01?"));
        System.out.println(me.askZapp("When will be the next update?"));
    }

    public interface SpecificSerializable extends Serializable {
    }

    public static class JavaDev implements SpecificSerializable {
        String answerQuestion(String question) {
            return String.format("I'll be thinking of [%s]", question);
        }
    }

    public static class JuniorJavaDev extends JavaDev{
        JavaDev zapp = new JavaDev();
        JavaDev hubert = new JavaDev();

        String askZapp(String question) {
            return zapp.answerQuestion(question);
        }

        String askHubert(String question) {
            return hubert.answerQuestion(question);
        }
    }
}




package com.javarush.test.level15.lesson06.task02;

/* Максимально простой код 2
Посмотри, что, связанное с конструкторами, может быть добавлено при компиляции, но в этой программе уже присутствует.
Упрости код - удали все конструкторы и вызовы конструкторов супер-классов, которые создаются и добавляются автоматически.

PS: Взаимосвязь между объектами классов NakedCat и NormalCat, SiamCat - Is-a (наследование): http://en.wikipedia.org/wiki/Is-a
http://cs7002.vk.me/c7007/v7007577/1411a/_dAiEola310.jpg
*/

public class Solution {
    public static void main(String[] args) {
        SiamCat simka = new SiamCat("Simka");
        NakedCat nakedSimka = simka.shave();
    }

    public static class NakedCat {
    }

    public static class NormalCat extends NakedCat {
        public NormalCat() {
        }

        public NormalCat(String name) {
            System.out.println("My name is " + name);
        }

        public NakedCat shave() {
            return this;
        }
    }

    public static class SiamCat extends NormalCat {
        public SiamCat(String name) {
            super(name);
        }
    }
}




package com.javarush.test.level15.lesson06.task03;

/* Максимально простой код 3
Упрости код:
- убери всё то, что будет генерироваться автоматически при компиляции
- убери все наследования классов, которые и так будут добавлены автоматически при компиляции
- убери все конструкторы, которые создаются и добавляются автоматически.
*/

public class Solution {
    public static void main(String[] args) {
    }

    public interface Runnable {

    }

    public class Machine implements Runnable {

    }

    public class Car extends Machine{

    }
}






__________________________________________________________________________СТАТИЧНЫЕ БЛОКИ

package com.javarush.test.level15.lesson09.task01;

import java.util.HashMap;
import java.util.Map;

/* Статики 1
В статическом блоке инициализировать labels 5 различными парами.
*/

public class Solution {

    public static Map<Double, String> labels = new HashMap<Double, String>();

    public static void main(String[] args) {
        System.out.println(labels);
    }


    static {
        labels.put(4.6758, "daw645");
    }

    static {
        labels.put(4.6453, "dagfw");
    }

    static {
        labels.put(4.643242, "dawtgr");
    }

    static {
        labels.put(4.64324, "dagtrw");
    }

    static {
        labels.put(4.6352, "dagtrw");
    }
}







package com.javarush.test.level15.lesson09.task02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Статики 2
1. В статическом блоке считайте две переменные с консоли А и В с типом int.
2. Не забыть про IOException, который надо обработать в блоке catch.
3. Закрыть поток ввода методом close().
*/

public class Solution {
    public static int A;
    public static int B;


    static{

        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            A = Integer.parseInt(reader.readLine());
            B = Integer.parseInt(reader.readLine());
            reader.close();

        } catch (IOException e) {
            System.out.println(e);
        }

    }
    public static final int MIN = min(A, B);

    public static void main(String[] args) {
        System.out.println(MIN);
    }

    public static int min(int a, int b) {
        return a < b ? a : b;
    }
}








package com.javarush.test.level15.lesson04.task02;

/* ООП - Перегрузка
Перегрузите метод printMatrix 8 различными способами. В итоге должно получиться 10 различных методов printMatrix.
*/

public class Solution {
    public static void main(String[] args) {
        printMatrix(2, 3, "8");
    }

    public static void printMatrix(int m, int n, String value) {
        System.out.println("Заполняем объектами String");
        printMatrix(m, n, (Object) value);
    }

    public static void printMatrix(int n, int m, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, int n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(short m, int n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, short n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(long m, int n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, long n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, byte n, Object value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static void printMatrix(byte m, int n, String value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }
    public static void printMatrix(short m, short n, String value) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(value);
            }
            System.out.println();
        }
    }
}





package com.javarush.test.level15.lesson09.task03;

/* Статики 3
1. Создать 7 public полей класса. Убедитесь, что они инициализируются дефолтными значениями.
intVar с типом int
doubleVar с типом double
DoubleVar с типом Double
booleanVar с типом boolean
ObjectVar с типом Object
ExceptionVar с типом Exception
StringVar с типом String
2. В методе main вывести их значения в заданном порядке.
*/

public class Solution {

    public static int intVar;
    public static double doubleVar;
    public static Double DoubleVar;
    public static boolean booleanVar;
    public static Object ObjectVar;
    public static Exception ExceptionVar;
    public static String StringVar;




    public static void main(String[] args) {

        System.out.println(intVar);
        System.out.println(doubleVar);
        System.out.println(DoubleVar);
        System.out.println(booleanVar);
        System.out.println(ObjectVar);
        System.out.println(ExceptionVar);
        System.out.println(StringVar);


    }
}





package com.javarush.test.level15.lesson09.task04;

/* Статики и исключения
В статическом блоке выбросьте RuntimeException
В результате класс не загрузится, и вы увидите сообщение об ошибке вместо значения переменной B

Exception in thread "main" java.lang.ExceptionInInitializerError
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:186)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:113)
Caused by: java.lang.RuntimeException:
at com.javarush.test.level15.lesson09.task04.Solution.clinit(Solution.java:22)

Hint: Нужно погуглить причину, если получилось следующее:
java: initializer must be able to complete normally
java: unreachable statement
*/

public class Solution {
    public static int A = 0;


    static {
        if (true) throw new RuntimeException();
    }

    public static int B = 5;

    public static void main(String[] args) {
        System.out.println(B);
    }
}





package com.javarush.test.level15.lesson09.task05;

/* Статики 4
Внутри статического блока:
1. Создайте класс Cat
2. Внутри Cat создайте поле класса String name = "Пушок"
3. Создайте объект класса Cat - myCat
4. Присвойте статическому объекту Object cat объект, созданный в п.3
5. Выведите в консоль myCat.name
*/

public class Solution {

    public static Object cat;

    static{
        class Cat {

            String name = "Пушок";
        }

            Cat myCat = new Cat();

            cat = myCat;

            System.out.println(myCat.name);

        }

    }


	
		
	
	
	
	
	
	

_________________________________________________________________________________________---WATCH!!!!!!!!!!!!!!!ПОЛЕЗНО
package com.javarush.test.level15.lesson12.home01;


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Разные методы для разных типов
1. Считать с консоли данные, пока не введено слово "exit".
2. Для каждого значения, кроме "exit", вызвать метод print. Если значение:
2.1. содержит точку '.', то вызвать метод print для Double;
2.2. больше нуля, но меньше 128, то вызвать метод print для short;
2.3. больше либо равно 128, то вызвать метод print для Integer;
2.4. иначе, вызвать метод print для String.
*/

public class Solution {
    public static void main(String[] args) throws IOException {


        BufferedReader reader = new BufferedReader((new InputStreamReader(System.in)));
        while (true) {
            String key = reader.readLine();
            try {
                if (key.equals("exit")) break;
                if (key.contains(".")) {
                    print(Double.parseDouble(key));
                } else if (((Integer.parseInt(key)) > 0) && ((Integer.parseInt(key)) < 128)) {
                    print(Short.parseShort(key));
                } else if (((Integer.parseInt(key)) >= 128)) {
                    print(Integer.parseInt(key));
                } else {
                    print(reader.readLine());
                }
            } catch (NumberFormatException e) {
                print(key);
            }
        }
    }
	

    public static void print(Double value) {
        System.out.println("Это тип Double, значение " + value);
    }

    public static void print(String value) {
        System.out.println("Это тип String, значение " + value);
    }

    public static void print(short value) {
        System.out.println("Это тип short, значение " + value);
    }

    public static void print(Integer value) {
        System.out.println("Это тип Integer, значение " + value);
    }
}





package com.javarush.test.level15.lesson12.home02;

/* Тренировка мозга
Найти логическую ошибку: метод doAction в реализации интерфейса Movable должен выдавать "moving".
Исправьте ошибку, при необходимости измените (отрефакторите) интерфейс Movable.
Результат вывода в консоль должен быть:
flying
moving
*/

public class Solution {
    public static void main(String[] args) {
        Duck duck = new Duck();
        Util.fly(duck);
        Util.move(duck);
    }

    public static class Duck implements Flyable, Movable {
        @Override
        public void doAction() {
            System.out.println("flying");
        }

        @Override
        public void doAct() {
            System.out.println("moving");
        }
    }

    public static class Util {
        static void fly(Flyable animal) {
            animal.doAction();
        }

        static void move(Movable animal) {
            animal.doAct();
        }
    }

    public static interface Flyable {
        void doAction();
    }

    public static interface Movable {
        void doAct();
    }
}






_________________________________________________________________________________________________ПЕРЕГРУЗКА МЕТОДОВ, ЛИСТИНГ ОБЬЕКТОВ
package com.javarush.test.level15.lesson12.home03;

import java.math.BigDecimal;

/* ООП - перегрузка
1.В классе Tree перегрузи метод info(Object s) два раза так, чтобы получилось три метода info(Object s), info(Number s), info(String s).
1.1. Разберись в методе info(Object s). Сделай по аналогии функционал новых методов.
1.2. Например, для метода info(Number s) результат может быть таким "Дерево № 123 , метод Number, параметр Short".
2. В блоке 2 должен вызываться метод info(Object s).
3. В блоке 3 должен вызываться метод info(Number s).
4. В блоке 4 должен вызываться метод info(String s).
*/

public class Solution {
    public static void main(String[] args) {
        //Блок 2.
        //Вызов для Object (задание 2)
        new Tree().info((Object)new Integer("4"));
        new Tree().info((Object)new Short("4"));
        new Tree().info((Object)new BigDecimal("4"));

        //Блок 3.
        //Вызов для Number (Задание 3)
        new Tree().info((Number)new Integer("4"));
        new Tree().info((Number)new Short("4"));
        new Tree().info((Number)new BigDecimal("4"));

        //Блок 4.
        //Вызов для String (Задание 4)
        new Tree().info((String) new String("4"));
        new Tree().info((String)new Integer("4").toString());
        new Tree().info((String)new Short("4").toString());
        new Tree().info((String)new BigDecimal("4").toString());
    }
}
-----------------------------------------------------------------
package com.javarush.test.level15.lesson12.home03;

public class Tree {
    public static int globalNumber;
    public int number;

    public Tree() {
        this.number = ++globalNumber;
    }

    public void info(Object s) {
        System.out.println(String.format("Дерево № %d , метод Object, параметр %s", number, s.getClass().getSimpleName()));
    }

    public void info(Number s) {
        System.out.println(String.format("Дерево № %d , метод Number, параметр %s", number, s.getClass().getSimpleName()));
    }

    public void info(String s) {
        System.out.println(String.format("Дерево № %d , метод String, параметр %s", number, s.getClass().getSimpleName()));
    }

}








public class Solution {
    public static int A = 0;


    static {
        if (true) throw new RuntimeException();
    }

    public static int B = 5;

    public static void main(String[] args) {
        System.out.println(B);
    }
}









package com.javarush.test.level15.lesson09.task03;

/* Статики 3
1. Создать 7 public полей класса. Убедитесь, что они инициализируются дефолтными значениями.
intVar с типом int
doubleVar с типом double
DoubleVar с типом Double
booleanVar с типом boolean
ObjectVar с типом Object
ExceptionVar с типом Exception
StringVar с типом String
2. В методе main вывести их значения в заданном порядке.
*/

public class Solution {

    public static int intVar;
    public static double doubleVar;
    public static Double DoubleVar;
    public static boolean booleanVar;
    public static Object ObjectVar;
    public static Exception ExceptionVar;
    public static String StringVar;




    public static void main(String[] args) {

        System.out.println(intVar);
        System.out.println(doubleVar);
        System.out.println(DoubleVar);
        System.out.println(booleanVar);
        System.out.println(ObjectVar);
        System.out.println(ExceptionVar);
        System.out.println(StringVar);


    }
}









package com.javarush.test.level15.lesson12.home04;

/* Закрепляем Singleton pattern
1. Найти в гугле пример для - Singleton pattern Lazy initialization.
2. По образу и подобию в отдельных файлах создать три синглтон класса Sun, Moon, Earth.
3. Реализовать интерфейс Planet для классов Sun, Moon, Earth.
4. В статическом блоке класса Solution вызвать метод readKeyFromConsoleAndInitPlanet.
5. Реализовать функционал метода readKeyFromConsoleAndInitPlanet:
5.1. С консоли считать один параметр типа String.
5.2. Если параметр равен одной из констант интерфейса Planet, то создать соответствующий объект и присвоить его Planet thePlanet, иначе обнулить Planet thePlanet.
5.3. Сравнивать введенный параметр можно только с константами из Planet, нельзя создавать свои строки.
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Solution {

    public static void main(String[] args) {

    }

    public static Planet thePlanet;

    static {

        try {
            readKeyFromConsoleAndInitPlanet();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void readKeyFromConsoleAndInitPlanet() throws IOException {

        try
        {
            String s = new BufferedReader(new InputStreamReader(System.in)).readLine();
            if(s.equals(Planet.EARTH))
                thePlanet = Earth.getInstance();
            else if(s.equals(Planet.MOON))
                thePlanet = Moon.getInstance();
            else if(s.equals(Planet.SUN))
                thePlanet = Sun.getInstance();
            else
                thePlanet = null;

        }catch(IOException e){}

    }
}
--------------------------------
package com.javarush.test.level15.lesson12.home04;

public interface Planet {
    static String SUN = "sun";
    static String MOON = "moon";
    static String EARTH = "earth";
}

---------------------------------
package com.javarush.test.level15.lesson12.home04;

/**
 * Created by Кира on 22.04.2016.
 */
public class Sun implements Planet{

    private static Sun instance;

    private Sun(){}

    public static Sun getInstance(){
        if(instance == null) {
            instance = new Sun();
        }
        return instance;
    }
}
-----------------------------------
package com.javarush.test.level15.lesson12.home04;

/**
 * Created by Кира on 22.04.2016.
 */
public class Moon implements Planet {

    private static Moon instance;

    private Moon(){}

    public static Moon getInstance(){
        if(instance == null) {
            instance = new Moon();
        }
        return instance;
    }
}

------------------------------------
package com.javarush.test.level15.lesson12.home04;

/**
 * Created by Кира on 22.04.2016.
 */
public class Earth implements Planet {

    private static Earth instance;

    private Earth(){}

    public static Earth getInstance(){
        if(instance == null) {
            instance = new Earth();
        }
        return instance;
    }
}
----------------------------------------








package com.javarush.test.level15.lesson12.home05;

/* Перегрузка конструкторов
1. В классе Solution создайте по 3 конструктора для каждого модификатора доступа.
2. В отдельном файле унаследуйте класс SubSolution от класса Solution.
3. Внутри класса SubSolution создайте конструкторы командой Alt+Insert -> Constructors.
4. Исправьте модификаторы доступа конструкторов в SubSolution так, чтобы они соответствовали конструкторам класса Solution.
*/

public class Solution {
    public Solution(Character f) {}
    public Solution(Object i) {}
    public Solution(String i) {}
    protected Solution(Integer i) {}
    protected Solution(Double i) {}
    protected Solution(Float i) {}
    Solution(char i) {}
    Solution(int i) {}
    Solution(double i) {}
    private Solution(float i) {}
    private Solution(byte i) {}
    private Solution(short i) {}
    // + Вспомогательные конструкторы для вызова из дочеррнего класса private конструкторов в этом базовом классе
}
-----------
package com.javarush.test.level15.lesson12.home05;

/**
 * Created by Кира on 22.04.2016.
 */
public class SubSolution extends Solution{

    public SubSolution(Character f) {
        super(f);
    }

    SubSolution(char i) {
        super(i);
    }

    protected SubSolution(Double i) {
        super(i);
    }

    SubSolution(double i) {
        super(i);
    }

    protected SubSolution(Float i) {
        super(i);
    }

    SubSolution(int i) {
        super(i);
    }

    protected SubSolution(Integer i) {
        super(i);
    }

    public SubSolution(Object i) {
        super(i);
    }

    public SubSolution(String i) {
        super(i);
    }

    private SubSolution(float i) {
        super(i);
    }
    private SubSolution(byte i) {
        super(i);
    }
    private SubSolution(short i) {
        super(i);
    }

}







package com.javarush.test.level15.lesson12.home06;

/* Порядок загрузки переменных
Разобраться, что в какой последовательности инициализируется.
Исправить порядок инициализации данных так, чтобы результат был следующим:
static void init()
Static block
public static void main
non-static block
static void printAllFields
0
null
Solution constructor
static void printAllFields
6
First name
*/

public class Solution {


    {
        System.out.println("non-static block");
        printAllFields(this);
    }

    public int i = 6;

    public String name = "First name";
    static {
        init();
    }

    public Solution() {
        System.out.println("Solution constructor");
        printAllFields(this);
    }

    public static void init() {
        System.out.println("static void init()");
    }

    public static void main(String[] args) {
        System.out.println("Static block");
        System.out.println("public static void main");
        Solution s = new Solution();
    }

    public static void printAllFields(Solution obj) {
        System.out.println("static void printAllFields");
        System.out.println(obj.i);
        System.out.println(obj.name);
    }
}








package com.javarush.test.level15.lesson12.home07;

import java.io.*;
import java.util.ArrayList;
import java.util.List;


/* Файл в статическом блоке
1. Инициализируй константу Constants.FILE_NAME полным путем к файлу с данными, который содержит несколько строк.
2. В статическом блоке считай из файла с именем Constants.FILE_NAME все строки и добавь их по-отдельности в List lines.
3. Закрой поток ввода методом close().
*/

public class Solution {

    public static List<String> lines = new ArrayList<String>();

    static {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(Constants.FILE_NAME));
            String buf;
            while ((buf = reader.readLine()) != null){
                lines.add(buf);
            }
        } catch (IOException ee) {
            ee.printStackTrace();
        } finally {
            try {
                if (reader != null) reader.close();
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        System.out.println(lines);
    }
}
----------------------------------------
package com.javarush.test.level15.lesson12.home07;

public class Constants{

    public static String FILE_NAME = "F://fgg.txt";

}







package com.javarush.test.level15.lesson12.home08;

/* Дебаг, дебаг, и еще раз дебаг
Программа выводит 0 9, а должна 6 9. Найди одну! ошибку и исправь.
Используй дебаг. Для этого поставь breakpoint-ы(Ctrl+F8), потом зайди в меню Run -> Debug.
F9 - выполнение кода до следующего breakpoint-а
F8 - переход к следующей строке кода
*/

public class Solution {
    public static void main(String[] args) {
        new B(6);
    }

    public static class A {
        private int f1 = 0;

        public A(int f1) {
            this.f1 = f1;
            initialize();
        }

        private void initialize() {
            System.out.println(f1);
        }
    }

    //Конструктор класса B вызывает конструктор класса A
    //Конструктор класса A вызывает initialize() класса A
    //Конструктор класса B продолжает работу и
    //вызывает initialize() класса B.

    public static class B extends A {
        protected int f1 = 3;

        public B(int f1) {
            super(f1);
            this.f1 += f1;
            initialize();
        }

        protected void initialize() {
            System.out.println(f1);
        }
    }
}






Модификация строк при копировании

Поскольку объекты класса String нельзя изменять, всякий раз, когда вам захочется модифицировать строку, 
придется либо копировать ее в объект типа StringBuffer, либо использовать один из описываемых ниже методов класса String, 
которые создают новую копию строки, внося в нее ваши изменения.

 

substring

Вы можете извлечь подстроку из объекта String, используя метод sub­string. 
Этот метод создает новую копию символов из того диапазона ин­дексов оригинальной строки, который вы указали при вызове. 
Можно указать только индекс первого символа нужной подстроки — тогда будут скопированы все символы, начиная с указанного и до конца строки. 
Также можно указать и начальный, и конечный индексы — при этом в новую строку будут скопированы все символы, начиная с первого ука­занного,
 и до (но не включая его) символа, заданного конечным индек­сом.

"Hello World".substring(6) -> "World" 

"Hello World".substring(3,8) -> "lo Wo"

 

concat

Слияние, или конкатенация строк выполняется с помощью метода concat. 
Этот метод создает новый объект String, копируя в него содер­жимое исходной строки и добавляя в ее конец строку, указанную в параметре метода.

"Hello".concat(" World") -> "Hello World"

 

replace

Методу replace в качестве параметров задаются два символа. Все сим­волы, совпадающие с первым, заменяются в новой копии строки на вто­рой символ.

"Hello".replace('l' , 'w') -> "Hewwo"

 

toLowerCase и toUpperCase

Эта пара методов преобразует все символы исходной строки в нижний и верхний регистр, соответственно.

"Hello".toLowerCase() -> "hello"

"Hello".toUpperCase() -> "HELLO"

 

trim

И, наконец, метод trim убирает из исходной строки все ведущие и замыкающие пробелы.

“Hello World    “.trirn() -> "Hello World"

 
 
 
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 indexOf и lastIndexOf

В класс String включена поддержка поиска определенного символа или подстроки, для этого в нем имеются два метода — indexOf и lastIndexOf. 
Каждый из этих методов возвращает индекс того символа, который вы хотели найти, либо индекс начала ис­комой подстроки. 
В любом случае, если поиск оказался неудачным ме­тоды возвращают значение -1. В очередном примере показано, как пользоваться различными вариантами 
этих методов поиска.

 

class indexOfDemo {

public static void main(String args[]) {

String s = "Now is the time for all good men " +

           "to come to the aid of their country " +

           "and pay their due taxes.";

System.out.println(s);

System.out.println("indexOf(t) = " + s.indexOf('f’));

System.out.println("lastlndexOf(t) = " + s.lastlndexOf('f’));

System.out.println("indexOf(the) = " + s.indexOf("the"));

System.out.println("lastlndexOf(the) = " + s.lastlndexOf("the"));

System.out.println("indexOf(t, 10) = " + s.indexOf('f’ , 10));

System.out.println("lastlndexOf(t, 50) = " + s.lastlndexOf('f’ , 50));

System.out.println("indexOf(the, 10) = " + s.indexOf("the", 10));

System.out.println("lastlndexOf(the, 50) = " + s.lastlndexOf("the", 50));

} }

 

Ниже приведен результат работы этой программы. Обратите внимание на то, что индексы в строках начинаются с нуля.

С:> java indexOfDemo

Now is the time for all good men to come to the aid of their country

and pay their due taxes.

indexOf(t) = 7

lastlndexOf(t) = 87

indexOf(the) = 7

lastlndexOf(the) = 77

index0f(t, 10) = 11

lastlndex0f(t, 50) = 44

index0f(the, 10) = 44

lastlndex0f(the, 50) = 44




















______________________________________________________________________--КРИВАЯ ВЕРСИЯ
package com.javarush.test.level15.lesson12.home09;

/* Парсер реквестов
Считать с консоли URl ссылку.
Вывести на экран через пробел список всех параметров (Параметры идут после ? и разделяются &, например, lvl=15).
URL содержит минимум 1 параметр.
Если присутствует параметр obj, то передать его значение в нужный метод alert.
alert(double value) - для чисел (дробные числа разделяются точкой)
alert(String value) - для строк

Пример 1
Ввод:
http://javarush.ru/alpha/index.html?lvl=15&view&name=Amigo
Вывод:
lvl view name

Пример 2
Ввод:
http://javarush.ru/alpha/index.html?obj=3.14&name=Amigo
Вывод:
obj name
double 3.14
*/


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Solution {
    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String s = reader.readLine();                           //создаем строку для чтения
        String allArguments = s.substring(s.indexOf("?") + 1);     //создаем строку для всех параметров(идут после ? )
        String[] parsed = allArguments.split("&");                   //разделяются &) массив "убирает" & и принимает все себе
        for (int i = 0; i < parsed.length; i++) {                  //шерстим циклом по ссылке без знака &
            String currentArg = parsed[i];                          //присаиваем новой строке все параметры, которые находим
            String[] currentArgArr = parsed[i].split("=");            //попутно пропускаем "="
            if(i == parsed.length - 1){                                 //если в итоге параметр 1 - печатаем его, единственного
                System.out.print(currentArgArr[0]);
            }else{                                                       //если 2 и более - печатаем их черех пробел
                System.out.print(currentArgArr[0] + " ");
            }
        }
        System.out.println();                                       //для перехода на сл строку
        for (int i = 0; i < parsed.length; i++) {                   //еще раз проходимся циклом по ссылке для определение obj
            String currentArg = parsed[i];                          
            String[] currentArgArr = parsed[i].split("=");  			
			
			
            try {
                if (currentArgArr[0].equals("obj")) {
                    if (currentArgArr[1].equals(Integer.parseInt(currentArg))) {
                        alert(Double.parseDouble(currentArgArr[1]));
                    }
                    if (!currentArgArr[1].equals(Integer.parseInt(currentArg))) {
                        alert(currentArgArr[1]);
                    }
                }
            }
                catch(Exception e){
                    System.out.println(e);
                }
            }
        }



    public static void alert(double value) {
        System.out.println("double " + value);
    }

    public static void alert(String value) {
        System.out.println("String " + value);
    }
}






package com.javarush.test.level15.lesson12.home10;

/* ООП - наследование
Исправить класс Hrivna так, чтоб избежать ошибку StackOverflowError, класс Money менять нельзя.
*/

public class Solution {
    public static void main(String[] args) {
        System.out.println(new Hrivna().getAmount());
    }

    public static abstract class Money {
        abstract Money getMoney();

        public Object getAmount() {
            return getMoney().getAmount();
        }
    }

    //add your code below - добавь код ниже
    public static class Hrivna extends Money {

        public double amount = 123d;

        public Hrivna getMoney() {
            return this;
        }

        public Object getAmount() {
            return amount;
        }
    }
}








package com.javarush.test.level17.lesson04.task04;

/* Синхронизированный президент
И снова Singleton паттерн - синхронизация в статическом блоке
Внутри класса OurPresident в статическом блоке создайте синхронизированный блок.
Внутри синхронизированного блока инициализируйте president.
*/

public class Solution {
    public static class OurPresident {

        private static OurPresident president;

        private OurPresident() {
        }

        public static OurPresident getOurPresident() {
            return president;
        }

        static{
            synchronized (OurPresident.class){
                System.out.println(president);
            }
        }
    }
}








package com.javarush.test.level17.lesson04.task05;

/* МВФ
Singleton паттерн - синхронизация в методе
IMF - это Международный Валютный Фонд
Внутри метода getFund создайте синхронизированный блок
Внутри синхронизированного блока инициализируйте переменную imf так, чтобы метод getFund всегда возвращал один и тот же объект
*/

public class Solution {
    public static class IMF {

        private static IMF imf;

        public static IMF getFund() {
            synchronized (IMF.class){
                imf = imf;
            }
            return imf;
        }

        private IMF() {
        }
    }
}







package com.javarush.test.level17.lesson06.task01;

import java.util.ArrayList;
import java.util.List;

/* Заметки для всех
Класс Note будет использоваться нитями.
Поэтому сделай так, чтобы лист notes находился в общей памяти
*/

public class Solution {

    public static class Note extends Thread {

        public volatile List<String> notes = new ArrayList<String>();

        public void addNote(int index, String note) {
            System.out.println("Сейчас будет добавлена заметка [" + note + "] На позицию " + index);
            notes.add(index, note);
            System.out.println("Уже добавлена заметка [" + note + "]");
        }

        public void removeNote(int index) {
            System.out.println("Сейчас будет удалена заметка с позиции " + index);
            String note = notes.remove(index);
            System.out.println("Уже удалена заметка [" + note + "] с позиции " + index);
        }
    }
}














package com.javarush.test.level17.lesson06.task02;

/* Предложения
Не используя synchronized сделайте так, чтобы количество сделанных и принятых предложений было одинаковым.
*/

public class Solution {
    public static volatile int proposal = 0;

    public static void main(String[] args) {
        new MakeProposal().start();
        new AcceptProposal().start();
    }

    public static class MakeProposal extends Thread {
        @Override
        public void run() {
            int thisProposal = proposal;

            while (proposal < 10) {
                System.out.println("Сделано предложение №" + (thisProposal + 1));
                proposal = ++thisProposal;
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static class AcceptProposal extends Thread {
        @Override
        public void run() {
            int thisProposal = proposal;

            while (thisProposal < 10) {
                if (thisProposal != proposal) {
                    System.out.println("Принято предложение №" + proposal);
                    thisProposal = proposal;
                }
            }
        }
    }
}



















_________________________________________________________________________________________DELEGATE METHODS
package com.javarush.test.level17.lesson10.home01;

import java.util.*;

/* Общий список
1. Изменить класс Solution так, чтобы он стал списком. (Необходимо реализовать интерфейс java.util.List).
2. Список Solution должен работать только с целыми числами Long.
3. Воспользуйтесь полем original.
4. Список будет использоваться нитями, поэтому позаботьтесь, чтобы все методы были синхронизированы.
*/

public class Solution implements List<Long> {


    private ArrayList<Long> original = new ArrayList<Long>();

    @Override
    public boolean add(Long aLong) {
        return original.add(aLong);
    }

    @Override
    public void add(int index, Long element) {
        original.add(index, element);
    }

    @Override
    public boolean addAll(Collection<? extends Long> c) {
        return original.addAll(c);
    }

    @Override
    public boolean addAll(int index, Collection<? extends Long> c) {
        return original.addAll(index, c);
    }

    @Override
    public void clear() {
        original.clear();
    }

    @Override
    public Object clone() {
        return original.clone();
    }

    @Override
    public boolean contains(Object o) {
        return original.contains(o);
    }

    public void ensureCapacity(int minCapacity) {
        original.ensureCapacity(minCapacity);
    }

    @Override
    public Long get(int index) {
        return original.get(index);
    }

    @Override
    public int indexOf(Object o) {
        return original.indexOf(o);
    }

    @Override
    public boolean isEmpty() {
        return original.isEmpty();
    }

    @Override
    public Iterator<Long> iterator() {
        return original.iterator();
    }

    @Override
    public int lastIndexOf(Object o) {
        return original.lastIndexOf(o);
    }

    @Override
    public ListIterator<Long> listIterator() {
        return original.listIterator();
    }

    @Override
    public ListIterator<Long> listIterator(int index) {
        return original.listIterator(index);
    }

    @Override
    public Long remove(int index) {
        return original.remove(index);
    }

    @Override
    public boolean remove(Object o) {
        return original.remove(o);
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return original.removeAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return original.retainAll(c);
    }

    @Override
    public Long set(int index, Long element) {
        return original.set(index, element);
    }

    @Override
    public int size() {
        return original.size();
    }

    @Override
    public List<Long> subList(int fromIndex, int toIndex) {
        return original.subList(fromIndex, toIndex);
    }

    @Override
    public Object[] toArray() {
        return original.toArray();
    }

    @Override
    public <T> T[] toArray(T[] a) {
        return original.toArray(a);
    }

    public void trimToSize() {
        original.trimToSize();
    }

    @Override
    public boolean equals(Object o) {
        return original.equals(o);
    }

    @Override
    public int hashCode() {
        return original.hashCode();
    }

    @Override
    public boolean containsAll(Collection<?> c) {
        return original.containsAll(c);
    }

    @Override
    public String toString() {
        return original.toString();
    }
}














Сортировка в Java - легко!

Временами сортировка массивов простых типов в Java заставляет нас потрудиться. Не говоря о сортировке массивов объектов.
 Теперь же мы можем сортировать и массивы простых типов и массивы объектов, написав относительно малый код, с помощью интерфейса Comparable.

java.util.Comparable это класс, содержащий определение правильного порядка двух объектов. Это применимо только для небольшого числа классов, 
которые по умолчанию реализованы в интерфейсе Comparable. Один из них - это класс String. В реализации интерфейса Comparable класс String 
перегружает метод compareTo(Object obj). Метод compareTo(Object obj) возвращает отрицательное integer, ноль или положительное integer, когда 
текущее значение меньше чем, равно, или больше чем полученный объект.

Ваша работа уже выполнена за вас в классе String. Тем не менее, если вы хотите обеспечить способность сортировки ваших собственных классов, 
тогда вы должны реализовать(implement) Comparable и перегружать compareTo(Object obj) самостоятельно. Ниже следует простой пример, в котором 
определен класс Student. Каждый Student содержит studentid, first_name, last_name. Согласно нашим спецификациям Student можно сортировать по student_id.


import java.util.*;

public class Student implements Comparable
{
  public int student_id;
  public String last_name;
  public String first_name;
                           
  public Student(int student_id, String last_name, String first_name)
  {
    this.student_id = student_id;
    this.last_name = last_name;
    this.first_name = first_name;  
  }
                           
  /* Перегрузка метода compareTo */
                       
  public int compareTo(Object obj)
  {
    Student tmp = (Student)obj;
    if(this.student_id < tmp.student_id)
    {
      /* текущее меньше полученного */
      return -1;
    }   
    else if(this.student_id > tmp.student_id)
    {
      /* текущее больше полученного */
      return 1;
    }
    /* текущее равно полученному */
    return 0;  
  }

}
Теперь, когда в классе Student перегружен метод compareTo(Object obj), мы легко можем сортировать массив объектов типа Student. Здесь использовался класс 
java.util.Array и его статический метод sort. Метод main добавлен, чтобы продемонстрировать, как это будет работать.


public static void main(String[] args)
{
  /* Создание массива объектов Student */
                     
  Student[] students = new Student[3];
  students[0] = new Student(52645,"Smith","Bob");
  students[1] = new Student(98765,"Jones","Will");
  students[2] = new Student(1354,"Johnson","Matt");
                           
  /* Сортировка массива */
  Arrays.sort(students);
                           
  /* Печать отсортированных значений */
                           
  for(int i = 0; i < students.length; i++)
  {
    System.out.println(students[i].student_id + 
    students[i].last_name + students[i].first_name);
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
package com.javarush.test.level17.lesson10.home02;

/* Comparable
Реализуйте интерфейс Comparable<Beach> в классе Beach, который будет использоваться нитями.
*/

public class Beach implements Comparable<Beach> {

    private volatile String name;      //название
    private volatile float distance;   //расстояние
    private volatile int quality;    //качество

    public Beach(String name, float distance, int quality) {
        this.name = name;
        this.distance = distance;
        this.quality = quality;
    }


    public String getName() {
        return name;
    }

    public synchronized void setName(String name) {
        this.name = name;
    }

    public float getDistance() {
        return distance;
    }

    public synchronized void setDistance(float distance) {
        this.distance = distance;
    }

    public int getQuality() {
        return quality;
    }

    public synchronized void setQuality(int quality) {
        this.quality = quality;
    }

    @Override
    synchronized public int compareTo(Beach o) {
            int distIndex = (int) (distance - o.getDistance());
            int qualIndex = quality - o.getQuality();
            return 10000 * name.compareTo(o.getName()) + 100 * distIndex + qualIndex;
        }
    }

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	_____________________________________________________________________________________СМОТРЕТЬ. АПТЕКА. ПРОГА НА РАНДОМ ВЫДАЧУ ЛЕКАРСТВ
package com.javarush.test.level17.lesson10.home03;

import java.util.ArrayList;
import java.util.List;

/* Аптека
Реализуй интерфейс Runnable в классах Apteka и Person.
Все нити должны работать пока не isStopped
Логика для Apteka: drugsController должен сделать закупку случайного лекарства (getRandomDrug) в количестве (getRandomCount) и подождать 300 мс
Логика для Person: drugsController должен сделать продажу случайного лекарства (getRandomDrug) в количестве (getRandomCount) и подождать 100 мс
Расставь synchronized там, где это необходимо
*/

public class Solution {

    public static DrugsController drugsController = new DrugsController();
    public static boolean isStopped = false;

    public static void main(String[] args) throws InterruptedException {
        Thread apteka = new Thread(new Apteka());
        Thread man = new Thread(new Person(), "Мужчина");
        Thread woman = new Thread(new Person(), "Женщина");

        apteka.start();
        man.start();
        woman.start();

        Thread.sleep(1000);
        isStopped = true;
    }

    public static class Apteka extends DrugsController implements Runnable {

        @Override
        public void run() {

            while(!isStopped){
                try {
                    drugsController.buy(getRandomDrug(), getRandomCount());
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }
    }

    public static class Person implements Runnable{

        @Override
        public void run() {

            while(!isStopped){
                try {
                    drugsController.sell(getRandomDrug(), getRandomCount());
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }
    }

    public static int getRandomCount() {
        return (int) (Math.random() * 3) + 1;
    }

    public static Drug getRandomDrug() {
        int index = (int) ((Math.random() * 1000) % (drugsController.allDrugs.size()));
        List<Drug> drugs = new ArrayList<>(drugsController.allDrugs.keySet());
        return drugs.get(index);
    }

    private static void waitAMoment() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
    }
}
------------------------------------------
package com.javarush.test.level17.lesson10.home03;

import java.util.HashMap;
import java.util.Map;

public class DrugsController {
    public static Map<Drug, Integer> allDrugs = new HashMap<Drug, Integer>();   // <Лекарство, Количество>

    static {
        Drug panadol = new Drug();
        panadol.setName("Панадол");
        allDrugs.put(panadol, 5);

        Drug analgin = new Drug();
        analgin.setName("Анальгин");
        allDrugs.put(analgin, 18);

        Drug placebo = new Drug();
        placebo.setName("Плацебо");
        allDrugs.put(placebo, 1);
    }

    public synchronized void sell(Drug drug, int count) {
        String name = Thread.currentThread().getName();
        if (!allDrugs.containsKey(drug)) {
            System.out.println("Нет в наличии");
        }
        Integer currentCount = allDrugs.get(drug);
        if (currentCount < count) {
            System.out.println(String.format("%s хочет %s %d шт. В наличии - %d", name, drug.getName(), count, currentCount));
        } else {
            allDrugs.put(drug, (currentCount - count));
            System.out.println(String.format("%s купил(а) %s %d шт. Осталось - %d", name, drug.getName(), count, (currentCount - count)));
        }
    }

    public synchronized void buy(Drug drug, int count) {
        System.out.println("Закупка " + drug.getName() + " " + count);
        if (!allDrugs.containsKey(drug)) {
            allDrugs.put(drug, 0);
        }
        Integer currentCount = allDrugs.get(drug);
        allDrugs.put(drug, (currentCount + count));
    }
}
---------------------------------------
package com.javarush.test.level17.lesson10.home03;

public class Drug {
    private String name;
    private String description;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}












package com.javarush.test.level17.lesson10.home04;

/* Синхронизированные методы
Установить модификатор synchronized только тем методам, которым необходимо.
Объект класса Solution будет использоваться нитями.
*/

public class Solution {

    private double param = Math.random();
    private StringBuilder sb = new StringBuilder();

    // method4() нужно синхронизировать, потому что создается новый объект типа StringBuilder(), который не имеет встроенной синхронизации
    // method5() не нужно синхронизировать, потому что создается новый объект типа StringBuffer(), который в себе имеет встроенную синхронизацию
    // method3() нужно синхронизировать, потому он доступается к общему private double param = Math.random(), который может использовать любой метод внутри класса Solution
    // method0() не нужно синхронизировать, потому он вызывает в себе method3(), который в свою очередь синхронизированный
    // method2() не нужно синхронизировать, потому что он не создает новых объектов и не изменяет общие ресурсы и не вызывает других методов
    // method1() нужно синхронизировать, потому что он вызывает в себе метод, который не синхронизированный, чтоб не получилось так что double i = method3()
    // будет иметь значение из другого потока, а не из вашего
    // method7() не нужно синхронизировать, потому что он не создает новых объектов и не изменяет общие ресурсы и не вызывает других методов
    // method6() нужно синхронизировать, потому что он вызывает в себе метод, который не синхронизированный, и у него есть вывод в консоль

    private void method0() {
        double i = method3();
    }

    protected synchronized void method1(String param1) {
        Solution solution = new Solution();
        solution.method0();
    }

    public void method2(int param1) {
        param1++;
    }

    synchronized double method3() {
        double random = Math.random();
        param += 40.7;
        return random + param;
    }

    private synchronized void method4() {
        sb.append(1).append(1).append(1).append(1);
    }

    protected void method5(String param2) {
        new StringBuffer().append(param2).append(param2).append(param2);
    }

    public synchronized String method6(int param2) {
        System.out.println("Thinking....");
        method7(5e-2);
        sb = new StringBuilder("Got it!.");
        return sb.toString();
    }

    String method7(double param2) {
        return "" + param2;
    }

}








______________________________________________________________________МАКСИМАЛЬНЫЙ БАЙТ
package com.javarush.test.level18.lesson03.task01;

import java.io.FileInputStream;

/* Максимальный байт
Ввести с консоли имя файла
Найти максимальный байт в файле, вывести его на экран.
Закрыть поток ввода-вывода
*/

public class Solution {
    public static void main(String[] args) throws Exception {


        FileInputStream fileInputStream = new FileInputStream("F://fgg.txt");

        int maxByte = 0;

        while (fileInputStream.available() > 0){
            int readByte = fileInputStream.read();
            if (readByte > maxByte){
                maxByte = readByte;
            }
        }
        System.out.println(maxByte);


        fileInputStream.close();

    }
}








!!!!!!!synchronize выставляет табличку занято для того метода или переменной, перед чем он выставлен, если с ним кто-то начинает работу.!!!!!!!!!!!!!!!!!!!!!!!!!!!

package com.javarush.test.level17.lesson10.home05;

/* Лишняя синхронизация
synchronized существенно замедляет программу, поэтому убери избыточность synchronized внутри методов
*/

public class Solution {
    char[] value;
    int count;

    public Solution append(CharSequence s) {
            if (s == null) {

                    s = "null";

            }

            if (s instanceof String) {
                    return this.append((String) s);

            }

            if (s instanceof Solution) {

                    return this.appendThis((Solution) s);

            }
        return this.append(s);
    }

    public synchronized Solution appendThis(Solution s) {
        return this;
    }

    private static final java.io.ObjectStreamField[] serialPersistentFields =
            {
                    new java.io.ObjectStreamField("value", char[].class),
                    new java.io.ObjectStreamField("count", Integer.TYPE),
                    new java.io.ObjectStreamField("shared", Boolean.TYPE),
            };

    private synchronized void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
        java.io.ObjectOutputStream.PutField fields = s.putFields();
            fields.put("value", value);
            fields.put("count", count);
            fields.put("shared", false);
            s.writeFields();

    }

    private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
            java.io.ObjectInputStream.GetField fields = s.readFields();
            value = (char[]) fields.get("value", null);
            count = fields.get("count", 0);
    }
}











package com.javarush.test.level17.lesson10.home06;

/* Глажка
И снова быт...
Поставьте один synchronized, чтобы diana и igor гладили по-очереди, ведь утюг всего один!
Подсказка: использовать блокировку на уровне класса.
*/

public class Solution {
    public static void main(String[] args) {
        Person diana = new Person("Diana");
        Person igor = new Person("Igor");
    }

    public static class Person extends Thread { //Человек

        public Person(String name) {
            super(name);
            start();
        }

        @Override
        public void run() {
            synchronized (Iron.class) {
                Iron iron = takeIron();
                Clothes clothes = takeClothes();
                ironing(iron, clothes);
                returnIron();
            }
        }

        protected Iron takeIron() {
            System.out.println("Taking an Iron");
            return new Iron();
        }

        protected Iron returnIron() {
            System.out.println("Returning the Iron");
            return new Iron();
        }

        protected Clothes takeClothes() {
            return new Clothes("T-shirt");
        }

        protected void ironing(Iron iron, Clothes clothes) {
            System.out.println(getName() + "'s ironing the " + clothes.name);
        }
    }

    public static class Iron {
    } //Утюг

    public static class Clothes {//Одежда
        String name;

        public Clothes(String name) {
            this.name = name;
        }
    }
}









package com.javarush.test.level17.lesson10.home07;

import java.util.HashMap;
import java.util.Map;

/* ApplicationContext
ApplicationContext будет доступен множеству нитей.
Сделать так, чтобы данные не терялись: подумай, какое ключевое слово необходимо поставить и где.
*/

public abstract class ApplicationContext<GenericsBean extends Bean> {
    private Map<String, GenericsBean> container = new HashMap<String, GenericsBean>();
    //Map<Name, some class implemented Bean interface>


    protected ApplicationContext() {
        parseAllClassesAndInterfaces();
    }

    public synchronized GenericsBean getByName(String name) {
          return container.get(name);
    }

    public synchronized GenericsBean removeByName(String name) {
        return container.remove(name);
    }

    protected abstract void parseAllClassesAndInterfaces();
}
-------------
package com.javarush.test.level17.lesson10.home07;

public interface Bean {   //это интерфейс-маркер
}










package com.javarush.test.level17.lesson10.home08;

/* Банкомат
Разберись, как работает программа
Во время тестирования лог содержит следующее:
.....
Добавляем 100, на счету 1100
Добавляем 100, на счету 1200
Тратим 1000, на счету 100
Недостаточно денег
.....

Создан баг: При списании денег со счета теряются деньги
Найти и исправить ошибку
*/

public class Bankomat {

    static BankAccount account = new BankAccount("Amigo");

    public static volatile boolean isStopped;

    public static void main(String[] args) throws InterruptedException {
        addMoney.start();
        new SpendThread();
        new SpendThread();
        new SpendThread();
        Thread.sleep(4000);
        isStopped = true;
    }

    private static Thread addMoney = new Thread() {
        @Override
        public void run() {
            while (!isStopped) {
                account.deposit("100");            //кладем на счет
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    };


    public static class SpendThread extends Thread {
        public SpendThread() {
            start();
        }

        @Override
        public void run() {
            while (!isStopped) {
                try {
                    account.withdraw("1000");             //снимаем со счета
                } catch (NotEnoughMoneyException e) {
                    System.out.println("Недостаточно денег");
                    isStopped = true;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }

    ;
}
-------------------------------------------------------------
package com.javarush.test.level17.lesson10.home08;

import java.math.BigDecimal;

public class BankAccount {
    private BigDecimal balance;
    private String owner;

    public BankAccount(String owner) {
        this(BigDecimal.valueOf(1000), owner);
    }

    public BankAccount(BigDecimal balance, String owner) {
        this.balance = balance;
        this.owner = owner;
    }

    public synchronized void deposit(BigDecimal money) {
        BigDecimal newBalance = balance.add(money);
        System.out.println("Добавляем " + money + ", на счету " + newBalance);
        balance = newBalance;
    }

    public synchronized void withdraw(BigDecimal money) throws NotEnoughMoneyException {
        BigDecimal newBalance = balance.subtract(money);

        if (newBalance.compareTo(BigDecimal.ZERO) < 0) throw new NotEnoughMoneyException();

        balance = newBalance;
        System.out.println("Тратим " + money + ", на счету " + balance);
    }

    public void deposit(String money) {
        deposit(new BigDecimal(money));
    }

    public void withdraw(String money) throws NotEnoughMoneyException {
        withdraw(new BigDecimal(money));
    }
}
--------------------------------------------------------------------
package com.javarush.test.level17.lesson10.home08;

public class NotEnoughMoneyException extends Exception {
}













package com.javarush.test.level17.lesson10.home10;

/* Посчитаем
1. Сделай так, чтобы результат успел посчитаться для всех элементов массива values НЕ используя Thread.sleep
2. Исправь synchronized блок так, чтобы массив values заполнился значением 1
*/

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        Counter counter1 = new Counter();
        Counter counter2 = new Counter();
        Counter counter3 = new Counter();
        Counter counter4 = new Counter();

        counter1.start();
        counter1.join();
        counter2.start();
        counter2.join();
        counter3.start();
        counter3.join();
        counter4.start();
        counter4.join();


        for (int i = 1; i <= 100; i++) {
            if (values[i] != 1) {
                System.out.println("Массив values содержит элементы неравные 1");
                break;
            }
        }
    }

    public static Integer count = 0;
    public static int[] values = new int[105];

    static {
        for (int i = 0; i < 105; i++) {
            values[i] = 0;
        }
    }

    public static void incrementCount() {
        count++;
    }

    public static int getCount() {
        return count;
    }

    public static class Counter extends Thread {
        @Override
        public void run() {
            do {
                synchronized (Counter.class) {
                    incrementCount();
                    values[getCount()]++;
                }

                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                }
            } while (getCount() < 100);
        }
    }
}










package com.javarush.test.level18.lesson03.task02;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;

/* Минимальный байт
Ввести с консоли имя файла
Найти минимальный байт в файле, вывести его на экран.
Закрыть поток ввода-вывода
*/

public class Solution {
    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        FileInputStream fileInputStream = new FileInputStream(reader.readLine());

        int min= 127;
        while (fileInputStream.available()>0){
            int data = fileInputStream.read();
            if( data <= min) min = data;
        }

        System.out.println(min);

    }
}








package com.javarush.test.level18.lesson03.task01;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;

/* Максимальный байт
Ввести с консоли имя файла
Найти максимальный байт в файле, вывести его на экран.
Закрыть поток ввода-вывода
*/

public class Solution {
    public static void main(String[] args) throws Exception {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        FileInputStream fileInputStream = new FileInputStream(reader.readLine());

        int maxByte = 0;

        while (fileInputStream.available() > 0){
            int readByte = fileInputStream.read();
            if (readByte > maxByte){
                maxByte = readByte;
            }
        }
        System.out.println(maxByte);


        fileInputStream.close();
    }
}









_____________________________________________________________________________________________СМОТРЕТЬ МАКСИМАЛЬН КОЛИЕСТВО ПОВТОРОВ!!!!!!!!
package com.javarush.test.level18.lesson03.task03;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/* Самые частые байты
Ввести с консоли имя файла
Найти байт или байты с максимальным количеством повторов
Вывести их на экран через пробел
Закрыть поток ввода-вывода
*/

public class Solution {
    public static void main(String[] args) throws Exception {

        Map<Integer, Integer> list = new HashMap<Integer, Integer>();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        FileInputStream fileInputStream = new FileInputStream(bufferedReader.readLine());
            /*если байта нет добавляем в МАП если есть то к value этого байты добавляем 1*/
        while (fileInputStream.available() > 0) {
            int key = fileInputStream.read();
            if (list.containsKey(key)) {
                int value = list.get(key);
                list.put(key, ++value);
            } else
                list.put(key, 1);
        }
        bufferedReader.close();
        fileInputStream.close();
            /*находим байт с наибольшим повторением(value)*/
        int tempValue = 0;
        for (Map.Entry<Integer, Integer> l : list.entrySet()) {
            if (tempValue < l.getValue()) {
                tempValue = l.getValue();
            }
        }
            /*Выводим байт с наибольшим повторением, если таких байт несколько то выводим их*/
        for (Map.Entry<Integer, Integer> l : list.entrySet()) {
            if (l.getValue() == tempValue)
                System.out.print(l.getKey() + " ");
        }
        }
}









package com.javarush.test.level18.lesson03.task04;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/* Самые редкие байты
Ввести с консоли имя файла
Найти байт или байты с минимальным количеством повторов
Вывести их на экран через пробел
Закрыть поток ввода-вывода
*/

public class Solution {
    public static void main(String[] args) throws Exception {
        Map<Integer, Integer> list = new HashMap<>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        FileInputStream fileInputStream = new FileInputStream(reader.readLine());

        while(fileInputStream.available() > 0){
            int key = fileInputStream.read();
            if(list.containsKey(key)){
                int value = list.get(key);
                list.put(key, ++value);
            }
             else
            list.put(key, 1);
        }

        fileInputStream.close();
        reader.close();

        int tempValue = 127;
        for(Map.Entry <Integer, Integer> l : list.entrySet()){
            if(tempValue > l.getValue()){
                tempValue = l.getValue();
            }
        }
        for(Map.Entry<Integer, Integer> l : list.entrySet()){
            if (l.getValue() == tempValue)
                System.out.print(l.getKey() + " ");
        }
    }
}











package com.javarush.test.level20.lesson02.task01;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/* Читаем и пишем в файл: Human
Реализуйте логику записи в файл и чтения из файла для класса Human
Поле name в классе Human не может быть пустым
В файле your_file_name.tmp может быть несколько объектов Human
Метод main реализован только для вас и не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        //you can find your_file_name.tmp in your TMP directory or fix outputStream/inputStream according to your real file location
        //вы можете найти your_file_name.tmp в папке TMP или исправьте outputStream/inputStream в соответствии с путем к вашему реальному файлу
        try {

            File your_file_name = File.createTempFile("your_file_name", null);
            OutputStream outputStream = new FileOutputStream("d:/ivanov.txt");
            InputStream inputStream = new FileInputStream("d:/ivanov.txt");

            Human ivanov = new Human("Ivanov", new Asset("home"), new Asset("car"));

            ivanov.save(outputStream);
            outputStream.flush();

            Human somePerson = new Human();
            somePerson.load(inputStream);
            //check here that ivanov equals to somePerson - проверьте тут, что ivanov и somePerson равны

            inputStream.close();

        } catch (IOException e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with my file");
        } catch (Exception e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with save/load method");
        }
    }


    public static class Human {
        public String name;
        public List<Asset> assets = new ArrayList<>();


        public Human() {
        }

        public Human(String name, Asset... assets) {
            this.name = name;
            if (assets != null) {
                this.assets.addAll(Arrays.asList(assets));
            }
        }

        public void save(OutputStream outputStream) throws Exception {
            //PrintWriter printWriter = new PrintWriter(outputStream);
            if (null != name && !name.isEmpty())
            {
                outputStream.write(name.getBytes());
                outputStream.write("\r\n".getBytes());
            }else return;

            String isAssetsPresent = assets.isEmpty() ?  "no" : "yes";

            outputStream.write(String.valueOf(isAssetsPresent).getBytes());

            outputStream.write("\r\n".getBytes());

            if (isAssetsPresent.equals("yes"))
            {
                outputStream.write(String.valueOf(assets.size()).getBytes());
                outputStream.write("\r\n".getBytes());
                for (Asset asset : assets)
                {
                    outputStream.write(asset.getName().getBytes());
                    outputStream.write("\r\n".getBytes());
                    outputStream.write(String.valueOf(asset.getPrice()).getBytes());
                    outputStream.write("\r\n".getBytes());
                }
            }
        }
        public void load(InputStream inputStream) throws Exception {
            while ( inputStream.available()>0)
            {
                this.name = readLine(inputStream);
                String isAssetsPresent = "";
                isAssetsPresent = readLine(inputStream);
                if(isAssetsPresent.equals("yes"))
                {
                    String s = "";
                    int size = Integer.parseInt(readLine(inputStream));
                    //if (size != 0) assets.removeAll(assets);
                    for (int i = 0; i < size; i++)
                    {
                        s = readLine(inputStream);
                        Asset as = new Asset(s);
                        try
                        {
                            as.setPrice(Double.parseDouble(readLine(inputStream)));
                        }
                        catch (Exception e)
                        {
                        }
                        this.assets.add(as);
                    }
                    return;
                }
                else if(isAssetsPresent.equals("no")){
                    //this.assets.size()
                    //System.out.println("AVALIABLE "+ inputStream.available());
                    return;
                }
            }
        }
        public String readLine(InputStream inputStream){
            String s ="";
            try
            {
                while (inputStream.available()>0){
                    char tmp = (char)inputStream.read();
                    if (tmp == '\r'){
                        tmp = (char)inputStream.read();
                        if (tmp == '\n'){
                            //inputStream.read();
                            break;
                        }
                    }
                    s+=tmp;
                }
            }
            catch (IOException e)
            {
                return null;
            }
            return s;
        }
    }
}

------------------------


package com.javarush.test.level20.lesson02.task01;

public class Asset {
    public Asset(String name) {
        this.name = name;
    }

    private String name;
    private double price;

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}















/* Читаем и пишем в файл: JavaRush
Реализуйте логику записи в файл и чтения из файла для класса JavaRush
В файле your_file_name.tmp может быть несколько объектов JavaRush
Метод main реализован только для вас и не участвует в тестировании
*/



package com.javarush.test.level20.lesson02.task02;

import java.util.Date;

public class User {
    private String firstName;
    private String lastName;
    private Date birthDate;
    private boolean isMale;
    private Country country;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public Date getBirthDate() {
        return birthDate;
    }

    public void setBirthDate(Date birthDate) {
        this.birthDate = birthDate;
    }

    public boolean isMale() {
        return isMale;
    }

    public void setMale(boolean male) {
        isMale = male;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }

    public static enum Country {
        UKRAINE("Ukraine"),
        RUSSIA("Russia"),
        OTHER("Other");

        private String name;

        private Country(String name) {
            this.name = name;
        }

        public String getDisplayedName() {
            return this.name;
        }
    }

}
-----------------------------------------------

БЕЗ ПРОВЕРОК РАБОТАЕТ НЕКОРРЕКТНО

package com.javarush.test.level20.lesson02.task02;

import java.io.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/* Читаем и пишем в файл: JavaRush
Реализуйте логику записи в файл и чтения из файла для класса JavaRush
В файле your_file_name.tmp может быть несколько объектов JavaRush
Метод main реализован только для вас и не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        //you can find your_file_name.tmp in your TMP directory or fix outputStream/inputStream according to your real file location
        //вы можете найти your_file_name.tmp в папке TMP или исправьте outputStream/inputStream в соответствии с путем к вашему реальному файлу
        try {
            File your_file_name = File.createTempFile("your_file_name", null);
            OutputStream outputStream = new FileOutputStream(your_file_name);
            InputStream inputStream = new FileInputStream(your_file_name);

            User ivan = new User();
            ivan.setFirstName("Ivan");
            ivan.setLastName("Ivanov");
            ivan.setBirthDate(new java.util.Date());
            ivan.setMale(true);
            ivan.setCountry(User.Country.RUSSIA);

            JavaRush javaRush = new JavaRush();
            javaRush.users.add(ivan);
            //initialize users field for the javaRush object here - инициализируйте поле users для объекта javaRush тут
            javaRush.save(outputStream);
            outputStream.flush();
            JavaRush loadedObject = new JavaRush();
            loadedObject.load(inputStream);
            //check here that javaRush object equals to loadedObject object - проверьте тут, что javaRush и loadedObject равны
            outputStream.close();
            inputStream.close();

        } catch (IOException e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with my file");
        } catch (Exception e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with save/load method");
        }
    }

    public static class JavaRush {

            public List<User> users = new ArrayList<User>();

            public void save(OutputStream outputStream) throws Exception {
                PrintWriter writer = new PrintWriter(outputStream);
                writer.println(users.size());
                for (User user : users) {
                    writer.println(user.getFirstName());
                    writer.println(user.getLastName());
                    writer.println(user.getBirthDate().getTime());
                    writer.println(user.isMale());
                    writer.println(user.getCountry().getDisplayedName());
                }
                writer.flush();
                //implement this method - реализуйте этот метод
            }

            public void load(InputStream inputStream) throws Exception {
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
                int size = Integer.parseInt(reader.readLine());
                if (size > 0) {
                    for (int i = 0; i < size; i++) {
                        User user = new User();
                        user.setFirstName(reader.readLine());
                        user.setLastName(reader.readLine());
                        user.setBirthDate(new Date(Long.parseLong(reader.readLine())));
                        user.setMale(Boolean.parseBoolean(reader.readLine()));
                        String s = reader.readLine();
                        if (s.equals("Ukraine")) {
                            user.setCountry(User.Country.UKRAINE);
                        } else if (s.equals("Russia")) {
                            user.setCountry(User.Country.RUSSIA);
                        } else if (s.equals("Other")) {
                            user.setCountry(User.Country.OTHER);
                        }
                        users.add(user);
                    }
                }
                //implement this method - реализуйте этот метод
            }
    }
}











PROPERTIES

package com.javarush.test.level20.lesson02.task03;

import java.io.*;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/* Знакомство с properties
В методе fillInPropertiesMap считайте имя файла с консоли и заполните карту properties данными из файла.
Про .properties почитать тут - http://ru.wikipedia.org/wiki/.properties
Реализуйте логику записи в файл и чтения из файла для карты properties.
*/
public class Solution {
    public static Map<String, String> properties = new HashMap<>();
    public final Properties p = new Properties();

    public static void main(String[] args) throws IOException {
        new Solution().fillInPropertiesMap();
        System.out.println(properties);

    }


    public void fillInPropertiesMap() throws IOException {
        //implement this method - реализуйте этот метод

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        FileInputStream fis = null;
        String fileName = null;
        try {
            fileName = reader.readLine();
            fis = new FileInputStream(fileName);
            load(fis);

        }catch (Exception e){
            e.printStackTrace();
        }
        finally { reader.close();
            try { fis.close();
            }catch (NullPointerException e){}}
    }

	//НАХЕР НЕ НУЖЕН В КОНТЕКСТЕ ЗАДАЧИ?
    public void save(OutputStream outputStream) throws Exception {
        //implement this method - реализуйте этот метод
        for(Map.Entry<String, String> entry : properties.entrySet()){
            String key = entry.getKey();
            String value = entry.getValue();
            p.setProperty(key, value);
        }
        p.store(outputStream, null);
    }

    public void load(InputStream inputStream) throws Exception {
        //implement this method - реализуйте этот метод
        p.load(inputStream);
        Enumeration e = p.propertyNames();

        while (e.hasMoreElements())
        {
            String key = (String) e.nextElement();
            properties.put(key, p.getProperty(key));
        }
    }
}













package com.javarush.test.level20.lesson02.task04;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

/* Читаем и пишем в файл статики
Реализуйте логику записи в файл и чтения из файла для класса ClassWithStatic
Метод load должен инициализировать объект включая статические поля c данными из файла
Метод main реализован только для вас и не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        //you can find your_file_name.tmp in your TMP directory or fix outputStream/inputStream according to your real file location
        //вы можете найти your_file_name.tmp в папке TMP или исправьте outputStream/inputStream в соответствии с путем к вашему реальному файлу
        try {

            File your_file_name = File.createTempFile("your_file_name", null);
            OutputStream outputStream = new FileOutputStream("d:/ivanov.properties");
            InputStream inputStream = new FileInputStream("d:/ivanov.properties");

            ClassWithStatic classWithStatic = new ClassWithStatic();
            classWithStatic.i = 3;
            classWithStatic.j = 4;
            classWithStatic.save(outputStream);
            outputStream.flush();

            ClassWithStatic loadedObject = new ClassWithStatic();
            loadedObject.staticString = "something";
            loadedObject.i = 6;
            loadedObject.j = 7;

            loadedObject.load(inputStream);
            //check here that classWithStatic object equals to loadedObject object - проверьте тут, что classWithStatic и loadedObject равны

            outputStream.close();
            inputStream.close();

        } catch (IOException e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with my file");
        } catch (Exception e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with save/load method");
        }
    }

    public static class ClassWithStatic {
        public static String staticString = "it's test static string";
        public int i;
        public int j;

        public void save(OutputStream outputStream) throws Exception {
            //implement this method - реализуйте этот метод
            PrintWriter writer = new PrintWriter(outputStream);
            if (staticString == null) {
                writer.println("null!");
            }
            if (staticString.length() > 0) {
                writer.println(staticString);
            }

            writer.println(i);
            writer.println(j);

            writer.flush();
        }

        public void load(InputStream inputStream) throws Exception {
            //implement this method - реализуйте этот метод

            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
            
            List<String> list = new ArrayList<String>();
            
            while (reader.ready())
            {
                list.add(reader.readLine());
            }

            staticString = list.get(0);
            this.i = Integer.parseInt(list.get(1));
            this.j = Integer.parseInt(list.get(2));

            reader.close();
        }

    }
}













package com.javarush.test.level20.lesson02.task05;

import java.io.*;
import java.lang.reflect.Field;

/* И еще раз о синхронизации
Разберитесь почему не работает метод main()
Реализуйте логику записи в файл и чтения из файла для класса Object
Метод load должен инициализировать объект данными из файла
Метод main реализован только для вас и не участвует в тестировании
*/
public class Solution {
    public static void main(java.lang.String[] args) throws Exception {
        //you can find your_file_name.tmp in your TMP directory or fix outputStream/inputStream according to your real file location
        //вы можете найти your_file_name.tmp в папке TMP или исправьте outputStream/inputStream в соответствии с путем к вашему реальному файлу
        try {
            File your_file_name = File.createTempFile("your_file_name", null);
            OutputStream outputStream = new FileOutputStream("d:/ivanov.properties");
            InputStream inputStream = new FileInputStream("d:/ivanov.properties");

            Object object = new Object();
            object.string1 = new String();   //string #1
            object.string2 = new String();   //string #2
            object.save(outputStream);
            outputStream.flush();

            Object loadedObject = new Object();
            loadedObject.string1 = new String(); //string #3
            loadedObject.string2 = new String(); //string #4

            loadedObject.load(inputStream);
            //check here that the object variable equals to loadedObject - проверьте тут, что object и loadedObject равны

            outputStream.close();
            inputStream.close();

        } catch (IOException e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with my file");
        } catch (Exception e) {
            //e.printStackTrace();
            System.out.println("Oops, something wrong with save/load method");
        }
    }


    public static class Object {
        public String string1;
        public String string2;

        public void save(OutputStream outputStream) throws Exception {
            PrintWriter writ = new PrintWriter(outputStream);
            writ.println(string1.number);
            writ.println(string2.number);
            writ.close();
        }
        
        public void load(InputStream inputStream) throws Exception {
            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
            
            Field f = string1.getClass().getDeclaredField("number");
            f.setAccessible(true);
            f.setInt(string1, Integer.parseInt(reader.readLine()));
            
            f = string2.getClass().getDeclaredField("number");
            f.setAccessible(true);
            f.setInt(string2, Integer.parseInt(reader.readLine()));
            
            reader.close();
        }
    }

    public static int countStrings;

    public static class String {
        private final int number;

        public String() {
            number = ++countStrings;
        }

        public void print() {
            System.out.println("string #" + number);
        }
    }
}

















package com.javarush.test.level20.lesson04.task01;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/* Как сериализовать?
Сделайте так, чтобы сериализация класса Human была возможной
*/
public class Solution {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Human human = new Human();

        File file = new File("d:/1.txt");
        FileOutputStream fos = new FileOutputStream("d:/1.txt");
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos);
        objectOutputStream.writeObject(human);
        fos.flush();
        fos.close();
        objectOutputStream.close();

        FileInputStream fis  = new FileInputStream("d:/1.txt");
        ObjectInputStream objectInputStream = new ObjectInputStream(fis);
        Object object = objectInputStream.readObject();
        fis.close();
        objectOutputStream.close();

        Human human1 = (Human) object;

        System.out.println(human1.toString());

    }

    public static class Human implements Serializable {
        public String name;
        public List<Asset> assets = new ArrayList<>();

        public Human() {
        }

        public Human(String name, Asset... assets) {
            this.name = name;
            if (assets != null) {
                this.assets.addAll(Arrays.asList(assets));
            }
        }
    }
}




package com.javarush.test.level20.lesson04.task01;

import java.io.Serializable;

public class Asset implements Serializable {
    public Asset(String name) {
        this.name = name;
    }

    private String name;
    private double price;

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}















package com.javarush.test.level20.lesson04.task02;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

/* Как сериализовать JavaRush?
Сделайте так, чтобы сериализация класса JavaRush была возможной
*/
public class Solution {


    public static void main(String[] args) throws IOException, ClassNotFoundException {

        JavaRush javaRush = new JavaRush();

        File file = new File("d:/3.txt");
        FileOutputStream fos = new FileOutputStream(file);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos);
        objectOutputStream.writeObject(javaRush);
        fos.flush();
        fos.close();
        objectOutputStream.close();



        FileInputStream fis = new FileInputStream(file);
        ObjectInputStream objectInputStream = new ObjectInputStream(fis);
        Object object = objectInputStream.readObject();
        fis.close();
        objectInputStream.close();

        JavaRush jr1 = (JavaRush) object;

        System.out.println(jr1);

    }



    public static class JavaRush implements Serializable {
        public List<User> users = new ArrayList<>();
    }
}


package com.javarush.test.level20.lesson04.task02;

import java.io.Serializable;
import java.util.Date;

public class User implements Serializable {
    private String firstName;
    private String lastName;
    private Date birthDate;
    private boolean isMale;
    private Country country;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public Date getBirthDate() {
        return birthDate;
    }

    public void setBirthDate(Date birthDate) {
        this.birthDate = birthDate;
    }

    public boolean isMale() {
        return isMale;
    }

    public void setMale(boolean male) {
        isMale = male;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }

    public static enum Country {
        UKRAINE("Ukraine"),
        RUSSIA("Russia"),
        OTHER("Other");

        private String name;

        private Country(String name) {
            this.name = name;
        }

        public String getDisplayedName() {
            return this.name;
        }
    }

}













package com.javarush.test.level20.lesson04.task03;

import java.io.*;

/* Как сериализовать Singleton?
Два десериализованных объекта singleton и singleton1 имеют разные ссылки в памяти, а должны иметь одинаковые.
В класс Singleton добавьте один метод (погуглите), чтобы после десериализации ссылки на объекты были равны.
Метод main не участвует в тестировании.
*/
public class Solution implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException {

        Singleton instance = Singleton.getInstance();

        //Serializing the singleton instance
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("d:/singleton.tmp"));
        oos.writeObject(instance);
        oos.close();

        //Recreating the instance by reading the serialized object data store
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("d:/singleton.tmp"));
        Singleton singleton = (Singleton) ois.readObject();
        ois.close();

        //Recreating the instance AGAIN by reading the serialized object data store
        ObjectInputStream ois2 = new ObjectInputStream(new FileInputStream("d:/singleton.tmp"));
        Singleton singleton1 = (Singleton) ois2.readObject();
        ois2.close();

        //The singleton behavior have been broken
        System.out.println("Instance reference check : " + singleton.getInstance());
        System.out.println("Instance reference check : " + singleton1.getInstance());
        System.out.println("=========================================================");
        System.out.println("Object reference check : " + singleton);
        System.out.println("Object reference check : " + singleton1);
    }

    public static class Singleton implements Serializable {
        private static Singleton ourInstance;

        public Object readResolve() throws Exception{

            return ourInstance;

        }

        public static Singleton getInstance() {
            if (ourInstance == null) {
                ourInstance = new Singleton();
            }
            return ourInstance;
        }

        private Singleton() {
        }


    }
}











package com.javarush.test.level20.lesson04.task04;

import java.io.*;

/* Как сериализовать static?
Сделайте так, чтобы сериализация класса ClassWithStatic была возможной
*/
public class Solution {

    public static Object object;

    public static void main(String[] args) throws Exception{

        ClassWithStatic classWithStatic = new ClassWithStatic();

        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream("d:/3.txt"));
        oout.writeObject(classWithStatic);
        oout.flush();
        oout.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream("d:/3.txt"));
        object = oin.readObject();

        ClassWithStatic classWithStatic1 = (ClassWithStatic) object;

        System.out.println(classWithStatic1);
    }

    public static class ClassWithStatic implements Serializable {
        public static String staticString = "it's test static string";
        public int i;
        public int j;
    }
}














package com.javarush.test.level20.lesson04.task05;

import java.io.*;

/* Как сериализовать что-то свое?
Сделайте так, чтобы сериализация класса Object была возможной
*/
public class Solution {

    public static void main(java.lang.String[] args) throws Exception{

        Object object = new Object();

        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("d:/3.txt"));
        out.writeObject(object);

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream("d:/3.txt"));
        java.lang.Object object1 = oin.readObject();

        Object objectNew = (Object) object1;


        System.out.println(objectNew);
    }


    public Solution() throws IOException {
    }

    public static class Object implements Serializable {
        public String string1;
        public String string2;
    }

    public static int countStrings;

    public static class String implements Serializable {
        private final int number;

        public String() {
            number = ++countStrings;
        }

        public void print() {
            System.out.println("string #" + number);
        }
    }
}
















package com.javarush.test.level20.lesson07.task01;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/* Externalizable для апартаментов
Реализуйте интерфейс Externalizable для класса Apartment
Подумайте, какие поля не нужно сериализовать.
*/
public class Solution {

    public static class Apartment implements Externalizable {

        private String address;
        private int year;

        /**
         * Mandatory public no-arg constructor.
         */
        public Apartment() {
            super();
        }

        public Apartment(String adr, int y) {
            address = adr;
            year = y;
        }

        /**
         * Prints out the fields. used for testing!
         */
        public String toString() {
            return("Address: " + address + "\n" + "Year: " + year);
        }

        @Override
        public void writeExternal(ObjectOutput out) throws IOException {

            out.writeObject(address);
            out.writeInt(year);
        }

        @Override
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

            address = (String) in.readObject();
            year = in.readInt();
        }
    }
}












package com.javarush.test.level20.lesson07.task02;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/* OutputToConsole
Класс OutputToConsole должен сериализоваться с помощью интерфейса Externalizable.
Подумайте, какие поля не нужно сериализовать.
Исправьте ошибку.
Сигнатуры методов менять нельзя.
*/
public class Solution {
    public static String greeting = "Hello world";

    /**
     * OutputToConsole is the inner base class for improving your attentiveness.
     * An OutputToConsole object encapsulates the information needed
     * for the displaying [greeting] variable to the console by character.
     * @author JavaRush
     */
    public static class OutputToConsole implements Externalizable {
        private int i = 8;

        /**
         * @param out A stream for an externalization
         * @throws java.io.IOException
         */
        @Override
        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeInt(i);
        }

        /**
         * @param in A stream for a de-externalization
         * @throws java.io.IOException
         * @throws ClassNotFoundException
         */
        @Override
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            i = in.readInt();
        }

        /**
         * Class constructor specifying fake private field [i].
         */
        public OutputToConsole(int ii) {
            this.i = ii;
        }

        public OutputToConsole(){
            
        }

        /**
         * Outputs to the console a static field of Solution class [greeting].
         * Has to use [charAt] method of String class
         */
        public void outputToConsole(int ii) {
            for (int i = 0; i < greeting.length(); i++)  {
                System.out.write(greeting.charAt(i));
            }
        }
    }
}


!!!!!!!!!!!!!!!!!!!!!!!!!
Потому-что любой класс реализующий интерфейс Externalizable обязан иметь public конструктор без параметров!
 eNdiD
eNdiD 21 марта 2015, 14:54 0 ↑
Обязан и имеет. Компилятор добавляет пустой конструктор автоматически, его не обязательно явно прописывать.
 sokolov
sokolov 21 мая 2015, 23:10 0 ↑
Это в случае если нет других конструкторов с параметрами. Если создал свой конструктор, то дефолтовый нужно добавлять «ручками».















package com.javarush.test.level20.lesson07.task04;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;

/* Serializable Solution
Сериализуйте класс Solution.
Подумайте, какие поля не нужно сериализовать, пометить ненужные поля — transient.
Объект всегда должен содержать актуальные итоговые данные.
Метод main не участвует в тестировании.
Написать код проверки самостоятельно в методе main:
1) создать файл, открыть поток на чтение (input stream) и на запись(output stream)
2) создать экземпляр класса Solution - savedObject
3) записать в поток на запись savedObject (убедитесь, что они там действительно есть)
4) создать другой экземпляр класса Solution с другим параметром
5) загрузить из потока на чтение объект - loadedObject
6) проверить, что savedObject.string равна loadedObject.string
7) обработать исключения
*/
public class Solution implements Serializable {

    private static Object loadedObject;

    public static void main(String[] args) throws Exception {

        try {
            Solution savedObject = new Solution(3);

            File file = new File("d:/4.txt");
            FileOutputStream fos = new FileOutputStream(file);
            ObjectOutputStream out = new ObjectOutputStream(fos);
            out.writeObject(savedObject);

            FileInputStream fis = new FileInputStream(file);
            ObjectInputStream oin = new ObjectInputStream(fis);
            loadedObject = oin.readObject();

            if (savedObject.toString().equals(loadedObject.toString())) {
                System.out.println(savedObject.toString());
            } else {
                System.out.println(loadedObject.toString() + "no!");
            }
        }catch(Exception e){
            e.printStackTrace();
        }

        System.out.println(new Solution(4));
    }

    private final transient String pattern = "dd MMMM yyyy, EEEE";
    private transient Date currentDate;
    private transient int temperature;
    String string;


    public Solution(int temperature) {
        this.currentDate = new Date();
        this.temperature = temperature;

        string = "Today is %s, and current temperature is %s C";
        SimpleDateFormat format = new SimpleDateFormat(pattern);
        this.string = String.format(string, format.format(currentDate), temperature);
    }

    public Solution(){

    }

    @Override
    public String toString() {
        return this.string;
    }
}













package com.javarush.test.level20.lesson07.task05;

import java.io.*;

/* Переопределение сериализации
Сделайте так, чтобы после десериализации нить runner продолжила работать.
Ключевые слова объекта runner менять нельзя.
Hint/Подсказка:
Конструктор не вызывается при сериализации, только инициализируются все поля.
*/
public class Solution implements Serializable, Runnable {
    transient private Thread runner;
    private int speed;

    public static Object loadedObject;

    public static void main(String[] args)throws Exception{

        Solution savedObject = new Solution(4);


    }

    public Solution(int speed) {
        this.speed = speed;
        runner = new Thread(this);
        runner.start();
    }

    public Solution(){

    }

    public void run() {
        // do something here, does not matter
        System.out.println("RazRaz");
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("RazRazDVA");
    }

    /**
     Переопределяем сериализацию.
     Для этого необходимо объявить методы:
     private void writeObject(ObjectOutputStream out) throws IOException
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
     Теперь сериализация/десериализация пойдет по нашему сценарию :)
     */
    private void writeObject(ObjectOutputStream out) throws IOException {

        out.defaultWriteObject();
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {

        in.defaultReadObject();
        startThread();

    }

    private void startThread(){
        runner = new Thread(this);
        runner.start();
    }
}















package com.javarush.test.level15.lesson12.bonus03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

/* Факториал
Написать метод, который вычисляет факториал - произведение всех чисел от 1 до введенного числа включая его.
Пример: 4! = factorial(4) = 1*2*3*4 = 24
1. Ввести с консоли число меньше либо равно 150.
2. Реализовать функцию  factorial.
3. Если введенное число меньше 0, то вывести 0.
0! = 1
*/

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int input = Integer.parseInt(reader.readLine());
        reader.close();

        if (input <= 0)
            System.out.println("0");

        else
            System.out.println(factorial(input));
    }

    public static String factorial(int n) {
        BigInteger fctrl = BigInteger.valueOf(1);
        if(n > 0 && n <= 150) {
            for (int i = 2; i <= n; i++) {
                fctrl = fctrl.multiply(BigInteger.valueOf(i));
            }
        }
        return fctrl.toString();
    }

}



















package com.javarush.test.level14.lesson08.bonus02;                                        
                                                                                           
/* НОД                                                                                     
Наибольший общий делитель (НОД).                                                           
Ввести с клавиатуры 2 целых положительных числа.                                           
Вывести в консоль наибольший общий делитель.                                               
*/                                                                                         
                                                                                           
import java.io.BufferedReader;                                                             
import java.io.InputStreamReader;                                                          
                                                                                           
public class Solution {                                                                    
    public static void main(String[] args) throws Exception {                              
                                                                                           
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));      
                                                                                           
        int a = Integer.parseInt(reader.readLine());                                       
        int b = Integer.parseInt(reader.readLine());                                       
                                                                                           
        while (b != 0) {                                                                   
            int tmp = a%b;                                                                 
            a = b;                                                                         
            b = tmp;                                                                       
        }                                                                                  
                                                                                           
        System.out.println(a);                                                             
    }                                                                                      
}                                                                                          
                                                                                           












package com.javarush.test.level12.lesson12.bonus03;

/* Задача по алгоритмам
Написать метод, который возвращает минимальное число в массиве и его позицию (индекс).
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        int[] data = new int[]{1, 2, 3, 5, -2, -8, 0, 77, 5, 5};

        Pair<Integer, Integer> result = getMinimumAndIndex(data);

        System.out.println("Minimum is " + result.x);
        System.out.println("Index of minimum element is " + result.y);
    }

    public static Pair<Integer, Integer> getMinimumAndIndex(int[] array)
    {
        if (array == null || array.length == 0)
        {
            return new Pair<Integer, Integer>(null, null);
        }

        //Напишите тут ваше решение
        int min = 0;
        int index = 0;

        for(int i = 0; i < array.length; i++){
            min = Math.min(min, array[i]);
            if(min == array[i]){
                index = i;
            }
        }

        return new Pair<Integer, Integer>(min, index);
    }


    public static class Pair<X, Y>
    {
        public X x;
        public Y y;

        public Pair(X x, Y y)
        {
            this.x = x;
            this.y = y;
        }
    }
}











package com.javarush.test.level10.lesson11.bonus03;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/* Задача по алгоритмам
Задача: ввести с клавиатуры 30 чисел. Вывести 10-е и 11-е минимальные числа.
Пояснение:
Самое минимальное число – 1-е минимальное.
Следующее минимальное после него – 2-е минимальное
Пример:
1 6 5  7  1  15   63   88
Первое минимальное – 1
Второе минимальное – 1
Третье минимальное – 5
Четвертое минимальное – 6
*/

public class Solution
{
    public static void main(String[] args) throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int[] array = new int[30];
        for (int i = 0; i < 30; i++)
        {
            array[i] = Integer.parseInt(reader.readLine());
        }

        sort(array);

        System.out.println(array[9]);
        System.out.println(array[10]);
    }

    public static void sort(int[] array)
    {
        int temp;

        for(int i=0; i < array.length-1; i++){

            for(int j=1; j < array.length-i; j++){
                if(array[j-1] > array[j]){
                    temp=array[j-1];
                    array[j-1] = array[j];
                    array[j] = temp;
                }
            }
        }
    }

}






package com.javarush.test.level13.lesson11.bonus01;

/* Сортировка четных чисел из файла
1. Ввести имя файла с консоли.
2. Прочитать из него набор чисел.
3. Вывести на консоль только четные, отсортированные по возрастанию.
Пример ввода:
5
8
11
3
2
10
Пример вывода:
2
8
10
*/

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Solution
{
    public static void main(String[] args) throws IOException {
        // напишите тут ваш код
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        List<Integer> list = new ArrayList<>();

        try (BufferedReader br = new BufferedReader(new FileReader(bufferedReader.readLine()))) {
            String line;

            while ((line = br.readLine()) != null) {
                // process the line.
                try
                {
                    int n = Integer.parseInt(line);

                    list.add(n);
                }
                catch(NumberFormatException e)
                {
                    e.printStackTrace();
                }

            }
        }

        int[] arr = new int[list.size()];

        for(int i = 0; i < list.size(); i++){
            arr[i] = list.get(i);
        }

        List<Integer> even = new ArrayList<Integer>();
        for (int i : arr) {
            if ((i & 1) == 0) {
                even.add(i);
            }
        }

        Collections.sort(even);

        for(int n = 0; n < even.size(); n++){
            System.out.println(even.get(n));
        }
    }
}














package com.javarush.test.level17.lesson10.bonus01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/* CRUD
CrUD - Create, Update, Delete
Программа запускается с одним из следующих наборов параметров:
-c name sex bd
-u id name sex bd
-d id
-i id
Значения параметров:
name - имя, String
sex - пол, "м" или "ж", одна буква
bd - дата рождения в следующем формате 15/04/1990
-c  - добавляет человека с заданными параметрами в конец allPeople, выводит id (index) на экран
-u  - обновляет данные человека с данным id
-d  - производит логическое удаление человека с id
-i  - выводит на экран информацию о человеке с id: name sex (м/ж) bd (формат 15-Apr-1990)

id соответствует индексу в списке
Все люди должны храниться в allPeople
Используйте Locale.ENGLISH в качестве второго параметра для SimpleDateFormat

Пример параметров: -c Миронов м 15/04/1990
*/


public class Solution {
    public static List<Person> allPeople = new ArrayList<Person>();
    static {
        allPeople.add(Person.createMale("Иванов Иван", new Date()));  //сегодня родился    id=0
        allPeople.add(Person.createMale("Петров Петр", new Date()));  //сегодня родился    id=1
    }


    public static void main(String[] args) throws ParseException
    {
        //start here - начни тут



        if(args.length==4&&args[0].equals("-c")){
            Person person = null;
            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy",Locale.ENGLISH);
            Date date = sdf.parse(args[3]);
            if (args[2].equals("м"))
                person  = Person.createMale(args[1], date);
            else if (args[2].equals("ж"))
                person  = Person.createFemale(args[1], date);
            allPeople.add(person);
            System.out.println(allPeople.indexOf(person));
        }

        else if(args.length==5&&args[0].equals("-u")){
            Person person = allPeople.get(Integer.parseInt(args[1]));
            person.setName(args[2]);
            if (args[3].equals("м"))
                person.setSex(Sex.MALE);
            else if (args[3].equals("ж"))
                person.setSex(Sex.FEMALE);
            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy",Locale.ENGLISH);
            Date date = sdf.parse(args[4]);
            person.setBirthDay(date);
            // allPeople.set(Integer.parseInt(args[1]), person);
        }


        else  if(args.length==2&&args[0].equals("-d")){
            Person person = allPeople.get(Integer.parseInt(args[1]));
            person.setName(null);
            person.setSex(null);
            person.setBirthDay(null);

        }


        else  if(args.length==2&&args[0].equals("-i")){
            Person person = allPeople.get(Integer.parseInt(args[1]));
            SimpleDateFormat sdf = new SimpleDateFormat("dd-MMM-yyyy",Locale.ENGLISH);

            String sexFormat = "";
            if (person.getSex().equals(Sex.MALE)) {
                sexFormat = "м";
            }
            if (person.getSex().equals(Sex.FEMALE)){
                sexFormat = "ж";
            }

            System.out.println(person.getName() + " " + sexFormat + " " + sdf.format(person.getBirthDay()));
        }
    }
}



----
package com.javarush.test.level17.lesson10.bonus02;

import java.util.Date;

public class Person {
    private String name;
    private Sex sex;
    private Date birthDay;

    private Person(String name, Sex sex, Date birthDay) {
        this.name = name;
        this.sex = sex;
        this.birthDay = birthDay;
    }

    public static Person createMale(String name, Date birthDay){
        return new Person(name, Sex.MALE, birthDay);
    }

    public static Person createFemale(String name, Date birthDay){
        return new Person(name, Sex.FEMALE, birthDay);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Sex getSex() {
        return sex;
    }

    public void setSex(Sex sex) {
        this.sex = sex;
    }

    public Date getBirthDay() {
        return birthDay;
    }

    public void setBirthDay(Date birthDay) {
        this.birthDay = birthDay;
    }
}

----
package com.javarush.test.level17.lesson10.bonus02;

public enum Sex {
    MALE,
    FEMALE
}














package com.javarush.test.level17.lesson10.bonus02;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/* CRUD 2
CrUD Batch - multiple Creation, Updates, Deletion
!!!РЕКОМЕНДУЕТСЯ выполнить level17.lesson10.bonus01 перед этой задачей!!!

Программа запускается с одним из следующих наборов параметров:
-c name1 sex1 bd1 name2 sex2 bd2 ...
-u id1 name1 sex1 bd1 id2 name2 sex2 bd2 ...
-d id1 id2 id3 id4 ...
-i id1 id2 id3 id4 ...
Значения параметров:
name - имя, String
sex - пол, "м" или "ж", одна буква
bd - дата рождения в следующем формате 15/04/1990
-с  - добавляет всех людей с заданными параметрами в конец allPeople, выводит id (index) на экран в соответствующем порядке
-u  - обновляет соответствующие данные людей с заданными id
-d  - производит логическое удаление всех людей с заданными id
-i  - выводит на экран информацию о всех людях с заданными id: name sex bd

id соответствует индексу в списке
Формат вывода даты рождения 15-Apr-1990
Все люди должны храниться в allPeople
Порядок вывода данных соответствует вводу данных
Обеспечить корректную работу с данными для множества нитей (чтоб не было затирания данных)
Используйте Locale.ENGLISH в качестве второго параметра для SimpleDateFormat
*/

public class Solution{

    public static volatile List<Person> allPeople = new ArrayList<Person>();

    static {
        allPeople.add(Person.createMale("Иванов Иван", new Date()));  //сегодня родился    id=0
        allPeople.add(Person.createMale("Петров Петр", new Date()));  //сегодня родился    id=1
    }

    public static void main(String[] args) throws ParseException {
        //start here - начни тут
        int n = args.length;
        if (n < 2) {
            return;
        }
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/y", Locale.ENGLISH);
        SimpleDateFormat sdf1 = new SimpleDateFormat("dd-MMM-y", Locale.ENGLISH);
        if (args[0].equals("-c")) {
            for (int i = 1; i < n; i += 3) {
                String name = args[i];
                try {
                    Date bd = sdf.parse(args[i + 2]);
                    if (args[i + 1].equals("м")) {
                        allPeople.add(Person.createMale(name, bd));
                        System.out.println(allPeople.size() - 1);
                    }else if (args[i + 1].equals("ж")) {
                        allPeople.add(Person.createFemale(name, bd));
                        System.out.println(allPeople.size() - 1);
                    }
                } catch (ParseException e) {
                    e.printStackTrace();
                }
            }
        } else if (args[0].equals("-u")) {
            for (int i = 1; i < n; i += 4) {
                try {
                    int id = Integer.parseInt(args[i]);
                    if (id > allPeople.size()-1) {
                        break;
                    }
                    String name = args[i + 1];
                    Date bd = sdf.parse(args[i + 3]);
                    if (args[i + 2].equals("м")) {
                        Person p = Person.createMale(name, bd);
                        allPeople.set(id, p);
                    }else if (args[i + 2].equals("ж")) {
                        Person p = Person.createFemale(name, bd);
                        allPeople.set(id, p);
                    }
                } catch (Exception e) {
                    System.out.println(e);
                }
            }
        } else if (args[0].equals("-d")) {
            for (int i = 1; i < n; i ++) {
                try {
                    int id = Integer.parseInt(args[i]);
                    if (id > allPeople.size() - 1) {
                        break;
                    }
                    allPeople.get(id).setBirthDay(null);
                    allPeople.get(id).setName("");
                    allPeople.get(id).setSex(null);
                } catch (Exception e) {
                    System.out.println(e);
                }
            }
        }else if (args[0].equals("-i")) {
            for (int i = 1; i < n; i++) {
                try {
                    int id = Integer.parseInt(args[i]);
                    if (id > allPeople.size() - 1) {
                        break;
                    }
                    Person p = allPeople.get(id);
                    String sex;
                    if (p.getSex() == Sex.FEMALE) {
                        sex = "ж";
                    }else sex = "м";
                    System.out.println(p.getName() + " " + sex + " " + sdf1.format(p.getBirthDay()));
                } catch (Exception e) {
                    System.out.println(e);
                }
            }
        }
//        for (Person p : allPeople) {
//            System.out.println(p.getName() + " " + p.getSex() + " " + sdf1.format(p.getBirthDay()));
//        }
    }
}













package com.javarush.test.level18.lesson10.bonus01;

/* Шифровка
Придумать механизм шифровки/дешифровки

Программа запускается с одним из следующих наборов параметров:
-e fileName fileOutputName
-d fileName fileOutputName
где
fileName - имя файла, который необходимо зашифровать/расшифровать
fileOutputName - имя файла, куда необходимо записать результат шифрования/дешифрования
-e - ключ указывает, что необходимо зашифровать данные
-d - ключ указывает, что необходимо расшифровать данные
*/

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Solution {

    public static void main(String[] args) throws Exception {


        if(args.length > 0)
        {
            String ifile = args[1];
            String ofile = args[2];
            if(args[0].equals("-e"))
                encrypt(ifile, ofile);
            else if(args[0].equals("-d"))
                decrypt(ifile, ofile);
        }
    }


    public static void encrypt(String filein, String fileout) throws IOException
    {
        FileInputStream inputStream = new FileInputStream(filein);
        FileOutputStream outputStream = new FileOutputStream(fileout);
        while (inputStream.available()>0)
        {
            int read = inputStream.read()-1;
            outputStream.write(read);
        }
        inputStream.close();
        outputStream.close();
    }


    public static void decrypt(String filein, String fileout) throws IOException
    {
        FileInputStream inputStream = new FileInputStream(filein);
        FileOutputStream outputStream = new FileOutputStream(fileout);
        while (inputStream.available()>0)
        {
            int read = inputStream.read()+1;
            outputStream.write(read);
        }
        inputStream.close();
        outputStream.close();
    }
}









package com.javarush.test.level19.lesson10.bonus01;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/* Отслеживаем изменения
Считать в консоли 2 имени файла - file1, file2.
Файлы содержат строки, file2 является обновленной версией file1, часть строк совпадают.
Нужно создать объединенную версию строк, записать их в список lines
Операции ADDED и REMOVED не могут идти подряд, они всегда разделены SAME
Пример:
оригинальный   редактированный    общий
file1:         file2:             результат:(lines)

строка1        строка1            SAME строка1
строка2                           REMOVED строка2
строка3        строка3            SAME строка3
строка4                           REMOVED строка4
строка5        строка5            SAME строка5
строка0                           ADDED строка0
строка1        строка1            SAME строка1
строка2                           REMOVED строка2
строка3        строка3            SAME строка3
строка5                           ADDED строка5
строка4        строка4            SAME строка4
строка5                           REMOVED строка5
*/

public class Solution {
    public static List<LineItem> lines = new ArrayList<LineItem>();

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String file1 = reader.readLine();
        String file2 = reader.readLine();

        List<String> list1 = readFile(file1);
        List<String> list2 = readFile(file2);

        reader.close();

        while (updateList(list1, list2)) {
        }
    }


    public static enum Type {
        ADDED,        //добавлена новая строка
        REMOVED,      //удалена строка
        SAME          //без изменений
    }

    public static class LineItem {
        public Type type;
        public String line;

        public LineItem(Type type, String line) {
            this.type = type;
            this.line = line;
        }
    }

    private static boolean updateList(List<String> l1, List<String> l2) {
        if (l1.isEmpty() && l2.isEmpty())
            return false;

        if (!l2.isEmpty() && l1.isEmpty()) {
            lines.add(new LineItem(Type.ADDED, l2.get(0)));
            l2.remove(0);
        }

        if (!l1.isEmpty() && l2.isEmpty()) {
            lines.add(new LineItem(Type.REMOVED, l1.get(0)));
            l1.remove(0);
        }

        if (l1.size() == 1 && l2.size() > 1) {

            if (l1.get(0).equals(l2.get(1))) {
                lines.add(new LineItem(Type.ADDED, l2.get(0)));
                lines.add(new LineItem(Type.SAME, l1.get(0)));
                l1.remove(0);
                l2.remove(0);
                l2.remove(1);
            }
        }

        if (l2.size() == 1 && l1.size() > 1) {

            if (l2.get(0).equals(l1.get(1))) {
                lines.add(new LineItem(Type.REMOVED, l1.get(0)));
                lines.add(new LineItem(Type.SAME, l2.get(0)));
                l1.remove(0);
                l1.remove(0);
                l2.remove(0);
            }
        }

        if (!l1.isEmpty() && !l2.isEmpty())
            if (l1.get(0).equals(l2.get(0))) {
                lines.add(new LineItem(Type.SAME, l1.get(0)));
                l1.remove(0);
                l2.remove(0);
            } else if (l1.get(0).equals(l2.get(1))) {
                lines.add(new LineItem(Type.ADDED, l2.get(0)));
                l2.remove(0);
            } else if (l2.get(0).equals(l1.get(1))) {
                lines.add(new LineItem(Type.REMOVED, l1.get(0)));
                l1.remove(0);
            }

        return !(l1.isEmpty() && l2.isEmpty());
    }

    private static List<String> readFile(String st) throws IOException {
        List<String> list = new LinkedList<>();

        BufferedReader reader = new BufferedReader(new FileReader(st));

        while (reader.ready()){

            list.add(reader.readLine());

        }

        return list;
    }
}
















package com.javarush.test.level19.lesson10.bonus02;

/* Свой FileWriter
Реализовать логику FileConsoleWriter
Должен наследоваться от FileWriter
При записи данных в файл, должен дублировать эти данные на консоль
*/

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileWriter;
import java.io.IOException;

public class FileConsoleWriter extends FileWriter {


    public static void main(String[] args) throws IOException {

        FileConsoleWriter fileConsoleWriter = new FileConsoleWriter("d:/1.txt");
        fileConsoleWriter.write("123456789".toCharArray(), 2, 5);
        fileConsoleWriter.write("123456789");
        fileConsoleWriter.write(9999);
        fileConsoleWriter.write(999943636);
        fileConsoleWriter.write("qwertyu", 2, 5);
        fileConsoleWriter.write("dfghj".toCharArray());

        fileConsoleWriter.flush();
        fileConsoleWriter.close();

    }

    public FileConsoleWriter(FileDescriptor fd) {
        super(fd);
    }

    public FileConsoleWriter(File file) throws IOException {
        super(file);
    }

    public FileConsoleWriter(File file, boolean append) throws IOException {
        super(file, append);
    }

    public FileConsoleWriter(String fileName) throws IOException {
        super(fileName);
    }

    public FileConsoleWriter(String fileName, boolean append) throws IOException {
        super(fileName, append);
    }

    @Override
    public void write(String str, int off, int len) throws IOException {
        super.write(str, off, len);
        System.out.print(str.substring(off, len));
    }

    @Override
    public void write(char[] cbuf, int off, int len) throws IOException {
        super.write(cbuf, off, len);
        System.out.print(String.valueOf(cbuf, off, len));
    }


    @Override
    public void write(int c) throws IOException {
        String num = ""+c;
        write(num, 0, num.length());
    }

}









<span>Super</span>
<span>girl</span>

Шаблон тега:
<tag>text1</tag>
<tag text2>text1</tag>
<tag
text2>text1</tag>

text1, text2 могут быть пустыми
*/

import java.io.*;
import java.util.Scanner;

public class Solution {

    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        Scanner scanner = new Scanner(new FileReader(reader.readLine()));
        String content ="";
        while(scanner.hasNext()){
            content += scanner.next();
        }
        scanner.close();

        String tag = args[0];

        int length = tag.length()+1;

        int pos = 0;
        int index = 0;
        int flag = 0;
        int open = 0;

        while((pos = content.indexOf(tag, index)) != -1) //Ищем совпадения для тега в пределах строки-контента
        {                                                // и сохраняем их индексы в pos
            if(content.substring(pos-1, pos + length-1).equals("<"+tag)) { //если совпадения нашлись, то проверяем теги
                                                                            //на "<+тег"
                if(flag == 0) {
                    flag++;                //если совпадения на "<+тег" нашлись, то плюсуем флаг на 1 и
                    open = pos;            //двигаемся дальше по контенту, поднимая значение open на значение pos
                    index = pos+1;         //+ поднимаем переменную index
                }
                else {
                    flag++;               //в противном случае просто плюсуем флаг на 1 и индекс на pos+1
                    index=pos+1;
                }

            } else if(content.substring(pos-2,pos+length).equals("</"+tag+">") && flag > 0) { //проверяем совпадения на "</+тег+>"

                if(flag == 1) {                                     //значение флага должно отвечать парности открывающих и
                    flag--;                                         //закрывающих тегов, т.е. быть 1, когда оба очерендных тега найдеы
                    System.out.println(content.substring(open-1,pos+length));
                    index=open+1;
                } else {
                    index = pos+1;
                    flag--;
                }

            } else
                index = pos+1;
        }
    }

}












package com.javarush.test.level20.lesson10.home01;

import java.io.Serializable;

/* Минимум изменений
Используя минимум изменений кода сделайте так, чтобы сериализация класса C стала возможной.
*/
public class Solution {

    public class A implements Serializable {
        String name = "A";

        public A(String name) {
            this.name += name;
        }

        @Override
        public String toString() {
            return name;
        }
    }

    public class B extends A {
        String name = "B";

        public B(String name) {
            super(name);
            this.name += name;
        }
    }

    public class C extends B {
        String name = "C";

        public C(String name) {
            super(name);
            this.name = name;
        }
    }
}









package com.javarush.test.level19.lesson10.home10;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;

/* Исправить ошибку
Программа содержит всего 1 ошибку. Найди и исправь ее
*/

public class Solution {
    {
        System.out.println("it's Solution class");
    }

    public static void main(String... args) throws IOException {
        try (
                FileOutputStream outputStream = new FileOutputStream("c:/output.txt");
                InputStream is = Solution.class.getClassLoader().getResourceAsStream("/user/resources/avatar.gif");
        ) {
            ;
            byte[] b = new byte[is.available()];
            outputStream.write(is.read(b));

            int value = 123_456_789;
            System.out.println(value);

            Example result = null;
            String s = "a";
            switch (s) {
                case "a": {
                    result = new Solution().new A();
                    break;
                }
                case "b": {
                    result = new Solution().new B();
                    break;
                }
                case "c": {
                    result = new Solution().new C();
                    break;
                }
            }

            if (result instanceof Example) {
                C p = (C) result;
                System.out.println(p.getClass().getSimpleName());
            }

        } catch (IOException e) {
        }
    }

    interface Example {
    }

    class A implements Example {
        {
            System.out.println("it's A class");
        }
    }

    class B implements Example {
        {
            System.out.println("it's B class");
        }
    }

    class C extends A {
        {
            System.out.println("it's C class");
        }
    }
}








package com.javarush.test.level20.lesson10.home02;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;

/* Десериализация
На вход подается поток, в который записан сериализованный объект класса A либо класса B.
Десериализуйте объект в методе getOriginalObject предварительно определив, какого именно типа там объект.
Реализуйте интерфейс Serializable где необходимо.
*/
public class Solution implements Serializable {

    public A getOriginalObject(ObjectInputStream objectStream) throws IOException, ClassNotFoundException {

        Object recrObj = objectStream.readObject();

        if(recrObj.getClass() == A.class){
            return (A) recrObj;
        }
        if(recrObj.getClass() == B.class){
            return (B) recrObj;
        }

        return null;
    }

    public class A implements Serializable {
    }

    public class B extends A {
        public B() {
            System.out.println("inside B");
        }
    }
}









package com.javarush.test.level20.lesson10.home03;

import java.io.*;

/* Найти ошибки
Почему-то при сериализации/десериализации объекта класса B возникают ошибки.
Найдите проблему и исправьте ее.
Класс A не должен реализовывать интерфейсы Serializable и Externalizable.
Сигнатура класса В не содержит ошибку :)
Метод main не участвует в тестировании.
*/
public class Solution implements Serializable {


    public static class A
    {
        protected String name = "A";
        public A(String name)
        {
            this.name += name;
        }
        public A()
        {
        }
    }
    public class B extends A implements Serializable {
        public B(String name) {
            super(name);
            this.name += name;
        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            out.writeObject(this.name);
        }

        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            name = (String) in.readObject();
        }
    }
}











package com.javarush.test.level20.lesson10.home04;

import java.io.*;
import java.util.HashMap;
import java.util.Map;

/* Исправить ошибку
После десериализации объекта класса Solution обнаружили, что данных в словаре [m] нет :(
Исправить 1 ошибку.
Метод main в тестировании не участвует.
*/
public class Solution implements Serializable {

    public static void main(String args[]) throws Exception {
        FileOutputStream fileOutput = new FileOutputStream("your.file.name");
        ObjectOutputStream outputStream = new ObjectOutputStream(fileOutput);

        Solution solution = new Solution();
        outputStream.writeObject(solution);

        fileOutput.close();
        outputStream.close();

        //loading
        FileInputStream fiStream = new FileInputStream("your.file.name");
        ObjectInputStream objectStream = new ObjectInputStream(fiStream);

        Solution loadedObject = (Solution) objectStream.readObject();

        fiStream.close();
        objectStream.close();

        //Attention!!
        System.out.println(loadedObject.size());
    }

    private Map<String, String> m = new HashMap<>();

    public Map<String, String> getMap() {
        return m;
    }

    public Solution(){

    }

    {
        m.put("Mickey", "Mouse");
        m.put("Mickey", "Mantle");
    }

    public int size() {
        return m.size();
    }
}













package com.javarush.test.level20.lesson10.home05;

import java.io.*;
import java.util.logging.Logger;

/* Сериализуйте Person
Сериализуйте класс Person стандартным способом. При необходимости поставьте полям модификатор transient.
*/
public class Solution {
    public static class Person implements Serializable {

        String firstName;
        String lastName;
        transient String fullName;
        transient final String greetingString;
        String country;
        Sex sex;
        transient PrintStream outputStream;
        transient Logger logger;

        Person(String firstName, String lastName, String country, Sex sex) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.fullName = String.format("%s, %s", lastName, firstName);
            this.greetingString = "Hello, ";
            this.country = country;
            this.sex = sex;
            this.outputStream = System.out;
            this.logger = Logger.getLogger(String.valueOf(Person.class));
        }

    }

    enum Sex {
        MALE,
        FEMALE
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException
    {
        Person person = new Person("Dexter", "Morgan", "Miami", Sex.MALE);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("Solution.out"));
        oos.writeObject(person);
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("Solution.out"));
        Person loadPerson = (Person) ois.readObject();
    }

}








package com.javarush.test.level20.lesson10.home06;

import java.io.*;

/* Запрет сериализации
Запретите сериализацию класса SubSolution используя NotSerializableException.
Сигнатуры классов менять нельзя
*/
public class Solution implements Serializable {
    public static class SubSolution extends Solution {

        public SubSolution(){

        }

        private void writeObject(ObjectOutputStream out) throws IOException {
            throw new NotSerializableException();
        }

        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            throw new NotSerializableException();
        }
    }
}













package com.javarush.test.level20.lesson10.home07;

import java.io.*;

/* Переопределение сериализации в потоке
Сериализация/десериализация Solution не работает.
Исправьте ошибки не меняя сигнатуры методов и класса.
Метод main не участвует в тестировании.
Написать код проверки самостоятельно в методе main:
1) создать экземпляр класса Solution
2) записать в него данные  - writeObject
3) сериализовать класс Solution  - writeObject(ObjectOutputStream out)
4) десериализовать, получаем новый объект
5) записать в новый объект данные - writeObject
6) проверить, что в файле есть данные из п.2 и п.5
*/
public class Solution implements Serializable, AutoCloseable {

    private String fileName;

    public static void main(String[] args) throws IOException, ClassNotFoundException
    {
        String fileName = "d:/1.txt";
        Solution solution = new Solution(fileName);
        solution.writeObject("test1");
        solution.writeObject(new ObjectOutputStream(new FileOutputStream(fileName)));
        String fileName1 = "d:/2.txt";
        Solution solution1 = new Solution(fileName1);
        solution1.readObject(new ObjectInputStream(new FileInputStream(fileName)));
        solution1.writeObject("test2");
    }
    private transient FileOutputStream stream;
    public Solution(String fileName) throws FileNotFoundException {
        this.stream = new FileOutputStream(fileName);
        this.fileName = fileName;
    }

    public void writeObject(String string) throws IOException {
        stream.write(string.getBytes());
        stream.write("\n".getBytes());
        stream.flush();
    }
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        //out.writeObject(fileName);
        // out.close();
    }
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        this.stream = new FileOutputStream(fileName,true);
        //  in.close();
    }
    @Override
    public void close() throws Exception {
        System.out.println("Closing everything!");
        stream.close();
    }
}









приоритет операторов и порядок их выполнения:

Операторы	Примеры
Высший приоритет (сначала выполняются операторы с меньшим номером)
()
[]
.	(a+b)
c[i] = c[i]+1
++ 
-- 
~ 
!
+
-	i++; ++i;
--j; a--;
~c
!f
return +a;
return -a;
*
/
%	a * b
c / d
a % b
+
-	a+b
c-d
String s = "count"+"35 ";
>>
<<
>>>
a>>3
b<<2
c>>>3
<
<=
>
>=	a < b
a <= b
c > b
c >= b
== 
!=	a == 3
a != 0
&	a & 7
^	a ^ b
|	a | b
&&	(a<b) && (a<c)
||	(b!=0) || (c!=0)
? : =	a>0 ? a : -a;
= 
*=, /=, %=
-=, +=
<<=. >>=, >>>=
&=, ^=. |=	
Низший приоритет (выполняются в самом конце)



---------------------------------------------------------------------

Группа – «побитовые операторы»

Обозначение	Пример	Название	Описание (что делает)
&	a & b	AND – «и»	Побитовое «И»
|	c | d	OR – «или»	Побитовое «ИЛИ»
~	~a	NOT – «не»	Побитовое «НЕ»
^	a^b	XOR – «исключающее или»	Побитовое «ИСКЛЮЧАЮЩЕЕ ИЛИ»
- Побитовые операторы выполняю операцию над целыми числами побитово.

- Это как?

- Каждое число представляется в виде набора бит, а затем вычисляется результат по такой схеме:

Если первый бит в обоих числах равен 1, то первый бит результата будет 1.

Если второй бит в обоих числах равен 1, то второй бит результата будет 1. И так далее

- Это верно для всех побитовых операторов?

- Тут все намного проще. Бит может принимать только два значения – 0 и 1, так?

- Да.

- Тогда представь, что 1 – это true, а 0 – это false. Тогда операции над отдельными битами будут практически такими же, как и логические операции:

Логическое выражение	Битовое выражение
true && true == true	1&1 == 1
true && false == false	1&0 ==0
true || true == true	1|1 ==1
true || false == true	1|0 ==1
false || false = false	0|0 ==0
!false == true	~0 ==1
!true == false	~1 == 0
- О! Так все же очень просто.

- Да, только не забывай, что в побитовых операциях участвуют биты двух чисел, которые расположены на одних и тех же местах.

- Да, я помню: первый бит одного числа взаимодействует с первым битом второго, и результат записывается также в первый бит. Для остальных битов – аналогично.

- Верно. Есть еще вопросы?

- А что это за XOR еще такой – «исключающее или»?

- Тут тоже все просто: когда значение разные – истина (true, 1), когда одинаковые – (false, 0)

Логическое выражение	Битовое выражение
true XOR true == false	1 ^ 1 ==0
false XOR false == false	0 ^ 0 ==0
true XOR false == true	1 ^ 0 ==1
false XOR true == true	0 ^ 1 ==1
Вот тебе еще пара примеров побитовых операций:

Пример	Числа в битовом виде	Ответ в битовом виде	Ответ
5 & 3	00000101 & 00000011	00000001	1
7 & 2	00000111 & 00000010	00000010	2
5 | 9	00000101 | 00001001	00001101	13
5 ^ 9	00000101 ^ 00001001	00001100	12
~9	~00001001	11110110	246
- Спасибо, Билаабо. Буду знать.

- Есть еще одна группа побитовых операторов – операторы сдвига:

5) Группа «операторы сдвига»

Обозначение	Пример	Название	Описание (что делает)
>>	a>>b	сдвиг вправо	Сдвигает биты числа a, на b разрядов вправо.
<<	c<<d	сдвиг влево	Сдвигает биты числа c, на d разрядов влево.
>>>	a>>>2	сдвиг вправо с заполнением нулем	Сдвигает биты числа a, на 2 разряда вправо.
- Это что еще за уличная магия?

- На самом деле тут все просто. Вот смотри:

Пример	Числа в битовом виде	Ответ в битовом виде	Ответ
10>>1	00001010>>1	00000101	5
10>>2	00001010>>2	00000010	2
10<<1	00001010<<1	00010100	20
10<<2	00001010<<2	00101000	40
Сдвига разрядов числа на 1 влево – то же самое, что умножить число на 2. На два разряда равно умножению на 4, на три разряда – умножению на 8 и так далее.

Сдвиг вправо – соответственно, деление на 2,4,8,16,… и так далее.

- А в чем отличие операторов «>>>» и «>>»?

- Они отличаются при работе с отрицательными числами. Дело в том, что знак отрицательного числа хранится в крайнем левом бите. 
И при сдвиге вправо число перестает быть отрицательным. Поэтому и придумали два различных оператора, вот смотри:

- На самом деле тут все просто. Вот смотри:

Выражение	Результат	Описание
10001010>>1	11000101	Отрицательное число остается отрицательным.
Новые разряды заполняются 1, для отрицательных чисел.
10001010>>2	11100010
10001010>>3	11110001
10001010>>>1	01000101	Отрицательное число перестает быть отрицательным. Новые разряды заполняются 0, для отрицательных чисел.
10001010>>>2	00100010
10001010>>>3	00010001
Сдвиг не циклический. Биты, которые оказались за краем числа слева или справа, просто отбрасываются.










package com.javarush.test.level21.lesson02.task01;

import java.io.UnsupportedEncodingException;

/* Определяем адрес сети
1) Даны IP-адрес и маска подсети, необходимо вычислить адрес сети - метод getNetAddress.
Используйте операцию поразрядной конъюнкции (логическое И).
Пример:
IP-адрес:       11000000 10101000 00000001 00000010 (192.168.1.2)
Маска подсети:  11111111 11111111 11111110 00000000 (255.255.254.0)
Адрес сети:     11000000 10101000 00000000 00000000 (192.168.0.0)
2) Реализовать метод print, который выведет в консоль данные в двоичном коде
3) Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) throws UnsupportedEncodingException {
        byte[] ip = new byte[]{(byte) 192, (byte) 168, 1, 2};
        byte[] mask = new byte[]{(byte) 255, (byte) 255, (byte) 254, 0};
        byte[] netAddress = getNetAddress(ip, mask);
        print(ip);          //11000000 10101000 00000001 00000010
        print(mask);        //11111111 11111111 11111110 00000000
        print(netAddress);  //11000000 10101000 00000000 00000000
    }

    public static byte[] getNetAddress(byte[] ip, byte[] mask) {

        byte[] newAdr = new byte[ip.length];

        for(int i = 0; i < ip.length; i++){
            newAdr[i] = (byte) (ip[i] & mask[i]);
        }
        return newAdr;
    }

    public static void print(byte[] bytes) {

        for(byte b : bytes) {
            String s1 = String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0');
            System.out.print(s1 + " ");
        }
        System.out.println();
    }
}











package com.javarush.test.level20.lesson10.home08;

/* Правильный вывод
Расставить обращение к методам суперкласса и модификаторы доступа так, чтобы вывод на экран был следующим:

C class, method2
A class, method2
A class, method1
B class, method1

1. Из одного метода можно вызвать только один метод суперкласса.
2. Из одного метода можно вызвать только один метод класса.
3. Можно менять модификаторы доступа к методам.
*/

//Если не обозначить method1 как приватный, то вместо «A class, method1» будет выдаваться «С class, method1»,
// поскольку в main() создана ссылка типа «А» на объект типа «С» [A a = new C();], что означает следующее —
// методы public переменной (ссылки) «а» будут ссылаться на методы объекта на которые она указывает, тобишь на «С».
// Применяя к методу модификатор доступа «private» — метод выполнится в том классе к которому принадлежит ссылка,
// а не объект. К примеру если к методу 2 в классе «А» применить модификатор «private»,
// то наша ссылка «а» у которой тип «А» — останется в своем методе класса «А»
// и выведет вместо первой строки «C class, method2» строку «А class, method2».


public class Solution {
    public static void main(String[] s) {
        A a = new C();
        a.method2();
    }

    public static class A {
        private void method1() {
            System.out.println("A class, method1");
        }

        public void method2() {
            System.out.println("A class, method2");
            method1();
        }
    }

    public static class B extends A {
        public void method1() {
            super.method2();
            System.out.println("B class, method1");
        }

        public void method2() {
            System.out.println("B class, method2");
        }
    }

    public static class C extends B {
        public void method1() {
            System.out.println("C class, method1");
        }

        public void method2() {
            System.out.println("C class, method2");
            super.method1();
        }
    }
}










package com.javarush.test.level20.lesson10.home09;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.List;

/* Знакомство с графами
Прочитать в дополнительных материалах о сериализации графов.
Дан ориентированный плоский граф Solution, содержащий циклы и петли.
Пример, http://edu.nstu.ru/courses/saod/images/graph1.gif
Сериализовать Solution.
Все данные должны сохранить порядок следования.
*/
public class Solution implements Serializable {
    int node;
    List<Solution> edges = new LinkedList<>();

    static final long SerialVersionUID = 1L;
}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
в этой задачe надо было осознать что java.io.Serializable — не нарушает целостности графа, а вот java.io.Externalizable — нарушает 
(вся целостность графа лежит на совести разработчика! И вот тут проявляется ИССКУСТВО программирования










package com.javarush.test.level21.lesson02.task02;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

/* Сравниваем модификаторы
Реализовать логику метода isAllModifiersContainSpecificModifier, который проверяет,
содержит ли переданный параметр allModifiers значение конкретного модификатора specificModifier
*/
public class Solution {
    public static void main(String[] args) {
        int modifiersOfThisClass = Solution.class.getModifiers();
        System.out.println(isAllModifiersContainSpecificModifier(modifiersOfThisClass, Modifier.PUBLIC));   //true
        System.out.println(isAllModifiersContainSpecificModifier(modifiersOfThisClass, Modifier.STATIC));   //false

        int modifiersOfMethod = getMainMethod().getModifiers();
        System.out.println(isAllModifiersContainSpecificModifier(modifiersOfMethod, Modifier.STATIC));      //true
    }

    public static boolean isAllModifiersContainSpecificModifier(int allModifiers, int specificModifier) {

        return (allModifiers & specificModifier) > 0;
    }

    private static Method getMainMethod() {
        Method[] methods = Solution.class.getDeclaredMethods();
        for (Method method : methods) {
            if (method.getName().equalsIgnoreCase("main")) return method;
        }

        return null;
    }
}









package com.javarush.test.level21.lesson02.task03;

/* Все гениальное - просто!
Упростить. Переменные не переименовывать, комментарии не оставлять.
*/
public class Solution {
    public static boolean calculate(boolean a, boolean b, boolean c, boolean d) {
	
	//(a && b && c && !d) || (!a && c) || (!b && c) || (c && d)
        return c;
    }

}











package com.javarush.test.level21.lesson05.task01;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

/* Equals and HashCode
В классе Solution исправить пару методов equals/hashCode в соответствии с правилами реализации этих методов.
Метод main не участвует в тестировании.
*/
public class Solution {
    private final String first, last;

    public Solution(String first, String last) {
        this.first = first;
        this.last = last;
    }

    @Override
    public int hashCode() {
        return Objects.hash(first, last);
    }

    @Override
    public boolean equals(Object n) {

        Solution object = (Solution) n;

        if (this == n)
            return true;
        if (n == null)
            return false;
        if (getClass() != n.getClass())
            return false;
        
        return Objects.equals(first, object.first) && Objects.equals(last, object.last);
    }

    public static void main(String[] args) {
        Set<Solution> s = new HashSet<>();
        s.add(new Solution("Donald", "Duck"));
        System.out.println(s.contains(new Solution("Donald", "Duck")));
    }
}











package com.javarush.test.level21.lesson05.task02;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

/* Исправить ошибку
Сравнение объектов Solution не работает должным образом. Найти ошибку и исправить.
Метод main не участвует в тестировании.
*/
public class Solution {
    private final String first, last;

    public Solution(String first, String last) {
        this.first = first;
        this.last = last;
    }

    public boolean equals(Object o) {

        Solution n = (Solution) o;

        if (this == n){
            return true;
        }
        if(n == null){
            return false;
        }
        if(this.getClass() != n.getClass()){
            return false;
        }

        return Objects.equals(first, n.first) && Objects.equals(last, n.last);
    }

    @Override
    public int hashCode() {
        return Objects.hash(first, last);
    }

    public static void main(String[] args) {
        Set<Solution> s = new HashSet<>();
        s.add(new Solution("Mickey", "Mouse"));
        System.out.println(s.contains(new Solution("Mickey", "Mouse")));
    }
}











package com.javarush.test.level21.lesson05.task03;

import java.util.Date;

/* Ошибка в equals/hashCode
Исправьте ошибки реализаций методов equals и hashCode для класса Solution
*/
public class Solution {
    private int anInt;
    private String string;
    private double aDouble;
    private Date date;
    private Solution solution;

    public Solution(int anInt, String string, double aDouble, Date date, Solution solution) {
        this.anInt = anInt;
        this.string = string;
        this.aDouble = aDouble;
        this.date = date;
        this.solution = solution;
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null) return false;
        if (!(o instanceof Solution)) return false;
        Solution solution1 = (Solution) o;
        if (Double.compare(solution1.aDouble, aDouble) != 0) return false;
        if (anInt != solution1.anInt) return false;
        if (date != null ? !date.equals(solution1.date) : solution1.date == null) return false;
        if (solution != null ? !solution.equals(solution1.solution) : solution1.solution == null) return false;
        if (string != null ? !string.equals(solution1.string) : solution1.string == null) return false;
        return true;
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        result = anInt;
        result = 31 * result + (string != null ? string.hashCode() : 0);
        temp = Double.doubleToLongBits(aDouble);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (date != null ? date.hashCode() : 0);
        result = 31 * result + (solution != null ? solution.hashCode() : 0);
        return result;
    }
}














package com.javarush.test.level21.lesson08.task01;

import java.util.LinkedHashMap;
import java.util.Map;

/* Глубокое клонирование карты
Клонируйтие объект класса Solution используя глубокое клонирование.
Данные в карте users также должны клонироваться.
Метод main изменять нельзя.
*/
public class Solution implements Cloneable {

    public static void main(String[] args) {
        Solution solution = new Solution();
        solution.users.put("Hubert", new User(172, "Hubert"));
        solution.users.put("Zapp", new User(41, "Zapp"));
        Solution clone = null;
        try {
            clone = solution.clone();
            System.out.println(solution);
            System.out.println(clone);
            System.out.println(solution.users);
            System.out.println(clone.users);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace(System.err);
        }
    }

    protected Map<String, User> users = new LinkedHashMap();

    public Solution clone()throws CloneNotSupportedException{

        Solution clone = (Solution)super.clone();

        clone.users = new LinkedHashMap<>();

        for(Map.Entry<String, User> mEntry : this.users.entrySet()){
            clone.users.put(mEntry.getKey(),mEntry.getValue().clone());
        }

        return clone;
    }

    public static class User implements Cloneable {
        int age;
        String name;

        public User(int age, String name) {
            this.age = age;
            this.name = name;
        }

        public User clone()throws CloneNotSupportedException{

            User user = new User(age, name);
            user.age = this.age;
            user.name = this.name;
            return  user;
        }
    }
}














package com.javarush.test.level21.lesson08.task02;

/* Клонирование
Класс Plant не должен реализовывать интерфейс Cloneable
Реализуйте механизм глубокого клонирования для Tree.
Метод main изменять нельзя.
*/
public class Solution {
    public static void main(String[] args) {
        Tree tree = new Tree("willow", new String[]{"s1", "s2", "s3", "s4"});
        Tree clone = null;
        try {
            clone = tree.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        System.out.println(tree);
        System.out.println(clone);

        System.out.println(tree.branches);
        System.out.println(clone.branches);
    }

    public static class Plant{
        private String name;

        public Plant(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }
    }

    public static class Tree extends Plant implements Cloneable {
        private String[] branches;

        public Tree(String name, String[] branches) {
            super(name);
            this.branches = branches;
        }

        public String[] getBranches() {
            return branches;
        }

        public Tree clone() throws CloneNotSupportedException{

            Tree tree1 = new Tree(super.getName(), branches != null ? this.getBranches().clone() : null);

            return tree1;

        }
    }


}









package com.javarush.test.level21.lesson10.task01;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/* Рефакторинг
Отрефакторите метод writeZipEntriesToFile в соответствии с java7 try-with-resources.
Допускаются только текстовые коментарии.
*/
public class Solution implements AutoCloseable {


    public static void writeZipEntriesToFile(String zipFileName, String outputFileName) throws IOException {
        Charset charset = StandardCharsets.UTF_8;
        Path outputFilePath = Paths.get(outputFileName);


        try (BufferedWriter writer = Files.newBufferedWriter(outputFilePath, charset);
             ZipFile  zip = new ZipFile(zipFileName);)
        {
            String newLine = System.getProperty("line.separator");
            for (Enumeration entries = zip.entries(); entries.hasMoreElements(); )
            {
                // Берем имя файла из архива и записываем его в результирующий файл
                // Get the entry name and write it to the output file
                String zipEntryName = ((ZipEntry) entries.nextElement()).getName() + newLine;
                writer.write(zipEntryName, 0, zipEntryName.length());
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }

    @Override
    public void close() throws Exception {
        throw new Exception();
    }
}











package com.javarush.test.level21.lesson10.task02;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.LinkedList;
import java.util.List;

/* Освобождаем ресурсы
Реализуйте метод finalize, подумайте, что именно в нем должно быть.
Отрефакторите метод getUsers в соответствии с java7 try-with-resources.
Допускаются только текстовые коментарии.
*/
public class Solution implements AutoCloseable {
    private Connection connection;

    public Solution(Connection connection) {
        this.connection = connection;
    }

    public List<User> getUsers() {
        String query = "select ID, DISPLAYED_NAME, LEVEL, LESSON from USER";

        List<User> result = new LinkedList();

        try(Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery(query)){
            while (rs.next()) {
                int id = rs.getInt("ID");
                String name = rs.getString("DISPLAYED_NAME");
                int level = rs.getInt("LEVEL");
                int lesson = rs.getInt("LESSON");

                result.add(new User(id, name, level, lesson));
            }
        } catch (SQLException e){
            e.printStackTrace();
        }
        return result;
    }

    @Override
    protected void finalize() throws Throwable {
        connection.close();
    }

    @Override
    public void close() throws Exception {

    }

    public static class User {
        private int id;
        private String name;
        private int level;
        private int lesson;

        public User(int id, String name, int level, int lesson) {
            this.id = id;
            this.name = name;
            this.level = level;
            this.lesson = lesson;
        }

        @Override
        public String toString() {
            return "User{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", level=" + level +
                    ", lesson=" + lesson +
                    '}';
        }
    }
}











package com.javarush.test.level21.lesson10.task03;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

/* Нюансы Exceptions
Классы семейства Utilizator должны утилизировать ресурсы не влияя на работу программы, т.е. программа должна отрабатывать одинаково с любым из Utilizator-ов.
На данный момент это не выполняется из-за неправильных реализаций утилизаторов. Исправьте реализацию утилизаторов.
Метод main не участвует в тестировании.
UtilizatorUtil не менять.
Стек трейс не выводить.
*/
public class Solution {
    private Utilizator utilizator;

    public void setUtilizator(Utilizator utilizator) {
        this.utilizator = utilizator;
    }

    public static void main(String[] args) {
        List<String> strings = new ArrayList<>();

        Solution solution = new Solution();
        solution.setUtilizator(new Utilizator());

        Solution solution2 = new Solution();
        solution2.setUtilizator(new SpecificUtilizator());

        strings.addAll(solution.readFileContent("FakeFileName.txt"));
        strings.addAll(solution2.readFileContent("FakeFileName2.txt"));
        System.out.println("Count of strings is " + strings.size());
    }

    public List<String> readFileContent(String path) {
        List<String> strings = new ArrayList<>();
        Charset charset = Charset.forName("UTF-8");
        Path filePath = Paths.get(path);
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(path)))) {
            String sCurrentLine;
            while ((sCurrentLine = bufferedReader.readLine()) != null) {
                strings.add(sCurrentLine);
            }
        } catch (IOException ignored) {

        } finally {
            utilizator.dispose();
        }
        return strings;
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("inside finalize - before throwing");
        utilizator.dispose();   //исключения игнорируются в finalize
        System.out.println("inside finalize - after throwing");
    }

    public static class Utilizator {
        protected final UtilizatorUtil util = new UtilizatorUtil();

        public void dispose() {
            //Utilization IS successful
            util.doNothing();
        }
    }

    public static class SpecificUtilizator extends Utilizator {
        @Override
        public void dispose() {
            try {
                util.throwException();
            }catch (RuntimeException e){
                e.printStackTrace();
            }
        }
    }

    public static class UtilizatorUtil {
        public void doNothing() {
        }

        public void throwException() {
            throw new RuntimeException("It`s impossible to dispose resources!");
        }

        public void sout(String message) {
            System.out.println(message);
        }
    }
}















package com.javarush.test.level21.lesson16.big01;

import java.util.ArrayList;

/**
 * Created by Кира on 26.10.2016.
 */
public class Hippodrome {

    public static Hippodrome game;

    ArrayList<Horse> horses = new ArrayList<>();

    public ArrayList<Horse> getHorses() {
        return horses;
    }

    public static void main(String[] args) throws InterruptedException {

        game = new Hippodrome();

        Horse gnedaya = new Horse("Gnedaya", 3, 0);
        Horse rizhyk = new Horse("Rizhyk", 3, 0);
        Horse manya = new Horse("Manya", 3, 0);

        game.getHorses().add(gnedaya);
        game.getHorses().add(rizhyk);
        game.getHorses().add(manya);

        game.run();



    }

    public void run() throws InterruptedException {

        for(int i = 1; i <= 100; i ++){
            print();
            move();
            Thread.sleep(200);
        }

        printWinner();

    }

    public void move(){

        for (Horse h : horses){
            h.move();
        }

    }

    public void print(){

        for (Horse h : horses){
            h.print();

        }
        System.out.println();
        System.out.println();
    }

    public Horse getWinner(){

        double max = 0;

        for(int i = 0; i < horses.size(); i++){
            if(max < horses.get(i).distance){
                max = horses.get(i).distance;
            }
        }

        for(Horse h : horses) {
            if (h.distance == max) {
                return h;
            }
        }

        return null;

    }

    public void printWinner(){

        System.out.println("Winner is " + getWinner().getName() + "!");

    }

}




--------------------

package com.javarush.test.level21.lesson16.big01;

/**
 * Created by Кира on 26.10.2016.
 */
public class Horse {

    public String name;
    public double speed;
    public double distance;

    public Horse(String name, double speed, double distance){
        this.name = name;
        this.speed = speed;
        this.distance = distance;
    }

    public double getDistance() {
        return distance;
    }

    public void setDistance(double distance) {
        this.distance = distance;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public void move(){

        distance += speed*Math.random();

    }

    public void print(){

        String dot = ".";

        for(int i = 0; i < Math.round(distance); i++) {
            System.out.print(dot);
        }
        System.out.print(getName());
        System.out.println();
    }
}














Reflection – это способность класса получить информацию о самом себе. В Java есть специальные классы: Field – поле, 
Method – метод, по аналогии с Class для классов. Т.к. объект типа Class дает возможность получить информацию о классе, 
то объект типа Field–получить информацию о «поле класса», а Method–о «методе класса». И вот что с ними можно делать:

Код	Описание
Class[] interfaces = List.class.getInterfaces();	Получаем список «объектов класса» для интерфейсов класса List
Class parent = String.class.getSuperclass();	Получаем «объект класса» родительского класса для класса String
Method[] methods = List.class.getMethods();	Получаем список методов, которые есть у класса List
String s = String.class.newInstance();	Создаем новый объект класса String
String s = String.class.newInstance();
Method m = String.class.getMethod("length");
int length = (int) m.invoke(s)	Получаем метод length у класса String, вызываем его у строки s









package com.javarush.test.level22.lesson05.task01;

/* Найти подстроку
Метод getPartOfString должен возвращать подстроку начиная с символа после 1-го пробела и до конца слова,
которое следует после 4-го пробела.
Пример: "JavaRush - лучший сервис обучения Java."
Результат: "- лучший сервис обучения"
На некорректные данные бросить исключение TooShortStringException (сделать исключением).
Сигнатуру метода getPartOfString не менять.
Метод main не участвует в тестировании.
*/
public class Solution {

    public static void main(String[] args) throws TooShortStringException {

        System.out.println(getPartOfString("JavaRush - лучший сервис обучения Java."));
    }

    public static String getPartOfString(String string) throws TooShortStringException
    {
        if(string == null) {
            throw new TooShortStringException();
        }

        String[] str = string.split(" "); //[-,лучший,сервис,обучения,....]

        if(str.length < 5){
            throw new TooShortStringException();
        }

        StringBuilder result = new StringBuilder(); //[пустой]

        for (int i = 1; i < 5; i++) {
            result.append(str[i]+" "); //[- лучший сервис обучения ]
        }

        return result.toString().substring(0, result.toString().length()-1); //убираем посл.пробел
    }

    public static class TooShortStringException extends Throwable {
    }
}











package com.javarush.test.level22.lesson05.task02;

/* Между табуляциями
Метод getPartOfString должен возвращать подстроку между первой и второй табуляцией.
На некорректные данные бросить исключение TooShortStringException.
Класс TooShortStringException не менять.
*/
public class Solution {
    public static String getPartOfString(String string) throws TooShortStringException {
        if(string == null){
            throw new TooShortStringException();
        }

        if(string.length() < 2){
            throw new TooShortStringException();
        }

        int s = string.indexOf("\t");
        boolean f = !string.substring(s+1, string.length()).contains("\t");

        if(f){
            throw new TooShortStringException();
        }

        String[] arr = string.split("\t");

        String ch = "";

        if(arr.length == 0){
            return ch;
        }

        for(int i = 0; i < 2; i++){
             ch = arr[i];
        }

        return ch;
    }

    public static class TooShortStringException extends Exception {
    }

    public static void main(String[] args) throws TooShortStringException {
        System.out.println(getPartOfString("tab0\ttab\ttab1\t"));       //tab
        System.out.println(getPartOfString("\t\t"));                    //
        System.out.println(getPartOfString("123\t123"));                //Exception
        System.out.println(getPartOfString(null));                      //Exception
    }
}











/* Форматирование строки
Исправить метод getFormattedString так, чтобы он возвращал строку с параметрами для форматирования.
Для перевода каретки не используйте \n.
Должен быть вывод:
20 / 7 = 2,86
Exp = 3,33e+00
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(String.format(getFormattedString(), 20.0 / 7.0, 10.0 / 3.0));
        //должен быть вывод
        //20 / 7 = 2,86
        //Exp = 3,33e+00
    }

    public static String getFormattedString() {

        return "20 / 7 = %.2f %nExp = %.2e";
    }
}














/* МНЕ нравится курс JavaRush
Исправить метод getFormattedString так, чтобы он возвращал строку с параметрами для форматирования.
Параметры должны меняться местами.
Должен быть вывод:
МНЕ нравится курс JavaRush
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(String.format(getFormattedString(), "JavaRush", "курс", "мне", "нравится"));
        //должен быть вывод
        //"МНЕ нравится курс JavaRush"
    }
    public static String getFormattedString() {

        String s = "%3$S %4$s %2$s %1$s"; //%-для определения формата, 1$(2$,3$,4$..) - порядковый номер, осн. на кол-ве фор
                                            //матрируемых эл-тов, s - опр. фортматриуемого символа(строка)

        return s;

    }
}













package com.javarush.test.level22.lesson07.task03;

import java.util.Date;

/* Форматирование даты
Исправить метод getFormattedString так, чтобы он возвращал строку с параметрами для форматирования.
Должен быть вывод аналогичный следующему:
31:10:13 15:59:59
*/
public class Solution {
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(String.format(getFormattedString(), date, date, date, date, date, date));
        //должен быть вывод аналогичный следующему
        //31:10:13 15:59:59 - dd:MM:yy hh:mm:ss
    }

    public static String getFormattedString() {


        return "%td:%tm:%ty %tH:%tM:%tS";
    }
}










!!!!!!!!!!!!!!!
 /**
     * Returns a fixed-size list backed by the specified array.  (Changes to
     * the returned list "write through" to the array.)  This method acts
     * as bridge between array-based and collection-based APIs, in
     * combination with {@link Collection#toArray}.  The returned list is
     * serializable and implements {@link RandomAccess}.
     *
     * <p>This method also provides a convenient way to create a fixed-size
     * list initialized to contain several elements:
     * <pre>
     *     List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");
     * </pre>
     *
     * @param a the array by which the list will be backed
     * @return a list view of the specified array
     */
    @SafeVarargs
    public static <T> List<T> asList(T... a) {
        return new ArrayList<>(a);
    }
	
--------------------------------------------------------------------------------















package com.javarush.test.level22.lesson09.task01;



import java.io.*;
import java.util.*;

/* Обращенные слова
В методе main с консоли считать имя файла, который содержит слова, разделенные пробелами.
Найти в тексте все пары слов, которые являются обращением друг друга. Добавить их в result.
Порядок слов first/second не влияет на тестирование.
Использовать StringBuilder.
Пример содержимого файла
рот тор торт о
о тот тот тот
Вывод:
рот тор
о о
тот тот
*/
public class Solution {

    public static List<Pair> result = new LinkedList<>();

    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String sourceFileName = reader.readLine();

        FileReader r = new FileReader(sourceFileName);

        Scanner sc = new Scanner(r);

        StringBuilder sb = new StringBuilder();

        while (sc.hasNext()) {
            sb.append(sc.next() + " ");
        }

        reader.close();
        r.close();
        sc.close();

        ArrayList<String> words = new ArrayList<>(Arrays.asList(sb.toString().split(" ")));

        System.out.println(words);

        ArrayList<String> uniqueWords = new ArrayList<>();

        for (int i = 0; i < words.size(); i++) {
            if (!uniqueWords.contains(words.get(i))) {
                uniqueWords.add(words.get(i));
            }
        }

        System.out.println(uniqueWords);

        for (int i = 0; i < uniqueWords.size(); i++) {

            String s = uniqueWords.get(i);
            String reversed = new StringBuffer(s).reverse().toString();

            if (uniqueWords.indexOf(reversed) != -1 & !s.equals("") & !s.equals(reversed)) {
                Pair pair = new Pair();
                pair.first = uniqueWords.get(i);
                pair.second = reversed.toString();
                result.add(pair);
                uniqueWords.set(i, "");
            }
        }
        for (Pair pair: result) System.out.println(pair);

    }

    public static class Pair {
        String first;
        String second;

        @Override
        public String toString() {
            return  first == null && second == null ? "" :
                    first == null && second != null ? second :
                    second == null && first != null ? first :
                    first.compareTo(second) < 0 ? first + " " + second : second + " " + first;

        }
    }

}











package com.javarush.test.level22.lesson09.task02;

import java.util.HashMap;
import java.util.Map;

/* Формируем Where
Сформируйте часть запроса WHERE используя StringBuilder.
Если значение null, то параметр не должен попадать в запрос.
Пример:
{"name", "Ivanov", "country", "Ukraine", "city", "Kiev", "age", null}
Результат:
"name = 'Ivanov' and country = 'Ukraine' and city = 'Kiev'"
*/
public class Solution {

    public static void main(String[] args){

        Map<String, String> map = new HashMap<>();
        map.put("name", "Ivanov");
        map.put("country", "Ukraine");
        map.put("city", "Kiev");
        map.put("age", null);
        map.put("parea", null);
        map.put(null, null);
        map.put("street", "Ivanovskaya");
        map.put("code", "534321");

        System.out.println(getCondition(map));
    }

    public static StringBuilder getCondition(Map<String, String> params) {

        StringBuilder sqlBuilder = new StringBuilder();
        for (Map.Entry<String, String> entry : params.entrySet()) {

            String key = entry.getKey();
            String value = entry.getValue();

            if ((key != null) && (value != null)) {
                if (!(sqlBuilder.toString().isEmpty())){
                    sqlBuilder.append(" and ");
                }

                sqlBuilder.append(key)
                        .append(" = '")
                        .append(value)
                        .append("'");
            }

        }
        String s = sqlBuilder.toString();
        StringBuilder fin = new StringBuilder(s);

        return fin;
    }
}










Следует также отметить, что JVM проводит предварительную группировку полей объекта. Это значит, что все поля класса размещаются в памяти в определенном порядке, а не так как объявлены. Порядок группировки выглядит так:
1. 8-ми байтовые типы(double и long)
2. 4-х байтовые типы(int и float)
3. 2-х байтовые типы(short и char)
4. Одно байтовые типы(boolean и byte)
5. Ссылочные переменные







ЕЩЕ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ


Шаблон	Описание	Примеры
.	Один любой символ	1
\d	Любая цифра	7
\D	Любая нецифра	C
\s	Пробел, перенос строки, символ табуляции	' '
\S	Что угодно, кроме пробела, табуляции, переноса строки	f
[a-z]	Любая буква от a до z	z
[0-9]	Любая цифра от 0 до 9.	8
\w	Любая буква	c
\W	Любая небуква	_


Шаблон	Описание	Примеры
A?	Символ A встречается 0..1 раз	A
B+	Символ B встречается 1.. ∞ раз	BBBB
C*	Символ C встречается 0.. ∞ раз	CCC
D{n}	Символ D встречается n раз	DDDD, для шаблона D{4}
E{n,}	Символ E встречается n.. ∞ раз	EEEEEEE, для шаблона E{2,}
F{n,m}	Символ F встречается n..m раз	EEEE, для шаблона E{2,4}


Шаблон	Описание	Примеры
[a-d]?	Символы a-d встречаются 0..1 раз	a, b, c, d
[b-d,z]+	Символы b,c,d,z встречаются 1.. ∞ раз	b, bcdcdbdbdbdbzzzzbbzbzb, zbz
[1,7-9]*	Символы 1,7,8,9 встречаются 0.. ∞ раз	1, 7, 9, 9777, 111199
1{5}	Символ 1 встречается 5 раз	11111
[1,2,a,b]{2}	Символы 1,2,a,b встречаются 2 раза	11, 12, 1a, ab, 2b, bb, 22
[a,0]{2,3}	Символы a,0 встречаются 2..3 раз	aa, a0,00,0a, aaa,000, a00,0a0, a0a


Т.к. регулярные выражения часто используют для поиска подстрок в строке, то в шаблон добавлены еще два символа ^ и $.

«^» - означает, что подстрока обязана включать начало строки.

«$» - означает, что подстрока обязана включать конец строки.

Примеры:

Шаблон	Строка и найденные подстроки, совпадающие с шаблоном
a{3}	aaa a aaa a aaa
a{3}$	aaa a aaa a aaa
^a{3}	aaa a aaa a aaa
^a{3}$	aaa a aaa a aaa













package com.javarush.test.level22.lesson13.task01;

import java.util.StringTokenizer;

/* StringTokenizer
Используя StringTokenizer разделить query на части по разделителю delimiter.
Пример,
getTokens("level22.lesson13.task01", ".") == {"level22", "lesson13", "task01"}
*/
public class Solution {

    public static void main(String[] args) {
        for (String s: getTokens("level22.lesson13.task01", ".")){
            System.out.print(s);
        }
    }
    public static String [] getTokens(String query, String delimiter) {
        StringTokenizer st = new StringTokenizer(query, delimiter);
        String[] result = new String[st.countTokens()];
        int count = 0;
        while(st.hasMoreTokens()){
            result[count] = st.nextToken();
            count++;
        }
        return result;
    }
}











package com.javarush.test.level22.lesson13.task02;

import java.io.*;
import java.nio.charset.Charset;

/* Смена кодировки
В метод main первым параметром приходит имя файла, тело которого в кодировке Windows-1251.
В метод main вторым параметром приходит имя файла, в который необходимо записать содержимое первого файла в кодировке UTF-8.
*/
public class Solution {
    static String win1251TestString = "РќР°СЂСѓС€РµРЅРёРµ РєРѕРґРёСЂРѕРІРєРё РєРѕРЅСЃРѕР»Рё?"; //only for your testing

    public static void main(String[] args) throws IOException {

        String file1 = args[0];
        String file2 = args[1];

        FileInputStream input = new FileInputStream(file1);
        FileOutputStream output = new FileOutputStream(file2);

        Charset windows1251 = Charset.forName("Windows-1251");
        Charset utf8 = Charset.forName("UTF-8");

        byte[] buffer = new byte[input.available()];

        input.read(buffer);
        String s = new String(buffer, utf8);
        buffer = s.getBytes(windows1251);
        output.write(buffer);

        input.close();
        output.close();

    }
}










PARSING WITH REGEX: _________________________HTML
It is a best practice to use a proper library to parse html, but to find simple tag names, you can use the expression <(\w+).

You can also capture tag contents >([\w\s]*)<, or even attribute values ='([\w://.]*)' if desired (not the goal of this problem though).

---------------------PHONE NUMBER
To grab the area code from the phone numbers, we can simply capture the first three digits, using the expression (\d{3}).

However, to match the full phone number as well, we can use the expression 1?[\s-]?\(?(\d{3})\)?[\s-]?\d{3}[\s-]?\d{4}. This breaks down into the country code '1?',
 the captured area code '\(?(\d{3})\)?', and the rest of the digits '\d{3}' and '\d{4}' respectively. We use '[\s-]?' to catch the space or dashes
 between each component.

--------------------- E-MAIL
To extract the beginning of each email, we can use a simple expression ^([\w\.]*) which will match emails starting with alphanumeric characters including the period. It will match up to the point in the text where it reaches an '@' or '+'.

Again, you should probably use a framework to match emails!



We are only looking for image files ending with the 'jpg', 'png' and 'gif' file extensions, so we can capture all such filenames 
using the expression (\w+)\.(jpg|png|gif)$.



We can just skip all the starting and ending whitespace by not capturing it in a line. For example, the expression ^\s*(.*)\s*$ will catch only the content.



Exercise 7: Extracting Data From Log Entries
Task	Text	Capture Groups	 
Skip	W/dalvikvm( 1553): threadid=1: uncaught exception		To be completed
Skip	E/( 1553): FATAL EXCEPTION: main		To be completed
Skip	E/( 1553): java.lang.StringIndexOutOfBoundsException		To be completed
Capture	E/( 1553):   at widget.List.makeView(ListView.java:1727)	makeView ListView.java 1727	Success
Capture	E/( 1553):   at widget.List.fillDown(ListView.java:652)	fillDown ListView.java 652	Success
Capture	E/( 1553):   at widget.List.fillFrom(ListView.java:709)	fillFrom ListView.java 709	Success

(\w+)\(([\w\.]*):(\d+)\)
Continue ›
Solution	
This one can be tricky too, but we really just want to capture the method name, filename, and line number.
 This can be achieved using the expression (\w+)\(([\w\.]+):(\d+)\) in which the first capture group is the method, followed by an escaped parenthesis,
 followed by the filename, a colon, and finally the line number.






Problem 8: Parsing and extracting data from a URL
When working with files and resources over a network, you will often come across URIs and URLs which can be parsed and worked with directly. Most standard libraries will have classes to parse and construct these kind of identifiers, but if you need to match them in logs or a larger corpus of text, you can use regular expressions to pull out information from their structured format quite easily.

URIs, or Uniform Resource Identifiers, are a representation of a resource that is generally composed of a scheme, host, port (optional), and resource path, respectively highlighted below.

http://regexone.com:80/page
The scheme describes the protocol to communicate with, the host and port describe the source of the resource, and the full path describes the location at the source for the resource.

In the exercise below, try to extract the protocol, host and port of the all the resources listed.

Exercise 8: Extracting Data From URLs
Task	Text	Capture Groups	 
Capture	ftp://file_server.com:21/top_secret/life_changing_plans.pdf	ftp file_server.com 21	Success
Capture	https://regexone.com/lesson/introduction#section	https regexone.com	Success
Capture	file://localhost:4040/zip_file	file localhost 4040	Success
Capture	https://s3cur3-server.com:9999/	https s3cur3-server.com 9999	Success
Capture	market://search/angry%20birds	market search	Success

(\w+)://([\w\-\.]+)(:(\d+))?
Continue ›
Solution	
We have to match each of the three components:

the protocols in our list are all alphanumeric, so they can be matched using (\w+)://
The hosts can contain non-alphanumeric characters like the dash or the period, so we will have to specifically include those characters using ://([\w\-\.]+)
The port is an optional part of the URI and is preceeded with a colon and can be matched using (:(\d+))
To put it all together, we then have the full regular expression (\w+)://([\w\-\.]+)(:(\d+))? to capture all the data we are looking for.









package com.javarush.test.level22.lesson13.task03;

/* Проверка номера телефона
Метод checkTelNumber должен проверять, является ли аргумент telNumber валидным номером телефона.
Критерии валидности:
1) если номер начинается с '+', то он содержит 12 цифр
2) если номер начинается с цифры или открывающей скобки, то он содержит 10 цифр
3) может содержать 0-2 знаков '-', которые не могут идти подряд
4) может содержать 1 пару скобок '(' и ')'  , причем если она есть, то она расположена левее знаков '-'
5) скобки внутри содержат четко 3 цифры
6) номер не содержит букв
7) номер заканчивается на цифру

Примеры:
+380501234567 - true
+38(050)1234567 - true
+38050123-45-67 - true
050123-4567 - true

+38)050(1234567 - false
+38(050)1-23-45-6-7 - false
050ххх4567 - false
050123456 - false
(0)501234567 - false
*/
public class Solution {

    public static void main(String[] args){

        testNumber(null, false);
        testNumber("", false);
        testNumber("+380501234567", true);
        testNumber("+3805012345q67", false);
        testNumber("+3805012345 67", true);
        testNumber("+3805012345.67", false);
        testNumber("+3805012345,67", false);
        testNumber("1-23456789-0", true);
        testNumber("1-23(456)789-0", false);
        testNumber("1-234567(89-0)", false);
        testNumber("1-2345678(9-0)", false);
        testNumber("(1-2)3456789-0", false);
        testNumber("(345)0512027", true);
        testNumber("+-313450531202", true);
        testNumber("+-313450531202-", false);
        testNumber("+380501212334567", false);
        testNumber("+3805012asd34567", false);
        testNumber("+38(050)1234567", true);
        testNumber("+38(150)1234567", true);
        testNumber("+38(050)12-34-567", true);
        testNumber("+38(050)12-34567", true);
        System.out.println("CHECK");
        testNumber("+38(050)112-34567", false);
        System.out.println("CHECK");
        testNumber("+38(050)12-34(5)67", false);
        testNumber("+3(8)(050)12-34567", false);
        testNumber("+38050123-45-67", true);
        testNumber("+38050123-45-6789", false);
        testNumber("050123-4567", true);
        System.out.println("CHECK");
        testNumber("050123-45678", false);
        System.out.println("CHECK");
        testNumber("+38)050(1234567", false);
        testNumber("+38(050)1-23-45-6-7", false);
        testNumber("050ххх4567", false);
        testNumber("050123456", false);
        testNumber("(0)501234567", false);
        testNumber("+38-(050)1234567", false);
        testNumber("38-(050)34567", false);
        testNumber("-38-(050)34567", false);
        testNumber("38-(050)34567-", false);
        testNumber("38(050)3(45)67", false);
        testNumber("(380)(050)3567", false);
        testNumber("+38(380)(050)3567", false);
        testNumber("8(380)(050)367", false);
        testNumber("8(380)4(050)67", false);
        testNumber("+38((050)1234567", false);
        testNumber("+5(0--5)1234567", false);
        testNumber("7-4-4123689-5", false);
        testNumber("+(012)123456789", true);
        testNumber("+(012)1-2345678-9", true);
        testNumber("+(012)1234567", false);
        testNumber("+(01-2)123456789", false);
        testNumber("+(012)12345678--9", false);
        testNumber("+(012)--123456789", false);


    }

    public static void testNumber(String number, boolean expected)
    {
        boolean result = checkTelNumber(number);
        System.out.format("%s:\t%s\t%b\t%b\n", (result == expected ? "OK" : "Fail"), number, result ,expected);
    }

    public static boolean checkTelNumber(String telNumber) {

        if(telNumber == null){
            return false;
        }

        if(telNumber.matches("\\+[\\d]{10}\\s[\\d]{2}")){
            return true;
        }

        if((telNumber.matches("^\\+[\\(\\-]?(\\d[\\(\\)\\-]?){11}\\d$") || telNumber.matches("^\\(?(\\d[\\-\\(\\)]?){9}\\d$"))
                && telNumber.matches("[\\+]?\\d*(\\(\\d{3}\\))?\\d*\\-?\\d*\\-?\\d*\\d$")){
            return true;
        }

        return false;
    }

}









TETRIS


package com.javarush.test.level22.lesson18.big01;

import java.awt.event.KeyEvent;

/**
 *  Класс Tetris - содержит основной функционал игры.
 */
public class Tetris
{

    private Field field;                //Поле с клетками
    private Figure figure;              //Фигурка

    private boolean isGameOver;         //Игра Окончена?

    public Tetris(int width, int height)
    {
        field = new Field(width, height);
        figure = null;
    }

    /**
     * Геттер переменной field.
     */
    public Field getField()
    {
        return field;
    }

    /**
     * Геттер переменной figure.
     */
    public Figure getFigure()
    {
        return figure;
    }

    /**
     *  Основной цикл программы.
     *  Тут происходят все важные действия
     */
    public void run() throws Exception
    {
        //Создаем объект "наблюдатель за клавиатурой" и стартуем его.
        KeyboardObserver keyboardObserver = new KeyboardObserver();
        keyboardObserver.start();

        //выставляем начальное значение переменной "игра окончена" в ЛОЖЬ
        isGameOver = false;
        //создаем первую фигурку посередине сверху: x - половина ширины, y - 0.
        figure = FigureFactory.createRandomFigure(field.getWidth() / 2, 0);

        //пока игра не окончена
        while (!isGameOver)
        {
            //"наблюдатель" содержит события о нажатии клавиш?
            if (keyboardObserver.hasKeyEvents())
            {
                //получить самое первое событие из очереди
                KeyEvent event = keyboardObserver.getEventFromTop();
                //Если равно символу 'q' - выйти из игры.
                if (event.getKeyChar() == 'q') return;
                //Если "стрелка влево" - сдвинуть фигурку влево
                if (event.getKeyCode() == KeyEvent.VK_LEFT)
                    figure.left();
                //Если "стрелка вправо" - сдвинуть фигурку вправо
                else if (event.getKeyCode() ==  KeyEvent.VK_RIGHT)
                    figure.right();
                //Если  код клавиши равен 12 ("цифра 5 на доп. клавиатуре") - повернуть фигурку
                else if (event.getKeyCode() ==  12)
                    figure.rotate();
                //Если "пробел" - фигурка падает вниз на максимум
                else if (event.getKeyCode() ==  KeyEvent.VK_SPACE)
                    figure.downMaximum();
            }

            step();             //делаем очередной шаг
            field.print();      //печатаем состояние "поля"
            Thread.sleep(300);  //пауза 300 миллисекунд - 1/3 секунды
        }

        //Выводим сообщение "Game Over"
        System.out.println("Game Over");
    }

    public void step()
    {
        //опускам фигурку вниз
        figure.down();

        //если разместить фигурку на текущем месте невозможно
        if (!figure.isCurrentPositionAvailable())
        {
            figure.up();                    //поднимаем обратно
            figure.landed();                //приземляем

            isGameOver = figure.getY() <= 1;//если фигурка приземлилась на самом верху - игра окончена

            field.removeFullLines();        //удаляем заполненные линии

            figure = FigureFactory.createRandomFigure(field.getWidth() / 2, 0); //создаем новую фигурку
        }
    }

    /**
     * Сеттер для figure
     */
    public void setFigure(Figure figure)
    {
        this.figure = figure;
    }

    /**
     * Сеттер для field
     */
    public void setField(Field field)
    {
        this.field = field;
    }

    public static Tetris game;
    public static void main(String[] args) throws Exception
    {
        game = new Tetris(10, 20);
        game.run();
    }
}


------------------

package com.javarush.test.level22.lesson18.big01;

/**
 * Клсс FigureFactory отвечает за создание объектов-фигурок.
 */
public class FigureFactory
{
    /**
     * Набор из шести шаблонов для фигурок
     */
    public static final int[][][] BRICKS = {{
            {1, 1, 0},                          //   X X
            {0, 1, 1},                          //     X X
            {0, 0, 0}}, {                       //

            {1, 0, 0},                          //   X
            {1, 1, 0},                          //   X X
            {0, 1, 0}}, {                       //     X

            {0, 1, 0},                          //   X
            {0, 1, 0},                          //   X
            {0, 0, 0}}, {                       //   X

            {1, 1, 0},                          //   X X
            {1, 1, 0},                          //   X X
            {0, 0, 0}}, {                       //

            {1, 1, 1},                          //   X X X
            {0, 1, 0},                          //     X
            {0, 0, 0}}, {                       //

            {1, 1, 1},                          //   X X X
            {1, 1, 1},                          //   X X X
            {0, 0, 0}}                          //
    };

    /**
     * Метод выбирает случайный шаблон и создает с ним новую фигурку.
     */
    public static Figure createRandomFigure(int x, int y)
    {
        int index = (int) (Math.random() * 6);
        return new Figure(x, y, BRICKS[index]);
    }
}


------------------

package com.javarush.test.level22.lesson18.big01;

import java.util.ArrayList;

/**
 * Класс Field описывает "поле клеток" игры Тетрис
 */
public class Field
{
    //ширина и высота
    private int width;
    private int height;

    //матрица поля: 1 - клетка занята, 0 - свободна
    private int[][] matrix;

    public Field(int width, int height)
    {
        this.width = width;
        this.height = height;
        matrix = new int[height][width];
    }

    public int getWidth()
    {
        return width;
    }

    public int getHeight()
    {
        return height;
    }

    public int[][] getMatrix()
    {
        return matrix;
    }

    /**
     * Метод возвращает значение, которое содержится в матрице с координатами (x,y)
     * Если координаты за пределами матрицы, метод возвращает null.
     */
    public Integer getValue(int x, int y)
    {
        if (x >= 0 && x < width && y >= 0 && y < height)
            return matrix[y][x];

        return null;
    }

    /**
     *  Метод устанавливает переданное значение(value) в ячейку матрицы с координатами (x,y)
     */
    public void setValue(int x, int y, int value)
    {
        if (x >= 0 && x < width && y >= 0 && y < height)
            matrix[y][x] = value;
    }

    /**
     * Метод печатает на экран текущее содержание матрицы
     */
    public void print()
    {
        //Создаем массив, куда будем "рисовать" текущее состояние игры
        int[][] canvas = new int[height][width];

        //Копируем "матрицу поля" в массив
        for (int i = 0; i < height; i++)
        {
            for (int j = 0; j < width; j++)
            {
                canvas[i][j] = matrix[i][j];
            }
        }

        //Копируем фигурку в массив, только непустые клетки
        int left = Tetris.game.getFigure().getX();
        int top = Tetris.game.getFigure().getY();
        int[][] brickMatrix = Tetris.game.getFigure().getMatrix();

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (top + i >= height || left + j >= width) continue;
                if (brickMatrix[i][j] == 1)
                    canvas[top + i][left + j] = 2;
            }
        }


        //Выводим "нарисованное" на экран, но начинаем с "границы кадра".
        System.out.println("\n");

        for (int i = 0; i < height; i++)
        {
            for (int j = 0; j < width; j++)
            {
                int index = canvas[i][j];
                if (index == 0)
                    System.out.print(" . ");
                else if (index == 1)
                    System.out.print(" X ");
                else if (index == 2)
                    System.out.print(" X ");
                else
                    System.out.print("???");
            }
            System.out.println();
        }


        System.out.println();
        System.out.println();
    }

    /**
     * Удаляем заполненные линии
     */
    public void removeFullLines()
    {
        //Создаем список для хранения линий
        ArrayList<int[]> lines = new ArrayList<int[]>();

        //Копируем все непустые линии в список.
        for (int i = 0; i <height; i++)
        {
            //подсчитываем количество единиц в строке - просто суммируем все ее значения
            int count = 0;
            for (int j = 0; j < width; j++)
            {
                count += matrix[i][j];
            }

            //Если сумма строки не равно ее ширине - добавляем в список
            if (count != width)
                lines.add(matrix[i]);
        }

        //Добавляем недостающие строки в начало списка.
        while (lines.size()<height)
        {
            lines.add(0,new int[width]);
        }

        //Преобразуем список обратно в матрицу
        matrix = lines.toArray(new int[height][width]);
    }
}

-------------------

package com.javarush.test.level22.lesson18.big01;

import javax.swing.*;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

public class KeyboardObserver extends Thread
{
    private Queue<KeyEvent> keyEvents = new ArrayBlockingQueue<KeyEvent>(100);

    private JFrame frame;

    @Override
    public void run()
    {
        frame = new JFrame("KeyPress Tester");
        frame.setTitle("Transparent JFrame Demo");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        frame.setUndecorated(true);
        frame.setSize(400, 400);
        frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
        frame.setLayout(new GridBagLayout());

        frame.setOpacity(0.0f);
        frame.setVisible(true);

        frame.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                //do nothing
            }

            @Override
            public void focusLost(FocusEvent e)
            {
                System.exit(0);
            }
        });


        frame.addKeyListener(new KeyListener()
        {

            public void keyTyped(KeyEvent e)
            {
                //do nothing
            }

            public void keyReleased(KeyEvent e)
            {
                //do nothing
            }

            public void keyPressed(KeyEvent e)
            {
                keyEvents.add(e);
            }
        });
    }


    public boolean hasKeyEvents()
    {
        return !keyEvents.isEmpty();
    }

    public KeyEvent getEventFromTop()
    {
        return keyEvents.poll();
    }
}

-------------------------------

package com.javarush.test.level22.lesson18.big01;


/**
 * Класс Figure описывает фигурку тетриса
 */
public class Figure
{
    //метрица которая определяет форму фигурки: 1 - клетка не пустая, 0 - пустая
    private int[][] matrix;
    //координаты
    private int x;
    private int y;

    public Figure(int x, int y, int[][] matrix)
    {
        this.x = x;
        this.y = y;
        this.matrix = matrix;
    }

    public int getX()
    {
        return x;
    }

    public int getY()
    {
        return y;
    }

    public int[][] getMatrix()
    {
        return matrix;
    }

    /**
     * Поворачаиваем фигурку.
     * Для простоты - просто вокруг главной диагонали.
     */
    public void rotate()
    {
        int[][] matrix2 = new int[3][3];

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                matrix2[i][j] = matrix[j][i];
            }
        }

        matrix = matrix2;
    }

    /**
     * Двигаем фигурку влево.
     * Проверяем не вылезла ли она за границу поля и/или не залезла ли на занятые клетки.
     */
    public void left()
    {
        x--;
        if (!isCurrentPositionAvailable())
            x++;
    }

    /**
     * Двигаем фигурку вправо.
     * Проверяем не вылезла ли она за границу поля и/или не залезла ли на занятые клетки.
     */
    public void right()
    {
        x++;
        if (!isCurrentPositionAvailable())
            x--;
    }

    /**
     * Двигаем фигурку вверх.
     * Используется, если фигурка залезла на занятые клетки.
     */
    public void up()
    {
        y--;
    }

    /**
     * Двигаем фигурку вниз.
     */
    public void down()
    {
        y++;
    }

    /**
     * Двигаем фигурку вниз до тех пор, пока не залезем на кого-нибудь.
     */
    public void downMaximum()
    {
        while (isCurrentPositionAvailable())
        {
            y++;
        }

        y--;
    }

    /**
     * Проверяем - может ли фигурка находится на текущей позици:
     * а) не вылазиет ли она за границы поля
     * б) не залазиет ли она на занятые клетки
     */
    public boolean isCurrentPositionAvailable()
    {
        Field field = Tetris.game.getField();

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (matrix[i][j] == 1)
                {
                    if (y + i >= field.getHeight())
                        return false;

                    Integer value = field.getValue(x + j, y + i);
                    if (value == null || value == 1)
                        return false;
                }
            }
        }

        return true;
    }

    /**
     * Приземляем фигурку - добавляем все ее непустые клетки к клеткам поля.
     */
    public void landed()
    {
        Field field = Tetris.game.getField();

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (matrix[i][j] == 1)
                    field.setValue(x + j, y + i, 1);
            }
        }
    }
}


















package com.javarush.test.level23.lesson02.task01;

/* Запретите наследование
Запретите наследование от класса Listener.
*/
public class Solution {

    public final static class Listener {
        public void onMouseDown(int x, int y) {
            //do something on mouse down event
        }

        public void onMouseUp(int x, int y) {
            //do something on mouse up event
        }
    }
}












package com.javarush.test.level23.lesson02.task02;

/* Запретите переопределение
Запретите переопределение метода onMouseDown.
*/
public class Solution {

    public static class Listener {
        public final void onMouseDown(int x, int y) {
            //do something on mouse down event
        }

        public void onMouseUp(int x, int y) {
            //do something on mouse up event
        }
    }
}










package com.javarush.test.level23.lesson02.task03;

/* Запретите создание экземпляров класса
Запретите создание экземпляров класса Listener.
*/
public class Solution {

    public abstract static class Listener {

        public void onMouseDown(int x, int y) {
            //do something on mouse down event
        }

        public void onMouseUp(int x, int y) {
            //do something on mouse up event
        }
    }
}









package com.javarush.test.level23.lesson04.task02;

/* Inner 2
В классе SuperUser метод getDescription должен учитывать страну и город, т.е. возвращать результат аналогичный следующему:
My name is George. I'm from the USA, Seattle.
Используйте возможности иннер класса.
*/
public class Solution {
    private String country;
    private String city;

    public Solution(String country, String city) {
        this.country = country;
        this.city = city;
    }

    /*т.к. модификатор иннер класса private, то чтобы вызвать метод getDescription из другого внешнего класса,
    нужно обернуть его вызов в какой-то public метод*/
    public String getDescriptionOfUser(String name) {
        return getTrickyUser(name).getDescription();
    }

    public SuperUser getTrickyUser(String name) {
        return new SuperUser(name);
    }

    private class SuperUser {
        private String name;

        //доступ к этому методу возможен только внутри класса Solution, т.к. модификатор иннер класса private
        public SuperUser(String name) {
            this.name = name;
        }

        //доступ к этому методу возможен только внутри класса Solution, т.к. модификатор иннер класса private
        public String getDescription() {
            return String.format("My name is %s. I'm from %s, %s.", this.name, country, city);
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution("the USA", "Seattle");
        //внутри класса Solution (а сейчас мы внутри) к методу getDescription можно обращаться обоими способами
        System.out.println(solution.getTrickyUser("George").getDescription());
    }
}








package com.javarush.test.level23.lesson04.home01;

import java.util.*;

/* Inner 3
Внутри класса Solution:
1) реализуйте private class TaskDataProvider используя Task и DbMock, цель которого - обновить поле tasks.
2) реализуйте private class NameDataProvider используя String и DbMock, цель которого - обновить поле names.
*/
public class Solution {

    @Override
    public boolean equals(Object obj) {
        Solution object = (Solution) obj;

        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;

        return Objects.equals(names, object.names) && Objects.equals(tasks, object.tasks);
    }

    @Override
    public int hashCode() {
        return Objects.hash(names, tasks);
    }

    public static void main(String[] args){

        Solution sol1 = new Solution();

        List<Solution> s = new ArrayList<>();
        s.add(sol1);

        sol1.refresh();
        System.out.println(s.get(0).equals(sol1));

    }

    private List<Task> tasks;
    private List<String> names;

    private DbDataProvider taskDataProvider = new TaskDataProvider();
    private DbDataProvider nameDataProvider = new NameDataProvider();


    public void refresh() {
        Map taskCriteria = ViewMock.getFakeTasksCriteria();
        taskDataProvider.refreshAllData(taskCriteria);

        Map nameCriteria = ViewMock.getFakeNamesCriteria();
        nameDataProvider.refreshAllData(nameCriteria);
    }

    private interface DbDataProvider<T> {
        void refreshAllData(Map criteria);

    }



    class Task {
    }

    private class TaskDataProvider implements DbDataProvider {

        @Override
        public void refreshAllData(Map criteria) {

            tasks = DbMock.getFakeTasks(criteria);

        }


    }

    private class NameDataProvider implements DbDataProvider {

        @Override
        public void refreshAllData(Map criteria) {

            names = DbMock.getFakeNames(criteria);

        }
    }
}



package com.javarush.test.level23.lesson04.home01;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class DbMock {
    private static final List<Solution.Task> FAKE_TASKS = new ArrayList<>();
    private static final List<String> FAKE_NAMES = new ArrayList<>();

    public static List<Solution.Task> getFakeTasks(Map criteria) {
        return ViewMock.getFakeTasksCriteria().equals(criteria) ? FAKE_TASKS : null;
    }

    public static List<String> getFakeNames(Map criteria) {
        return ViewMock.getFakeNamesCriteria().equals(criteria) ? FAKE_NAMES : null;
    }
}





package com.javarush.test.level23.lesson04.home01;

import java.util.HashMap;
import java.util.Map;

public class ViewMock {
    private static final Map FAKE_TASKS_CRITERIA = new HashMap();
    private static final Map FAKE_NAMES_CRITERIA = new HashMap();

    public static Map getFakeTasksCriteria() {
        return FAKE_TASKS_CRITERIA;
    }

    public static Map getFakeNamesCriteria() {
        return FAKE_NAMES_CRITERIA;
    }
}








package com.javarush.test.level23.lesson06.task01;

/* Как выбрать нужное?
В методе main присвойте объекту Object obj экземпляр класса TEST
Константу TEST и класс TEST менять нельзя.
*/
public class Solution {
    public static final String TEST = "test";

    public static class TEST {
        @Override
        public String toString() {
            return "test class";
        }
    }

    static Object obj;

    public static void main(String[] args) {
        obj = new Solution.TEST();
        System.out.println(obj);
    }
}










package com.javarush.test.level23.lesson06.task02;

/* Рефакторинг
Отрефакторите класс Solution: вынесите все константы в public вложенный(nested) класс Constants.
Запретите наследоваться от Constants.
*/
public class Solution {

    public static final class Constants {

        static final String SERVER_NOT_ACCESSIBLE_EXCEPTION = "Server is not accessible for now.";
        static final String UNAUTHORIZED_USER_EXCEPTION = "User is not authorized.";
        static final String BANNED_USER_EXCEPTION = "User is banned.";
        static final String RESTRICTION_EXCEPTION = "Access is denied.";
    }

    public class ServerNotAccessibleException extends Exception {
        public ServerNotAccessibleException() {
            super(Constants.SERVER_NOT_ACCESSIBLE_EXCEPTION);
        }

        public ServerNotAccessibleException(Throwable cause) {
            super(Constants.SERVER_NOT_ACCESSIBLE_EXCEPTION, cause);
        }
    }

    public class UnauthorizedUserException extends Exception {
        public UnauthorizedUserException() {
            super(Constants.UNAUTHORIZED_USER_EXCEPTION);
        }

        public UnauthorizedUserException(Throwable cause) {
            super(Constants.UNAUTHORIZED_USER_EXCEPTION, cause);
        }
    }

    public class BannedUserException extends Exception {
        public BannedUserException() {
            super(Constants.BANNED_USER_EXCEPTION);
        }

        public BannedUserException(Throwable cause) {
            super(Constants.BANNED_USER_EXCEPTION, cause);
        }
    }

    public class RestrictionException extends Exception {
        public RestrictionException() {
            super(Constants.RESTRICTION_EXCEPTION);
        }

        public RestrictionException(Throwable cause) {
            super(Constants.RESTRICTION_EXCEPTION, cause);
        }
    }
}









package com.javarush.test.level23.lesson08.task01;

/* Напряги извилины!
Метод printName должен выводить свое собственное имя, т.е. "sout"
Сделайте минимум изменений.
*/
public class Solution {
    private String name;

    Solution(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    private void sout() {
        new Solution("sout") {
            void printName() {
                System.out.println(getName());
            }
        }.printName();
    }

    public static void main(String[] args) {
        new Solution("main").sout();
    }
}







package com.javarush.test.level23.lesson08.home01;

import com.javarush.test.level23.lesson08.home01.vo.*;

import java.util.List;

/* Анонимность иногда так приятна!
1. В пакете vo создайте public классы User, Location, Server, Subject, Subscription, которые наследуются от NamedItem
2. В классе Solution для каждого класса создайте свой метод, который возвращает список экземпляров класса.
Например, для класса User это будет - public List<User> getUsers()
Для класса Location это будет - public List<Location> getLocations()
3. Внутри каждого такого метода создайте анонимный класс от AbstractDbSelectExecutor и вызовите его нужный метод.
Подсказка: тело метода должно начинаться так: return new AbstractDbSelectExecutor

4. Пример вывода для User и Location:
Id=5, name='User-5', description=Got by executing 'select * from USER'
Id=1, name='Location-1', description=Got by executing 'select * from LOCATION'

5. Проанализируйте пример вывода и сформируйте правильный query для всех классов.
6. Классы не должны содержать закоментированного кода.
*/
public class Solution {

    public static void main(String[] args) {
        Solution solution = new Solution();
        print(solution.getUsers());
        print(solution.getLocations());
        print(solution.getServers());
        print(solution.getSubjects());
        print(solution.getSubscriptions());
    }

    public static void print(List list) {
        String format = "Id=%d, name='%s', description=%s";
        for (Object obj : list) {
            NamedItem item = (NamedItem) obj;
            System.out.println(String.format(format, item.getId(), item.getName(), item.getDescription()));
        }
    }

    public List<User> getUsers() {
        return new AbstractDbSelectExecutor<User>() {
            @Override
            public String getQuery() {
                return "USER";
            }
        }.execute();
    }

    public List<Location> getLocations() {
        return new AbstractDbSelectExecutor<Location>(){

            @Override
            public String getQuery() {
                return "LOCATION";
            }
        }.execute();
    }

    public List<Server> getServers(){
        return new AbstractDbSelectExecutor<Server>() {
            @Override
            public String getQuery() {
                return "SERVER";
            }
        }.execute();
    }

    public List<Subject> getSubjects() {
        return new AbstractDbSelectExecutor<Subject>(){

            @Override
            public String getQuery() {
                return "SUBJECT";
            }
        }.execute();
    }

    public List<Subscription> getSubscriptions() {
        return new AbstractDbSelectExecutor<Subscription>(){

            @Override
            public String getQuery() {
                return "SUBSCRIPTION";
            }
        }.execute();
    }
}






package com.javarush.test.level23.lesson08.home01;

import com.javarush.test.level23.lesson08.home01.vo.NamedItem;

import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.List;

public abstract class AbstractDbSelectExecutor<T extends NamedItem> {

    public abstract String getQuery();

    /**
     * It's fake method
     *
     * @return a list of 5 fake items
     */
    public List<T> execute() {
        List<T> result = new ArrayList<>();
        //assert the query is not null
        String query = getQuery();
        if (query == null) return result;

        try {
            //generate 5 fake items
            for (int i = 1; i <= 5; i++) {
                T newItem = getNewInstanceOfGenericType();
                newItem.setId(i);
                newItem.setName(newItem.getClass().getSimpleName() + "-" + i);
                newItem.setDescription("Got by executing '" + "select * from " + query + "'");
                result.add(newItem);
            }
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return result;
    }

    //reflection
    //you have to know that it is possible to create new instance of T (generic type) class by using its default constructor
    private T getNewInstanceOfGenericType() throws InstantiationException, IllegalAccessException {
        return (T) ((Class) ((ParameterizedType) this.getClass().
                getGenericSuperclass()).getActualTypeArguments()[0]).newInstance();
    }
}


---------

public clases Subscription, User, Location, Server, Subject extend NamedItem

---------

package com.javarush.test.level23.lesson08.home01.vo;

public class NamedItem {
    private int id;
    private String name;
    private String description;

    public NamedItem() {
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}















package com.javarush.test.level23.lesson08.task02;

/* Повторяем threads
Сделать так, чтобы в методе someActions вызывались только методы класса Solution.
Ожидаемый вывод в методе main:
Amigo: Mmmmm, beef
Amigo: knock knock
Amigo: Zzzzzzz...1 sec
*/
public class Solution {
    public final String name;
    public final String food;
    public final String sound;

    public Solution(String name, String food, String sound) {
        this.name = name;
        this.food = food;
        this.sound = sound;
    }

    public void eat() {
        System.out.println(name + ": Mmmmm, " + food);
    }

    public void play() {
        System.out.println(name + ": " + sound + " " + sound);
    }

    public void sleep(long milliseconds) {
        System.out.println(name + ": Zzzzzzz..." + (milliseconds / 1000) + " sec");
    }

    public void live() throws InterruptedException {
        Thread thread = new Thread() {
            public void run() {
                try {
                    someActions();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            private void someActions() throws InterruptedException {
                eat();
                play();
                sleep(1000);
            }
        };
        thread.start();
        thread.join();
    }

    public static void main(String[] args) throws InterruptedException {
        new Solution("Amigo", "beef", "knock").live();
    }
}












-----------------------------------------ЗМЕЙКА-----------------------------


package com.javarush.test.level23.lesson13.big01;


import java.awt.event.KeyEvent;
import java.util.ArrayList;

/**
 * Основной класс программы.
 */
public class Room
{
    private int width;
    private int height;
    private Snake snake;
    private Mouse mouse;

    public Room(int width, int height, Snake snake)
    {
        this.width = width;
        this.height = height;
        this.snake = snake;
    }

    public Snake getSnake()
    {
        return snake;
    }

    public Mouse getMouse()
    {
        return mouse;
    }

    public int getWidth()
    {
        return width;
    }

    public int getHeight()
    {
        return height;
    }

    public void setWidth(int width)
    {
        this.width = width;
    }

    public void setHeight(int height)
    {
        this.height = height;
    }

    public void setSnake(Snake snake)
    {
        this.snake = snake;
    }

    public void setMouse(Mouse mouse)
    {
        this.mouse = mouse;
    }

    /**
     *  Основной цикл программы.
     *  Тут происходят все важные действия
     */
    public void run()
    {
        //Создаем объект "наблюдатель за клавиатурой" и стартуем его.
        KeyboardObserver keyboardObserver = new KeyboardObserver();
        keyboardObserver.start();

        //пока змея жива
        while (snake.isAlive())
        {
            //"наблюдатель" содержит события о нажатии клавиш?
            if (keyboardObserver.hasKeyEvents())
            {
                KeyEvent event = keyboardObserver.getEventFromTop();
                //Если равно символу 'q' - выйти из игры.
                if (event.getKeyChar() == 'q') return;

                //Если "стрелка влево" - сдвинуть фигурку влево
                if (event.getKeyCode() == KeyEvent.VK_LEFT)
                    snake.setDirection(SnakeDirection.LEFT);
                //Если "стрелка вправо" - сдвинуть фигурку вправо
                else if (event.getKeyCode() == KeyEvent.VK_RIGHT)
                    snake.setDirection(SnakeDirection.RIGHT);
                //Если "стрелка вверх" - сдвинуть фигурку вверх
                else if (event.getKeyCode() == KeyEvent.VK_UP)
                    snake.setDirection(SnakeDirection.UP);
                //Если "стрелка вниз" - сдвинуть фигурку вниз
                else if (event.getKeyCode() == KeyEvent.VK_DOWN)
                    snake.setDirection(SnakeDirection.DOWN);
            }

            snake.move();   //двигаем змею
            print();        //отображаем текущее состояние игры
            sleep();        //пауза между ходами
        }

        //Выводим сообщение "Game Over"
        System.out.println("Game Over!");
    }

    /**
     * Выводим на экран текущее состояние игры
     */
    public void print()
    {
        //Создаем массив, куда будем "рисовать" текущее состояние игры
        int[][] matrix = new int[height][width];

        //Рисуем все кусочки змеи
        ArrayList<SnakeSection> sections = new ArrayList<SnakeSection>(snake.getSections());
        for (SnakeSection snakeSection : sections)
        {
            matrix[snakeSection.getY()][snakeSection.getX()] = 1;
        }

        //Рисуем голову змеи (4 - если змея мертвая)
        matrix[snake.getY()][snake.getX()] = snake.isAlive() ? 2 : 4;

        //Рисуем мышь
        matrix[mouse.getY()][mouse.getX()] = 3;

        //Выводим все это на экран
        String[] symbols = {" . ", " x ", " X ", "^_^", "RIP"};
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                System.out.print(symbols[matrix[y][x]]);
            }
            System.out.println();
        }
        System.out.println();
        System.out.println();
        System.out.println();
    }

    /**
     * Метод вызывается, когда мышь съели
     */
    public void eatMouse()
    {
        createMouse();
    }

    /**
     * Создает новую мышь
     */
    public void createMouse()
    {
        int x = (int) (Math.random() * width);
        int y = (int) (Math.random() * height);

        mouse = new Mouse(x, y);
    }


    public static Room game;

    public static void main(String[] args)
    {
        game = new Room(20, 20, new Snake(10, 10));
        game.snake.setDirection(SnakeDirection.DOWN);
        game.createMouse();
        game.run();
    }

    //Массив "пауз" в зависимости от уровня.
    private static int[] levelDelay = {1000, 600, 550, 500, 480, 460, 440, 420, 400, 380, 360, 340, 320, 300, 285, 270};

    /**
     * Прогрмма делает паузу, длинна которой зависит от длинны змеи.
     */
    public void sleep()
    {
        try
        {
            int level = snake.getSections().size();
            int delay = level < 15 ? levelDelay[level] : 250;
            Thread.sleep(delay);
        }
        catch (InterruptedException e)
        {
        }
    }
}
}

--------------

package com.javarush.test.level23.lesson13.big01;

import java.util.ArrayList;

/**
 * Класс змея
 */
public class Snake
{
    //Направление движения змеи
    private SnakeDirection direction;
    //Состояние - жива змея или нет.
    private boolean isAlive;
    //Список кусочков змеи.
    private ArrayList<SnakeSection> sections = new ArrayList<SnakeSection>();

    public Snake(int x, int y)
    {
        sections = new ArrayList<SnakeSection>();
        sections.add(new SnakeSection(x, y));
        isAlive = true;
    }

    public boolean isAlive()
    {
        return isAlive;
    }

    public int getX()
    {
        return sections.get(0).getX();
    }

    public int getY()
    {
        return sections.get(0).getY();
    }

    public SnakeDirection getDirection()
    {
        return direction;
    }

    public void setDirection(SnakeDirection direction)
    {
        this.direction = direction;
    }

    public ArrayList<SnakeSection> getSections()
    {
        return sections;
    }

    /**
     * Метод перемещает змею на один ход.
     * Направление перемещения задано переменной direction.
     */
    public void move()
    {
        if (!isAlive) return;

        if (direction == SnakeDirection.UP)
            move(0, -1);
        else if (direction == SnakeDirection.RIGHT)
            move(1, 0);
        else if (direction == SnakeDirection.DOWN)
            move(0, 1);
        else if (direction == SnakeDirection.LEFT)
            move(-1, 0);
    }

    /**
     * Метод перемещает змею в соседнюю клетку.
     * Кординаты клетки заданы относительно текущей головы с помощью переменных (dx, dy).
     */
    private void move(int dx, int dy)
    {
        //Создаем новую голову - новый "кусочек змеи".
        SnakeSection head = sections.get(0);
        head = new SnakeSection(head.getX() + dx, head.getY() + dy);

        //Проверяем - не вылезла ли голова за границу комнаты
        checkBorders(head);
        if (!isAlive) return;

        //Проверяем - не пересекает ли змея  саму себя
        checkBody(head);
        if (!isAlive) return;

        //Проверяем - не съела ли змея мышь.
        Mouse mouse = Room.game.getMouse();
        if (head.getX() == mouse.getX() && head.getY() == mouse.getY()) //съела
        {
            sections.add(0, head);                  //Добавили новую голову
            Room.game.eatMouse();                   //Хвот не удаляем, но создаем новую мышь.
        }
        else //просто движется
        {
            sections.add(0, head);                  //добавили новую голову
            sections.remove(sections.size() - 1);   //удалили последний элемент с хвоста
        }
    }

    /**
     *  Метод проверяет - находится ли новая голова в пределах комнаты
     */
    private void checkBorders(SnakeSection head)
    {
        if ((head.getX() < 0 || head.getX() >= Room.game.getWidth()) || head.getY() < 0 || head.getY() >= Room.game.getHeight())
        {
            isAlive = false;
        }
    }

    /**
     *  Метод проверяет - не совпадает ли голова с каким-нибудь участком тела змеи.
     */
    private void checkBody(SnakeSection head)
    {
        if (sections.contains(head))
        {
            isAlive = false;
        }
    }
}
--------------------

package com.javarush.test.level23.lesson13.big01;

public class Mouse
{
    private int x;
    private int y;

    public Mouse(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public int getX()
    {
        return x;
    }

    public int getY()
    {
        return y;
    }
}

---------------------



package com.javarush.test.level23.lesson13.big01;

import java.util.Objects;

public class SnakeSection
{
    private int x;
    private int y;

    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }

    @Override
    public boolean equals(Object obj) {
        SnakeSection object = (SnakeSection) obj;

        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;

        return Objects.equals(x, object.x) && Objects.equals(y, object.y);
    }

    public SnakeSection(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public int getX()
    {
        return x;
    }

    public int getY()
    {
        return y;
    }
}


-------------------


package com.javarush.test.level23.lesson13.big01;


public enum  SnakeDirection
{
    UP,
    RIGHT,
    DOWN,
    LEFT
}


----------------


package com.javarush.test.level23.lesson13.big01;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class KeyboardObserver extends Thread
{
    private Queue<KeyEvent> keyEvents = new ArrayBlockingQueue<KeyEvent>(100);

    private JFrame frame;

    @Override
    public void run()
    {
        frame = new JFrame("KeyPress Tester");
        frame.setTitle("Transparent JFrame Demo");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        frame.setUndecorated(true);
        frame.setSize(400, 400);
        frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
        frame.setLayout(new GridBagLayout());

        frame.setOpacity(0.0f);
        frame.setVisible(true);

        frame.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                //do nothing
            }

            @Override
            public void focusLost(FocusEvent e)
            {
                System.exit(0);
            }
        });


        frame.addKeyListener(new KeyListener()
        {

            public void keyTyped(KeyEvent e)
            {
                //do nothing
            }

            public void keyReleased(KeyEvent e)
            {
                //do nothing
            }

            public void keyPressed(KeyEvent e)
            {
                keyEvents.add(e);
            }
        });
    }


    public boolean hasKeyEvents()
    {
        return !keyEvents.isEmpty();
    }

    public KeyEvent getEventFromTop()
    {
        return keyEvents.poll();
    }
}











package com.javarush.test.TempPack;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

/**
 * Created by Кира on 02.11.2016.
 */
public class KeyCodesList {

    public static void main(String[] args) {


        Field[] fields = java.awt.event.KeyEvent.class.getDeclaredFields();
        for (
                Field f
                : fields)

        {
            if (Modifier.isStatic(f.getModifiers())) {
                System.out.println(f.getName());
            }
        }
    }
}











package com.javarush.test.level24.lesson02.task01;

/* Cloneable
Добавьте java-код, чтобы метод main отработал без исключений.
Удалять что-либо нельзя.
*/
public class Solution {

    public static void main(String[] args) throws CloneNotSupportedException {
        Test1 test1 = new Test1();
        test1.clone();

        Test2 test2 = new Test2();
        test2.clone(new Test2());

        Test3 test3 = new Test3();
        test3.c1one();

        Test4 test4 = new Test4();
        test4.clone();
    }


    public static class Test1 implements Cloneable {
        protected Test1 clone() throws CloneNotSupportedException {
            return (Test1)super.clone();
        }
    }

    public static class Test2 extends Test1 {
        public Test2 clone(Test2 test2) throws CloneNotSupportedException {
            return (Test2)test2.clone();
        }
    }

    public static class Test3 {
        protected Object c1one() throws CloneNotSupportedException {
            return new Test3();
        }
    }

    public static class Test4 extends Test3 implements Cloneable {
        protected Object c1one() throws CloneNotSupportedException {
            return super.c1one();
        }

        protected Test4 clone() throws CloneNotSupportedException {
            return (Test4) super.clone();
        }
    }
}







package com.javarush.test.level24.lesson02.home01;

/* Создание своего интерфейса-маркера
1. Создайте интерфейс-маркер SelfInterfaceMarker
2. Создайте класс SelfInterfaceMarkerImpl, который реализует SelfInterfaceMarker
3. Добавьте в SelfInterfaceMarkerImpl минимум 2 любых различных public метода (дефолтовый public конструктор должен присутствовать)
4. Создайте исключение UnsupportedInterfaceMarkerException
5. В методе testClass класса Util: если параметр == null, то выбросьте UnsupportedInterfaceMarkerException
*/
public class Solution {
    public static void main(String[] args) throws UnsupportedInterfaceMarkerException {
        SelfInterfaceMarkerImpl obj = new SelfInterfaceMarkerImpl();
        Util.testClass(obj);
    }

}



package com.javarush.test.level24.lesson02.home01;

/**
 * Created by Кира on 02.11.2016.
 */
public class UnsupportedInterfaceMarkerException extends Exception {


    public UnsupportedInterfaceMarkerException(){

    }
}





package com.javarush.test.level24.lesson02.home01;

/**
 * Created by Кира on 02.11.2016.
 */
public class SelfInterfaceMarkerImpl implements SelfInterfaceMarker {

    public SelfInterfaceMarkerImpl(){

    }

    public void stub(){
        System.out.println("Stub!");
    }

    public void stub1(){
        System.out.println("Stub111!!");
    }
}




package com.javarush.test.level24.lesson02.home01;

/**
 * Created by Кира on 02.11.2016.
 */
public interface SelfInterfaceMarker {
}



package com.javarush.test.level24.lesson02.home01;

import java.lang.reflect.Method;

public class Util {

    //пример того, как можно использовать интерфейс-маркер
    //this method is available only for a SelfInterfaceMarker implementation
    public static void testClass(SelfInterfaceMarker interfaceMarker) throws UnsupportedInterfaceMarkerException {
        if(interfaceMarker == null){
            throw  new UnsupportedInterfaceMarkerException();
        }
        for (Method method : interfaceMarker.getClass().getDeclaredMethods()) {
                System.out.println(method);
        }
    }

}










package com.javarush.test.level24.lesson02.task02;

import java.io.Serializable;
import java.rmi.Remote;
import java.util.ArrayDeque;
import java.util.EventListener;

/* Так-с...сопоставим
Исправьте ошибки: переместите методы clone в те классы, в которых они должны быть реализованы.
Лишние методы удалите.
*/
public class Solution {


    public static class A implements Serializable {

    }

    public static class B implements Remote {

    }

    public static class C extends ArrayDeque {

        public C clone() {
            return (C) super.clone();
        }
    }

    public static class D implements EventListener {

    }


}







package com.javarush.test.level24.lesson04.task01;

import java.math.BigDecimal;

/* Наследование от внутреннего класса
Внутри класса Solution создайте 2 внутренних public класса Apt3Bedroom, BigHall.
Унаследуйте их от Apartments и Hall.
*/
public class Solution {
    public class Building {
        public class Hall {
            private BigDecimal square;

            public Hall(BigDecimal square) {
                this.square = square;
            }
        }

        public class Apartments {
        }
    }

    public class Apt3Bedroom extends Building.Apartments {

        public Apt3Bedroom(Building apt)
        {
            apt.super();
        }
    }

    public class BigHall extends Building.Hall {

        public BigHall(Building building, BigDecimal square)
        {
            building.super(square);
        }
    }
}









package com.javarush.test.level24.lesson04.home01;

/* Рефакторинг
В классе Rectangle:
1. Измените методы getHeight и getWidth, чтобы они возвращали HasHeight и HasWidth соответственно.
2. Для этого внутри методов getHeight и getWidth создайте локальные классы - реализации интерфейсов.
3. Переименуйте getHeight в castToHasHeight, getWidth в castToHasWidth (на имени метода нажмите Shift+F6).
4. Уберите наследование интерфейсов в классе  Rectangle.
Методы интерфейсов не менять.
*/
public class Solution {
    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle(1, 2, 3, 4);

        /////////////////////expected//////////////////
        System.out.println(getHeight(rectangle.castToHasHeight()));
        System.out.println(getWidth(rectangle.castToHasWidth()));
    }

    public static double getHeight(HasHeight rectangle) {
        return rectangle.getHeight();
    }

    public static double getWidth(HasWidth rectangle) {
        return rectangle.getWidth();
    }


    public static class Rectangle{
        private Point point1;
        private Point point2;

        public Rectangle(double x1, double y1, double x2, double y2) {
            point1 = new Point(x1, y1);
            point2 = new Point(x2, y2);
        }

        public HasHeight castToHasHeight() {
            return new HasHeight() {
                @Override
                public double getHeight() {
                    return Math.abs(point1.getY() - point2.getY());
                }
            };
        }

        public HasWidth castToHasWidth() {
            return new HasWidth() {
                @Override
                public double getWidth() {
                    return Math.abs(point1.getX() - point2.getX());
                }
            };
        }
    }
}


package com.javarush.test.level24.lesson04.home01;

public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }
}


package com.javarush.test.level24.lesson04.home01;

public interface HasWidth {
    double getWidth();
}


package com.javarush.test.level24.lesson04.home01;

public interface HasHeight {
    double getHeight();
}












package com.javarush.test.level24.lesson04.home02;

/* Black box
1. Восстановите логику метода someAction для поля solutionAction.
2. Пример вывода смотрите коментарием к методу main.
3. Подсказка: метод someAction анонимного класса поля solutionAction должен вызвать метод сабкласса FirstClass,
если param > 0, иначе вызвать метод сабкласса SecondClass
4. Свои строки создавать нельзя.
5. Классы Action, FirstClass, SecondClass менять нельзя.
*/
public class Solution implements Action {

    public static int countActionObjects;

    private int param;

    private Action solutionAction = new Action() {
        FirstClass firstClass;
        SecondClass secondClass;

        public void someAction() {
            if (param > 0)
            {
                firstClass = new FirstClass()
                {
                    @Override
                    public Action getDependantAction()
                    {
                        return new Action()
                        {
                            @Override
                            public void someAction()
                            {
                            }
                        };
                    }
                };
                int limit = param;
                for (int i = 0; i < limit; i++)
                    System.out.println(param--);
                firstClass.someAction();
            }
            secondClass = new SecondClass();
            secondClass.someAction();
            System.out.print(SecondClass.SPECIFIC_ACTION_FOR_ANONYMOUS_SECOND_CLASS_PARAM);
            System.out.println(param);
        }
    };


    public Solution(int param) {
        this.param = param;
    }

    @Override
    public void someAction() {
        solutionAction.someAction();
    }

    /**
     * 5
     * 4
     * 3
     * 2
     * 1
     * class FirstClass, method someAction
     * class SecondClass, method someAction
     * Specific action for anonymous SecondClass, param = 0
     * Count of created Action objects is 2
     * class SecondClass, method someAction
     * Specific action for anonymous SecondClass, param = -1
     * Count of created Action objects is 3
     */
    public static void main(String[] args) {
        Solution solution = new Solution(5);
        solution.someAction();
        System.out.println("Count of created Action objects is " + countActionObjects);

        solution = new Solution(-1);
        solution.someAction();
        System.out.println("Count of created Action objects is " + countActionObjects);
    }
}




package com.javarush.test.level24.lesson04.home02;

public abstract class FirstClass implements Action {     //first implementation

    protected FirstClass() {
        Solution.countActionObjects++;
    }

    public void someAction() {
        System.out.println("class FirstClass, method someAction");
    }

    public abstract Action getDependantAction();
}



package com.javarush.test.level24.lesson04.home02;

public class SecondClass implements Action {   //second implementation

    public static String SPECIFIC_ACTION_FOR_ANONYMOUS_SECOND_CLASS_PARAM = "\nSpecific action for anonymous SecondClass, param = ";

    private static String SECOND_CLASS_METHOD_STRING = "class SecondClass, method someAction";

    public SecondClass() {
        Solution.countActionObjects++;
    }
    protected StringBuilder sb = new StringBuilder(SECOND_CLASS_METHOD_STRING);

    public void someAction() {
        System.out.println(sb.toString());
    }
}


package com.javarush.test.level24.lesson04.home02;

public interface Action {
    void someAction();
}














package com.javarush.test.level24.lesson02.task01;

/* Cloneable
Добавьте java-код, чтобы метод main отработал без исключений.
Удалять что-либо нельзя.
*/
public class Solution {

    public static void main(String[] args) throws CloneNotSupportedException {
        Test1 test1 = new Test1();
        test1.clone();

        Test2 test2 = new Test2();
        test2.clone(new Test2());

        Test3 test3 = new Test3();
        test3.c1one();

        Test4 test4 = new Test4();
        test4.clone();
    }


    public static class Test1 implements Cloneable {
        protected Test1 clone() throws CloneNotSupportedException {
            return (Test1)super.clone();
        }
    }

    public static class Test2 extends Test1 {
        public Test2 clone(Test2 test2) throws CloneNotSupportedException {
            return (Test2)test2.clone();
        }
    }

    public static class Test3 {
        protected Object c1one() throws CloneNotSupportedException {
            return new Test3();
        }
    }

    public static class Test4 extends Test3 implements Cloneable {
        protected Object c1one() throws CloneNotSupportedException {
            return super.c1one();
        }

        protected Test4 clone() throws CloneNotSupportedException {
            return (Test4) super.clone();
        }
    }
}











package com.javarush.test.level24.lesson06.home01;

import java.util.List;

/* Реализация интерфейса используя локальный класс
В классе Cat реализуйте логику метода toSayable, которая описана в джавадоке.
*/
public class Solution {
    public static void main(String[] args) {
        List<Pet> pet = Util.getPets();
        List<Sayable> pets = Util.convertPetToSayable(pet);
        Util.printDialog(pets);
    }
}


package com.javarush.test.level24.lesson06.home01;

import java.util.LinkedList;
import java.util.List;

public class Util {
    //Util отлично работает со всеми классами Cat, Mouse. А ведь Mouse отличается от Cat.
    public static void printDialog(List<Sayable> pets) {
        for (int i = 0; i < pets.size(); i++) {
            System.out.println(pets.get(i).say());
        }
    }

    public static List<Pet> getPets() {
        List<Pet> pets = new LinkedList<>();
        pets.add(new Cat("Мурзик"));
        pets.add(new Cat("Васька"));
        pets.add(new Cat("Кошка"));
        pets.add(new Mouse());
        pets.add(new Cat("Томас"));
        return pets;
    }

    public static List<Sayable> convertPetToSayable(List<Pet> pets) {
        List<Sayable> result = new LinkedList<>();
        for (Pet pet : pets) {
            int i = (int) (Math.random() * 7) - 2;
            result.add(pet.toSayable(i));
        }
        return result;
    }
}


package com.javarush.test.level24.lesson06.home01;

/*
обратите внимание, как именно Mouse отличается от Cat
Этот класс - привычный для вас.
*/
public class Mouse implements Pet, Sayable {
    @Override
    public Sayable toSayable(int i) {
        return this;
    }

    @Override
    public String say() {
        return "Мыша пищит.";
    }
}


package com.javarush.test.level24.lesson06.home01;

/*
В работе вам иногда будет нужно закастить класс к какому-нибудь интерфейсу (тут Sayable),
который не реализован в текущем классе
 */
public class Cat implements Pet {
    private String name;

    public Cat(String name) {
        this.name = name;
    }

    /**
     * Это - механизм адаптирования к другому интерфейсу - Sayable
     * Внутри метода toSayable создайте class CatPet, реализующий интерфейс Sayable
     * Логика метода say:
     * Если i <= 0, то вывести на экран, что кот спит. Пример, "Васька спит."'
     * Иначе вывести фразу: "имя_кота говорит мяу!". Пример для i=3, "Васька говорит мяяяу!"
     * <p/>
     * <b>Пример вывода:</b>
     * Мурзик спит.
     * Васька говорит мяяу!
     * Кошка говорит мяяяяяу!
     * Мыша пищит.
     * Томас говорит мяу!
     * <p/>
     * @param i количество букв 'я' в слове мяу
     * @return экземпляр класса CatPet
     */
    public Sayable toSayable(final int i) {

        class CatPet implements Sayable {

            private final String name;

            public CatPet(String name){
                this.name = name;

            }

            String saying = "";

            @Override
            public String say() {

                String temp = "";
                if(i <= 0){
                   saying = (name + " спит.");
                }
                else{
                    for(int j = 1; j <= i; j++){
                        temp += "я";
                    }
                    saying = String.format(name + " говорит м%sу!", temp);
                }

                return saying;
            }
        }

        return new CatPet(name);
    }
}


package com.javarush.test.level24.lesson06.home01;

public interface Sayable {
    String say();
}

package com.javarush.test.level24.lesson06.home01;

public interface Pet {
    public Sayable toSayable(int i);
}









package com.javarush.test.level24.lesson06.home02;

import java.util.List;

/* Как избежать Copy+Paste
В классе Dog реализуйте логику метода toSayable, которая описана в джавадоке.
*/
public class Solution {
    public static void main(String[] args) {
        List<Pet> pet = Util.getPets();
        List<Sayable> pets = Util.convertPetToSayable(pet);
        Util.printDialog(pets);
    }
}



package com.javarush.test.level24.lesson06.home02;

import java.util.LinkedList;
import java.util.List;

public class Util {
    //Util отлично работает с классами Dog, Mouse.
    public static void printDialog(List<Sayable> pets) {
        for (int i = 0; i < pets.size(); i++) {
            System.out.println(pets.get(i).say());
        }
    }

    public static List<Pet> getPets() {
        List<Pet> pets = new LinkedList<>();
        pets.add(new Dog("Барбос"));
        pets.add(new Dog("Тузик"));
        pets.add(new Dog("Бобик"));
        pets.add(new Mouse());
        pets.add(new Dog("Шарик"));
        return pets;
    }

    public static List<Sayable> convertPetToSayable(List<Pet> pets) {
        List<Sayable> result = new LinkedList<>();
        for (Pet pet : pets) {
            int i = (int) (Math.random() * 7) - 2;
            result.add(pet.toSayable(i));
        }
        return result;
    }
}





package com.javarush.test.level24.lesson06.home02;

import java.util.Date;

/*
В работе вам иногда будет нужно закастить класс к какому-нибудь другому классу, не интерфейсу :)))
Класс DogPet использует 2 класса - SuperDog и Dog, разберись с getName в классе DogPet
Так намного лучше, чем Copy+Paste!
 */
public class Dog implements Pet {
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    /**
     * Если так получилось, что есть готовый класс А (тут SuperDog) с логикой, которую вы хотите использовать.
     * То возможны 3 способа:
     * 1) из класса А скопировать логику себе (это плохо, т.к. поддерживать несколько копий одного и того же кода проблематично)
     * 2) создать экземпляр класса А внутри нашего класса и использовать его, связь has-a (не всегда подходит, т.к. класс А сам по себе)
     * 3) создать внутренний класс, который наследуется от А, использовать его методы вместе с
     * методами и полями нашего класса, т.к. внутренний класс имеет доступ к своему родителю как наследник,
     * а также ко всем полям и методам включая private того класса, в который он вложен.
     * <p/>
     * Итак, разбираемся с п.3:
     * Внутри метода toSayable создайте class DogPet, который наследуется от SuperDog и реализует интерфейс Sayable
     * создайте метод private String getName(), который будет использовать логику двух классов - Dog и SuperDog.
     * Пусть этот метод возвращает имя собаки (класс Dog), которое с обеих сторон выделено getSuperQuotes (класс SuperDog)
     * Пример, " *** Барбос *** "
     * Логика метода say:
     * Если i <= 0, то используя метод getName вывести на экран, что собака спит. Пример, " *** Шарик ***  спит."
     * Иначе вывести фразу: "имя_собаки лает гааав! сегодняшняя_дата". Пример для i=3, " *** Тузик ***  лает гааав! 13-ноя-2013 Ср"
     * Для форматирования даты используйте formatter из класса SuperDog.
     * <p/>
     * <b>Пример вывода:</b>
     *  *** Барбос ***  лает гааааав! 13-ноя-2013 Ср
     *  *** Тузик ***  лает гаав! 13-ноя-2013 Ср
     *  *** Бобик ***  лает гааав! 13-ноя-2013 Ср
     * Мыша пищит.
     *  *** Шарик ***  спит.
     *
     * @param i количество букв 'а' в слове гав
     * @return экземпляр класса DogPet
     */
    public Sayable toSayable(final int i) {

        class DogPet extends SuperDog implements Sayable{
            private String getName(){
                return getSuperQuotes()+name+getSuperQuotes();
            }
            @Override
            public String say()
            {
                String scream="";
                for (int j = 0; j < i; j++) scream+="а";
                return i<=0 ? getName()+" спит." : getName()+" лает г"+scream+"в! "+formatter.format(new Date());
            }
        }
        return new DogPet();
    }
}



package com.javarush.test.level24.lesson06.home02;

import java.text.SimpleDateFormat;

public abstract class SuperDog {
    protected String getSuperQuotes() {
        //some logic here
        return " *** ";
    }

    protected SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy EEE");
}


package com.javarush.test.level24.lesson06.home02;

/*
обратите внимание, как именно Mouse отличается от Dog
Этот класс - привычный для вас.
*/
public class Mouse implements Pet, Sayable {
    @Override
    public Sayable toSayable(int i) {
        return this;
    }

    @Override
    public String say() {
        return "Мыша пищит.";
    }
}


package com.javarush.test.level24.lesson06.home02;

public interface Sayable {
    String say();
}
package com.javarush.test.level24.lesson06.home02;

public interface Pet {
    public Sayable toSayable(int i);
}











import java.util.List;

/* Интернет-магазин продажи джинсов
1.Внутри файла Solution.java, но НЕ внутри класса Solution создайте 2 интерфейса:
1.1) Item с методами int getId(), double getPrice(), String getTM()
1.2) Jeans extends Item с методами int getLength() и int getSize()
2. В классе Util в методе getAllJeans добавьте пропущенную часть java-кода:
2.1) разберитесь в том, что уже есть в методе getAllJeans класса Util
2.2) создайте абстрактный class AbstractJeans от интерфейса Jeans с одним абстрактным методом, реализуйте остальные методы
2.3) создайте классы Levis и Denim от AbstractJeans, реализуйте оставшийся метод
2.4) в классе AbstractJeans реализуйте метод toString() используя  Alt+Insert -> toString()
2.5) метод toString класса AbstractJeans должен начинаться с имени сабкласса, например, Levis{id=1, length=34, size=6, price=150.0}
*/
public class Solution {

    public static List<Jeans> allJeans = Util.getAllJeans();

    public static void main(String[] args) {
        for (Jeans jeans : allJeans) {
            System.out.println(jeans);
        }
    }

}




package com.javarush.test.level24.lesson06.home03;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

public class Util {
    protected static Collection<Object[]> jeansArray = new LinkedList<>();

    static {
        jeansArray.add(new Object[]{1, Company.Levis, 34, 6, 150.0});
        jeansArray.add(new Object[]{2, Company.Denim, 35, 8, 154.0});
        jeansArray.add(new Object[]{3, Company.Colins, 32, 6, 120.0});
        jeansArray.add(new Object[]{4, Company.CalvinKleinJeans, 31, 8, 125.0});
    }

    public static List<Jeans> getAllJeans() {

        abstract class AbstractJeans implements Jeans {
            int length;
            int size;
            int id;
            double price;

            protected AbstractJeans(int id, int length, int size, double price)
            {
                this.id = id;
                this.length = length;
                this.size = size;
                this.price = price;
            }

            @Override
            public int getLength()
            {
                return length;
            }

            @Override
            public int getSize()
            {
                return size;
            }

            @Override
            public int getId()
            {
                return id;
            }

            @Override
            public double getPrice()
            {
                return price;
            }

            @Override
            public String toString()
            {
                return getTM() +"{" +
                        "id=" + id +
                        ", length=" + length +
                        ", size=" + size +
                        ", price=" + price +
                        '}';
            }

        }
        class Levis extends AbstractJeans {
            String TM;

            Levis(int id, int length, int size, double price)
            {
                super(id, length, size, price);
            }

            @Override
            public String getTM()
            {
                return TM;
            }

        }

        class Denim extends AbstractJeans {
            String TM;

            Denim(int id, int length, int size, double price)
            {
                super(id, length, size, price);
            }

            @Override
            public String getTM()
            {
                return TM;
            }

        }

        List<Jeans> allJeans = new LinkedList<>();

        for (Object[] obj : getJeansArray()) {
            int id = (int) obj[0];
            final Company company = (Company ) obj[1];
            int length = (int) obj[2];
            int size = (int) obj[3];
            double price = (double) obj[4];

            Jeans jeans = null;
            if (Company.Levis == company) {
                jeans = new Levis(id, length, size, price);
            } else
            if (Company.Denim == company) {
                jeans = new Denim(id, length, size, price);
            } else {
                jeans = new AbstractJeans(id, length, size, price) {
                    public String getTM() {
                        return company.fullName;
                    }
                };
            }
            allJeans.add(jeans);
        }
        return allJeans;
    }

    public static Collection<Object[]> getJeansArray() {
        return jeansArray;
    }

    static enum Company {
        Levis ("Levi's"),
        Denim("Denim"),
        Colins("COLIN'S"),
        CalvinKleinJeans("Calvin Klein Jeans");

        final String fullName;
        Company(String name) {
            this.fullName = name;
        }
    }
}


package com.javarush.test.level24.lesson06.home03;

/**
 * Created by Кира on 03.11.2016.
 */
interface Item {

    int getId();

    double getPrice();

    String getTM();
}


package com.javarush.test.level24.lesson06.home03;

/**
 * Created by Кира on 03.11.2016.
 */
interface Jeans extends Item {

    int getLength();

    int getSize();


}









package com.javarush.test.level24.lesson09.task01;

/* Вспомним наследование
Исправить наследование во всех классах, чтобы вывод метода main был CCBAYS
*/
public class Solution extends C {

    public static void main(String[] args) {
        new Solution();
    }


    private class A{
        protected String value = "A";

        public A() {
            System.out.print(value);
        }
    }

    private A a = new A() {
        { //у анонимных классов нет своих конструкторов, но что-то можно сделать в блоке инициализации класса
            value = "Y";
            if (super.getClass().getName().contains(".Solution$")) {
                System.out.print(value);
            }
        }
    };

    public Solution() {
        System.out.print("S");
    }


}

interface JustAnInterface {
    public static final B B = new B();

    class B extends C{
        public B() {
            System.out.print("B");
        }
    }
}

class C implements JustAnInterface {
    public C() {
        System.out.print("C");
        B localB = B;
    }
}









package com.javarush.test.level24.lesson09.home01;

import java.util.LinkedList;
import java.util.List;

/* Рефакторинг
Сделайте так, чтобы метод getIterator возвращал анонимный класс.
Перенесите логику LocalIterator в анонимный класс.
Меняйте только тело метода getIterator.
*/
public class Solution {
    public static List<Iterator> iterators = new LinkedList<>();

    private int countItems = 0;

    public Iterator getIterator(final String name) {


        return new Iterator()
        {

            @Override
            public Iterator next()
            {
                countItems++;
                System.out.println(name + " item " + countItems);
                return this;
            }
        }.next();
    }


        /**class LocalIterator implements Iterator {
            public LocalIterator() {
                countItems++;
                System.out.println(name + " item " + countItems);
            }

            public Iterator next() {
                return new LocalIterator();
            }
        }
        return new LocalIterator();
         */

    public static void main(String[] args) {
        Solution solution = new Solution();

        Iterator iterator = solution.getIterator("iterator");
        for (int i = 1; i < 5; i++) {
            iterators.add(iterator.next());
        }
    }
}

package com.javarush.test.level24.lesson09.home01;

public interface Iterator {
    Iterator next();
}













ARCANOID

package com.javarush.test.level24.lesson14.big01;

import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Главный класс игры
 */
public class Arcanoid
{
    //ширина и высота
    private int width;
    private int height;

    //список кирпичей
    private ArrayList<Brick> bricks = new ArrayList<Brick>();
    //шарик
    private Ball ball;
    //подставка
    private Stand stand;

    //игра закончена?
    private boolean isGameOver = false;

    public Arcanoid(int width, int height)
    {
        this.width = width;
        this.height = height;
    }

    public ArrayList<Brick> getBricks()
    {
        return bricks;
    }

    public Ball getBall()
    {
        return ball;
    }

    public void setBall(Ball ball)
    {
        this.ball = ball;
    }

    public Stand getStand()
    {
        return stand;
    }

    public void setStand(Stand stand)
    {
        this.stand = stand;
    }

    /**
     * Рисуем на холсте границы и все объекты.
     */
    public void draw(Canvas canvas)
    {
        //отрисуй границы
        //отрисуй кирпичи
        //отрисуй шарик
        //отрисуй подставку
        drawBoders(canvas);
        for(Brick b : getBricks()){
            b.draw(canvas);
        }
        ball.draw(canvas);
        stand.draw(canvas);
    }

    /**
     * Рисуем на холсте границы
     */
    private void drawBoders(Canvas canvas)
    {
        //draw game
        for (int i = 0; i < width + 2; i++)
        {
            for (int j = 0; j < height + 2; j++)
            {
                canvas.setPoint(i, j, '.');
            }
        }

        for (int i = 0; i < width + 2; i++)
        {
            canvas.setPoint(i, 0, '-');
            canvas.setPoint(i, height + 1, '-');
        }

        for (int i = 0; i < height + 2; i++)
        {
            canvas.setPoint(0, i, '|');
            canvas.setPoint(width + 1, i, '|');
        }
    }

    /**
     *  Основной цикл программы.
     *  Тут происходят все важные действия
     */
    public void run() throws Exception
    {
        //Создаем холст для отрисовки.
        Canvas canvas = new Canvas(width, height);

        //Создаем объект "наблюдатель за клавиатурой" и стартуем его.
        KeyboardObserver keyboardObserver = new KeyboardObserver();
        keyboardObserver.start();

        //Исполняем цикл, пока игра не окончека
        while (!isGameOver)
        {
            //"наблюдатель" содержит события о нажатии клавиш?
            if (keyboardObserver.hasKeyEvents())
            {
                KeyEvent event = keyboardObserver.getEventFromTop();

                //Если "стрелка влево" - сдвинуть фигурку влево
                if (event.getKeyCode() == KeyEvent.VK_LEFT)
                    stand.moveLeft();
                //Если "стрелка вправо" - сдвинуть фигурку вправо
                else if (event.getKeyCode() == KeyEvent.VK_RIGHT)
                    stand.moveRight();
                //Если "пробел" - запускаем шарик
                else if (event.getKeyCode() == KeyEvent.VK_SPACE)
                    ball.start();
            }

            //двигаем все объекты
            move();

            //проверяем столкновения
            checkBricksBump();
            checkStandBump();

            //проверяем, что шарик мог улететь через дно.
            checkEndGame();

            //отрисовываем все объекты
            canvas.clear();
            draw(canvas);
            canvas.print();

            //пауза
            Thread.sleep(300);
        }

        //Выводим сообщение "Game Over"
        System.out.println("Game Over!");
    }

    /**
     * Двигаем шарик и подставку.
     */
    public void move()
    {
        //двигай шарик
        //двигай подставку
        stand.move();
        ball.move();
    }

    /**
     * Проверяем столкновение с кирпичами.
     * Если столкновение было - шарик отлетает в случайном направлении 0..360 градусов
     */
    public void checkBricksBump()
    {
        //Тут проверь - столкнулся ли шарик с кирпичем.
        //Если да - кирпичь удалить, а шарик запустить в случайно направлении.

        Iterator<Brick> brickIterator = bricks.iterator();
        while (brickIterator.hasNext()) {
            if (ball.isIntersec(brickIterator.next())) {
                double angel = Math.random() * 360;
                ball.setDirection(angel);
                brickIterator.remove();
            }
        }
    }

    /**
     * Проверяем столкновение с подставкой.
     * Если столкновение было - шарик отлетает в случайном направлении  вверх 80..100 градусов.
     */
    public void checkStandBump()
    {
        //Тут проверь - столкнулся ли шарик с подставкой.
        //Если да - запустить шарик  вверх на 80..100 градусов.

        if(ball.isIntersec(stand)){
            double angel = 80 + Math.random()*20;
            ball.setDirection(angel);
        }
    }

    /**
     * Проверяем - не улетел ли шарик через дно.
     * Если да - игра окончена (isGameOver = true)
     */
    public void checkEndGame()
    {
        //Если шарик улетел за нижнюю границы - игра окончена.

        //Если координата y шарика больше??? чем высота поля игры (height), значит шарик улетел вниз за границу экрана
        //В этом случае надо переменную isGameOver установить в true

        if (ball.y > getHeight())
            isGameOver = true;

    }

    public int getWidth()
    {
        return width;
    }

    public int getHeight()
    {
        return height;
    }

    public void setWidth(int width)
    {
        this.width = width;
    }

    public void setHeight(int height)
    {
        this.height = height;
    }

    public static Arcanoid game;

    public static void main(String[] args) throws Exception
    {
        game = new Arcanoid(20, 30);

        Ball ball = new Ball(10, 29, 2,  95);
        game.setBall(ball);

        Stand stand = new Stand(10, 30);
        game.setStand(stand);

        game.getBricks().add(new Brick(3, 3));
        game.getBricks().add(new Brick(7, 5));
        game.getBricks().add(new Brick(12, 5));
        game.getBricks().add(new Brick(16, 3));

        game.run();
    }
}


package com.javarush.test.level24.lesson14.big01;

/**
 * Класс-холст для отрисовки.
 */
public class Canvas
{
    //ширина и высота
    private int width;
    private int height;
    //матрица, где рисуем. символ - это цвет.
    private char[][] matrix;

    public Canvas(int width, int height)
    {
        this.width = width;
        this.height = height;
        this.matrix = new char[height + 2][width + 2];
    }

    /**
     * Очищаем холст
     */
    public void clear()
    {
        this.matrix = new char[height + 2][width + 2];
    }

    /**
     * Печатаем переданную фигуру в указанных координатах уветом c.
     * Если переданный массив содержит единицы, то на холсте им будут соответствовать символы - с.
     */
    public void drawMatrix(double x, double y, int[][] matrix, char c)
    {
        int height = matrix.length;
        int width = matrix[0].length;

        for (int i = 0; i < height; i++)
        {
            for (int j = 0; j < width; j++)
            {
                if (matrix[i][j] == 1)
                    setPoint(x + j, y + i, c);
            }
        }
    }

    /**
     * Ставим одну точку на холсте с координатами (x,y) и цветом - c.
     */
    public void setPoint(double x, double y, char c)
    {
        int x0 = (int) Math.round(x);
        int y0 = (int) Math.round(y);
        if (y0 < 0 || y0 >= matrix.length) return;
        if (x0 < 0 || x0 >= matrix[y0].length) return;

        matrix[y0][x0] = c;
    }

    /**
     * Печатаем содержимое холста на экран.
     */
    public void print()
    {
        System.out.println();

        for (int i = 0; i < height + 2; i++)
        {
            for (int j = 0; j < width + 2; j++)
            {
                System.out.print(" ");
                System.out.print(matrix[i][j]);
                System.out.print(" ");
            }

            System.out.println();
        }

        System.out.println();
        System.out.println();
        System.out.println();
    }

    public int getWidth()
    {
        return width;
    }

    public int getHeight()
    {
        return height;
    }

    public char[][] getMatrix()
    {
        return matrix;
    }
}


package com.javarush.test.level24.lesson14.big01;

/**
 *  Подставка, с помощью которой отражаем мячик.
 */
public class Stand extends BaseObject
{
    //картинка для отрисовки
    private static int[][] matrix = {
            {1, 1, 1, 1, 1},
            {1, 0, 0, 0, 1},
            {0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0},
    };

    //скорость
    private double speed = 1;
    //направление (-1 влево, +1 вправо)
    private double direction = 0;

    public Stand(double x, double y)
    {
        super(x,y,3);
    }

    /**
     * Метод передвигает подставку в соответствии с текущим значением direction.
     */
    public void move()
    {
        double dx = speed * direction;
        x = x + dx;

        checkBorders(radius, Arcanoid.game.getWidth() - radius + 1, 1, Arcanoid.game.getHeight() + 1);
    }

    /**
     * direction устанавливается равным -1
     */
    public void moveLeft()
    {
        direction = -1;
    }

    /**
     * direction устанавливается равным +1
     */
    public void moveRight()
    {
        direction = 1;
    }

    public double getSpeed()
    {
        return speed;
    }

    public double getDirection()
    {
        return direction;
    }

    /**
     * Отрисовываем себя на холсте
     */
    @Override
    public void draw(Canvas canvas)
    {
        canvas.drawMatrix(x - radius + 1, y, matrix, 'M');
    }
}



package com.javarush.test.level24.lesson14.big01;

/**
 * Класс для объекта "кирпич".
 */
public class Brick extends BaseObject
{
    //картинка для отрисовки
    private static int[][] matrix = {
            {0, 0, 0, 0, 0},
            {0, 1, 1, 1, 0},
            {0, 1, 1, 1, 0},
            {0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0},
    };

    public Brick(double x, double y)
    {
        super(x,y,3);
    }

    /**
     * Рисуем себя на холсте
     */
    @Override
    public void draw(Canvas canvas)
    {
        canvas.drawMatrix(x - radius + 1, y, matrix, 'H');
    }

    /**
     * Ничего не делаем - кирпич неподвижен
     */
    @Override
    public void move()
    {
        //do nothing
    }
}



package com.javarush.test.level24.lesson14.big01;

/**
 * Класс для шарика в игре
 */
public class Ball extends BaseObject
{
    //скорость
    private double speed;
    //направление  (в градусах от 0 до 360)
    private double direction;

    //текущее значение вектора движения (dx,dy)
    private double dx;
    private double dy;

    //заморожен ли объект или может двигаться
    private boolean isFrozen;

    public Ball(double x, double y, double speed, double direction)
    {
        super(x, y, 1);

        this.direction = direction;
        this.speed = speed;

        this.isFrozen = true;
    }

    public double getSpeed()
    {
        return speed;
    }

    public void setSpeed(double speed)
    {
        this.speed = speed;
    }

    public double getDirection()
    {
        return direction;
    }

    public double getDx()
    {
        return dx;
    }

    public double getDy()
    {
        return dy;
    }

    /**
     * Устанавливаем новое направление движения.
     * Тут же вычисляем и новый вектор.
     * Такой подход удобно использовать при отскоках от стен.
     */
    public void setDirection(double direction)
    {
        this.direction = direction;

        double angle = Math.toRadians(direction);
        dx = Math.cos(angle) * speed;
        dy = -Math.sin(angle) * speed;
    }

    /**
     * Рисуем себя на "канвасе".
     */
    @Override
    public void draw(Canvas canvas)
    {
        canvas.setPoint(x, y, 'O');
    }

    /**
     * Двигаем себя на один шаг.
     */
    public void move()
    {
        if (isFrozen) return;

        x += dx;
        y += dy;

        checkRebound(1, Arcanoid.game.getWidth(), 1, Arcanoid.game.getHeight() + 5);
    }

    /**
     * Проверяем не улетел ли шарик за стенку.
     * Если да - отражаем его.
     */
    public void checkRebound(int minx, int maxx, int miny, int maxy)
    {
        if (x < minx)
        {
            x = minx + (minx - x);
            dx = -dx;
        }

        if (x > maxx)
        {
            x = maxx - (x - maxx);
            dx = -dx;
        }

        if (y < miny)
        {
            y = miny + (miny - y);
            dy = -dy;
        }

        if (y > maxy)
        {
            y = maxy - (y - maxy);
            dy = -dy;
        }
    }

    /**
     * Запускам шарик.
     * isFrozen = false.
     * Пересчитываем вектор движения (dx,dy).
     */
    public void start()
    {
        this.setDirection(direction);
        this.isFrozen = false;
    }
}


package com.javarush.test.level24.lesson14.big01;

/**
 * Базовый класс для всех объектов игры.
 */
public abstract class BaseObject
{
    //координаты
    protected double x;
    protected double y;
    //радиус объекта
    protected double radius;

    protected BaseObject(double x, double y, double radius)
    {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    public double getX()
    {
        return x;
    }

    public void setX(double x)
    {
        this.x = x;
    }

    public double getY()
    {
        return y;
    }

    public void setY(double y)
    {
        this.y = y;
    }

    public double getRadius()
    {
        return radius;
    }

    public void setRadius(double radius)
    {
        this.radius = radius;
    }

    /**
     * Метод рисует свой объект на "канвасе".
     */
    public abstract void draw(Canvas canvas);

    /**
     * Двигаем себя на один ход.
     */
    public abstract void move();

    /**
     * Проверяем - не выходит ли (x,y) за границы.
     */
    public void checkBorders(double minx, double maxx, double miny, double maxy)
    {
        if (x < minx) x = minx;
        if (x > maxx) x = maxx;
        if (y < miny) y = miny;
        if (y > maxy) y = maxy;
    }

    /**
     * Проверяем - пересекаются ли переданный(o) и наш(this) объекты.
     */
    public boolean isIntersec(BaseObject o)
    {
        double dx = x - o.x;
        double dy = y - o.y;
        double destination = Math.sqrt(dx * dx + dy * dy);
        double destination2 = Math.max(radius, o.radius);

        return destination <= destination2;
    }
}


package com.javarush.test.level24.lesson14.big01;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.concurrent.ArrayBlockingQueue;

import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.util.Queue;

public class KeyboardObserver extends Thread
{
    private Queue<KeyEvent> keyEvents = new ArrayBlockingQueue<KeyEvent>(100);

    private JFrame frame;

    @Override
    public void run()
    {
        frame = new JFrame("KeyPress Tester");
        frame.setTitle("Transparent JFrame Demo");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        frame.setUndecorated(true);
        frame.setSize(400, 400);
        frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
        frame.setLayout(new GridBagLayout());

        frame.setOpacity(0.0f);
        frame.setVisible(true);

        frame.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                //do nothing
            }

            @Override
            public void focusLost(FocusEvent e)
            {
                System.exit(0);
            }
        });


        frame.addKeyListener(new KeyListener()
        {

            public void keyTyped(KeyEvent e)
            {
                //do nothing
            }

            public void keyReleased(KeyEvent e)
            {
                //do nothing
            }

            public void keyPressed(KeyEvent e)
            {
                keyEvents.add(e);
            }
        });
    }


    public boolean hasKeyEvents()
    {
        return !keyEvents.isEmpty();
    }

    public KeyEvent getEventFromTop()
    {
        return keyEvents.poll();
    }
}
















package com.javarush.test.level24.lesson09.task02;

import java.text.*;
import java.util.*;

/* Знания - сила!
1. В методе sort написать компаратор для Stock:
1.1. Первичная сортировка по name в алфавитном порядке
1.2. Вторичная сортировка по дате без учета часов, минут, секунд (сверху самые новые), потом по прибыли от положительных к отрицательным
... open 125,64 and last 126,74 - тут прибыль = 126,74-125,64
... open 125,64 and last 123,43 - тут прибыль = 123,43-125,64
2. Разобраться с *Format-ами и исправить IllegalArgumentException. Подсказка - это одна строчка.
Пример вывода:
Fake Apple Inc.   AAPL | 17-11-2025 open 125,64 and last 123,43
Fake Oracle Corporation   ORCL | 21-08-1989 closed 0,15
*/
public class Solution {
    public static void main(String[] args) {
        List<Stock> stocks = getStocks();
        sort(stocks);
        Date actualDate = new Date();
        printStocks(stocks, actualDate);
    }

    public static void printStocks(List<Stock> stocks, Date actualDate) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy");

        double[] filelimits = {0d, actualDate.getTime()};
        String[] filepart = {"closed {4}", "open {2} and last {3}"};

        ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
        Format[] testFormats = {null, null, dateFormat, fileform};
        MessageFormat pattform = new MessageFormat("{0}   {1} | {5} {6}");
        pattform.setFormats(testFormats);

        for (Stock stock : stocks) {
            String name = ((String) stock.get("name"));
            String symbol = (String) stock.get("symbol");
            double open = !stock.containsKey("open") ? 0 : ((double) stock.get("open"));
            double last = !stock.containsKey("last") ? 0 : ((double) stock.get("last"));
            double change = !stock.containsKey("change") ? 0 : ((double) stock.get("change"));
            Date date = (Date) stock.get("date");
            Object[] testArgs = {name, symbol, open, last, change, date, date.getTime()};
            System.out.println(pattform.format(testArgs));
        }
    }

    public static void sort(List<Stock> list) {

        /**
         * 1.1. Первичная сортировка по name в алфавитном порядке
         1.2. Вторичная сортировка по дате без учета часов, минут, секунд (сверху самые новые), потом по прибыли от положительных к отрицательным
         ... open 125,64 and last 126,74 - тут прибыль = 126,74-125,64
         ... open 125,64 and last 123,43 - тут прибыль = 123,43-125,64
         2. Разобраться с *Format-ами и исправить IllegalArgumentException. Подсказка - это одна строчка.
         Пример вывода:
         Fake Apple Inc.   AAPL | 17-11-2025 open 125,64 and last 123,43
         Fake Oracle Corporation   ORCL | 21-08-1989 closed 0,15
         */
        Collections.sort(list, new Comparator<Stock>() {
            public int compare(Stock stock1, Stock stock2) {

                int compareResult = ((String) stock1.get("name")).compareTo((String) stock2.get("name"));
                if (compareResult != 0) {
                    return compareResult;
                } else {
                    DateFormat outputFormatter = new SimpleDateFormat("MM/dd/yyyy");
                    String output1 = outputFormatter.format((Date) stock1.get("date"));
                    String output2 = outputFormatter.format((Date) stock2.get("date"));
                    compareResult = (output1.compareTo(output2));
                    if (compareResult != 0) {
                        return compareResult;
                    } else {
                        Double change1;
                        Double change2;
                        if (stock1.containsKey("change")) {
                            change1 = (Double) stock1.get("change");
                        } else
                            change1 = (Double) stock1.get("last") - (Double) stock1.get("open");

                        if (stock2.containsKey("change")) {
                            change2 = (Double) stock2.get("change");
                        } else
                            change2 = (Double) stock2.get("last") - (Double) stock2.get("open");

                        int compareChanges = change2.compareTo(change1);
                        if (compareChanges != 0)
                            return compareChanges;
                        else
                            return 0;
                    }
                }
            }

        });
    }

    public static class Stock extends HashMap {
        public Stock(String name, String symbol, double open, double last) {
            put("name", name);
            put("symbol", symbol);
            put("open", open);
            put("last", last);
            put("date", getRandomDate(2020));
        }

        public Stock(String name, String symbol, double change, Date date) {
            put("name", name);
            put("symbol", symbol);
            put("date", date);
            put("change", change);
        }
    }

    public static List<Stock> getStocks() {
        List<Stock> stocks = new ArrayList();

        stocks.add(new Stock("Fake Apple Inc.", "AAPL", 125.64, 123.43));
        stocks.add(new Stock("Fake Cisco Systems, Inc.", "CSCO", 25.84, 26.3));
        stocks.add(new Stock("Fake Google Inc.", "GOOG", 516.2, 512.6));
        stocks.add(new Stock("Fake Intel Corporation", "INTC", 21.36, 21.53));
        stocks.add(new Stock("Fake Level 3 Communications, Inc.", "LVLT", 5.55, 5.54));
        stocks.add(new Stock("Fake Microsoft Corporation", "MSFT", 29.56, 29.72));

        stocks.add(new Stock("Fake Nokia Corporation (ADR)", "NOK", .1, getRandomDate()));
        stocks.add(new Stock("Fake Oracle Corporation", "ORCL", .15, getRandomDate()));
        stocks.add(new Stock("Fake Starbucks Corporation", "SBUX", .03, getRandomDate()));
        stocks.add(new Stock("Fake Yahoo! Inc.", "YHOO", .32, getRandomDate()));
        stocks.add(new Stock("Fake Applied Materials, Inc.", "AMAT", .26, getRandomDate()));
        stocks.add(new Stock("Fake Comcast Corporation", "CMCSA", .5, getRandomDate()));
        stocks.add(new Stock("Fake Sirius Satellite", "SIRI", -.03, getRandomDate()));

        return stocks;
    }

    public static Date getRandomDate() {
        return getRandomDate(1970);
    }

    public static Date getRandomDate(int startYear) {
        int year = startYear + (int) (Math.random() * 30);
        int month = (int) (Math.random() * 12);
        int day = (int) (Math.random() * 28);
        GregorianCalendar calendar = new GregorianCalendar(year, month, day);
        return calendar.getTime();
    }
}





ENUM METHODS:

Direction direction = Direction.LEFT;
int index = direction.ordinal();
int index2 = Direction.RIGHT.ordinal();
2) У каждого enum’а есть метод values(), который возвращает массив значений enum’а.

 
int leftIndex = Direction.LEFT.ordinal();

Direction[] array = Direction.values();
Direction left = array[leftIndex];










package com.javarush.test.level25.lesson02.task01;

/* Новые возможности!
Используя возможности enum-а реализуйте метод getLetterPosition, который должен возвращать позицию буквы (A - 1).
Не должно быть закоментированного кода.
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(Alphabet.G.getLetterPosition());
    }

    public enum Alphabet {
        A, B, C, D, E,
        F, G, H, I, J,
        K, L, M, N, O,
        P, Q, R, S, T,
        U, V, W, X, Y, Z;

        int getLetterPosition() {
            return ordinal()+1;
        }
    }
}














package com.javarush.test.level25.lesson02.home01;

/* Свой enum
Реализуйте интерфейс Columnable у Column, описание методов смотрите в джавадоках.
Реализуйте логику метода Column.getVisibleColumns.
Создавать дополнительные поля нельзя.
Метод main не участвует в тестировании.
*/
public class Solution {
    /**
     * Output:
     * <p/>
     * Available Amount
     * Account Number
     * Bank Name
     * --------------------
     * Available Amount
     * Bank Name
     */
    public static void main(String[] args) {

        Column.configureColumns(Column.Amount, Column.AccountNumber, Column.BankName);

        for (Columnable columnable : Column.getVisibleColumns()) {
            System.out.println(columnable.getColumnName());
        }

        System.out.println("--------------------");
        Column.AccountNumber.hide();

        for (Columnable columnable : Column.getVisibleColumns()) {
            System.out.println(columnable.getColumnName());
        }
    }
}



package com.javarush.test.level25.lesson02.home01;

public interface Columnable {

    /**
     * @return полное имя колонки
     */
    String getColumnName();

    /**
     * Возвращает true, если колонка видимая, иначе false
     */
    boolean isShown();

    /**
     * Скрывает колонку - маркирует колонку -1 в массиве realOrder.
     * Сдвигает индексы отображаемых колонок, которые идут после скрытой
     */
    void hide();

    /**
     * Возвращает порядок константы в энуме.
     *
     * @return порядок константы в энуме
     */
    int ordinal();
}



package com.javarush.test.level25.lesson02.home01;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public enum Column implements Columnable {
    Customer("Customer"),
    BankName("Bank Name"),
    AccountNumber("Account Number"),
    Amount("Available Amount");

    private String columnName;

    private static int[] realOrder;

    private Column(String columnName) {
        this.columnName = columnName;
    }

    /**
     * Задает новый порядок отображения колонок, который хранится в массиве realOrder.
     * realOrder[индекс в энуме] = порядок отображения; -1, если колонка не отображается.
     *
     * @param newOrder новая последовательность колонок, в которой они будут отображаться в таблице
     * @throws IllegalArgumentException при дубликате колонки
     */
    public static void configureColumns(Column... newOrder) {
        realOrder = new int[values().length];
        for (Column column : values()) {
            realOrder[column.ordinal()] = -1;
            boolean isFound = false;

            for (int i = 0; i < newOrder.length; i++) {
                if (column == newOrder[i]) {
                    if (isFound) {
                        throw new IllegalArgumentException("Column '" + column.columnName + "' is already configured.");
                    }
                    realOrder[column.ordinal()] = i;
                    isFound = true;
                }
            }
        }
    }

    /**
     * Вычисляет и возвращает список отображаемых колонок в сконфигурированом порядке (см. метод configureColumns)
     * Используется поле realOrder.
     *
     * @return список колонок
     */
    public static List<Column> getVisibleColumns() {
        List<Column> result = new LinkedList<>();

        Map<Integer, Column> map = new TreeMap<>();
        for (int i = 0; i < realOrder.length; i++) {
            map.put(realOrder[i], Column.values()[i]);
        }

        for (Map.Entry<Integer, Column> entry : map.entrySet()){
            if (entry.getKey() != -1)
                result.add(entry.getValue());
        }
        return result;

    }

    @Override
    public String getColumnName() {
        return columnName;
    }

    @Override
    public boolean isShown() {
        return realOrder[this.ordinal()] != -1;
    }

    @Override
    public void hide() {
       realOrder[this.ordinal()] = -1;
    }
}















package com.javarush.test.level25.lesson02.task02;

import java.util.ArrayList;
import java.util.List;

/* Машину на СТО не повезем!
Инициализируйте поле wheels используя данные из loadWheelNamesFromDB.
Обработайте некорректные данные.
Подсказка: если что-то не то с колесами, то это не машина!
Сигнатуры не менять.
*/
public class Solution {

    public static void main(String[] args) {

        Car car = new Car();

        car.loadWheelNamesFromDB();

    }

    public static enum Wheel {
        FRONT_LEFT,
        FRONT_RIGHT,
        BACK_LEFT,
        BACK_RIGHT
    }

    public static class Car {
        protected List<Wheel> wheels;

        public Car() {
            //init wheels here

            Wheel frontRight = Wheel.FRONT_RIGHT;
            Wheel backRight = Wheel.BACK_RIGHT;
            Wheel frontLeft = Wheel.FRONT_LEFT;
            Wheel backLeft = Wheel.BACK_LEFT;

            wheels = new ArrayList<Wheel>();

            if(loadWheelNamesFromDB().length != 4){
                System.out.println("Car is broken!");
            }

            for(int i = 0; i < loadWheelNamesFromDB().length; i ++) {
                if(loadWheelNamesFromDB()[i].equals(frontLeft.toString())||loadWheelNamesFromDB()[i].equals(frontRight.toString())||
                        loadWheelNamesFromDB()[i].equals(backLeft.toString())||loadWheelNamesFromDB()[i].equals(backRight.toString())) {
                    wheels.add(Wheel.valueOf(loadWheelNamesFromDB()[i]));
                }
                else {
                    System.out.println("Car is really broken!");
                    break;
                }
            }
        }

        protected String[] loadWheelNamesFromDB() {
            //this method returns mock data
            return new String[]{"FRONT_LEFT", "FRONT_RIGHT", "BACK_LEFT", "BACK_RIGHT"};
        }
    }
}











package com.javarush.test.level25.lesson05.task01;

/* Switch для нитей
Обработайте список нитей в зависимости от состояния:
1. Если нить еще не запущена, то запустите ее.
2. Если нить в ожидании, то прервите ее.
3. Если нить работает, то проверить маркер isInterrupted.
4. Если нить прекратила работу, то выведите в консоль ее приоритет.
Используйте switch.
*/
public class Solution extends Thread {

    public static void processThreads(Thread... threads) {

        for (Thread t : threads) {

            switch (t.getState())
            {
                case NEW:
                    t.start();
                    break;
                case WAITING:
                    t.interrupt();
                    break;
                case TIMED_WAITING:
                    t.interrupt();
                    break;
                case RUNNABLE:
                    t.isInterrupted();
                    break;
                case BLOCKED:
                    t.interrupt();
                    break;
                case TERMINATED:
                    System.out.println(t.getPriority());
                    break;
                default:
                    break;
            }
        }
        //implement this method - реализуйте этот метод
    }


}












package com.javarush.test.level25.lesson05.home01;

/* Мониторинг состояния нити
В отдельном классе создать нить LoggingStateThread,
которая будет выводить в консоль все состояния (State) переданной в конструктор нити.
Нить LoggingStateThread должна сама завершаться после остановки переданной в конструктор нити.
Метод main не участвует в тестировании.
*/
public class Solution extends Thread {
    public static void main(String[] args) throws InterruptedException {
        Thread target = new Thread();
        LoggingStateThread loggingStateThread = new LoggingStateThread(target);

        loggingStateThread.start();
        Thread.sleep(3);
        target.start();  //NEW
        Thread.sleep(100); //RUNNABLE
        target.join(100);
        Thread.sleep(400);
        target.interrupted(); //TERMINATED
        Thread.sleep(500);
    }
}



package com.javarush.test.level25.lesson05.home01;

/**
 * Created by Кира on 04.11.2016.
 */
public class LoggingStateThread extends Thread {

        private Thread target;
        private State state;

        public LoggingStateThread(Thread target) {
            this.target = target;
            setDaemon(true);
        }

    /**
     * currentState = runnable
     вывели на экран runnable
     state = null (т.к. еще не чем не инициализировали) и соотв. не равно State.TERMINATED
     currentState = runnable (допустим еще не произошло изменение состояния)
     currentState != state - условие выпоняется т.к. state = null
     печатаем второй раз runnable
     */

    @Override
    public void run() {

        State currentState = target.getState();
        System.out.println(currentState);

        while (state != State.TERMINATED) {
            currentState = target.getState();
            if (currentState != state) {
                state = currentState;
                System.out.println(state);
            }
        }
    }


}









package com.javarush.test.level25.lesson05.task02;

/* Без дураков
1. Создай private class MyUncaughtExceptionHandler, который на перехват исключения должен подождать половину секунды,
а затем вывести на экран secretKey, имя трэда и сообщение возникшего исключения.
Используй String.format(...). Пример:
super secret key, Thread-0, it's an example
2. Разберитесь в последовательности выполняемого кода и обеспечьте логирование возникновения исключения в п.1.
3. Метод main в тестировании не участвует.
*/
public class Solution {

    public static void main(String[] args) throws Exception {
        MyThread myThread = new Solution().new MyThread("super secret key");
        myThread.start();
    }

    public class MyThread extends Thread
    {
        private String secretKey;
        public MyThread(String secretKey)
        {
            this.secretKey = secretKey;
            setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
            setDaemon(false);
        }
        @Override
        public void run()
        {
            throw new NullPointerException("it's an example");
        }
        private class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler
        {
            @Override
            public void uncaughtException(Thread t, Throwable e)
            {
                try
                {

                    Thread.sleep(500);
                    System.out.println(String.format("%s, %s, %s", secretKey, t.getName(), e.getMessage()));
                }
                catch (InterruptedException e1)
                {
                    e1.printStackTrace();
                }
            }
        }
    }
}











package com.javarush.test.level25.lesson07.task01;

import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;

/* Работать в поте лица!
Реализуйте логику метода interrupt, который должен прерывать трэд предварительно закрыв используемые ресурсы
Используйте метод super-класса в блоке finally
*/
public class Solution extends Thread {

    private static final int BUFFER_SIZE = 2000;    //2000 bytes
    private final Socket socket;
    private final InputStream in;

    public Solution(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }

    public void interrupt() {
        //implement logic here

        try {

            socket.close();
            in.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void run() {
        try {
            byte[] buf = new byte[BUFFER_SIZE];
            while (true) {
                int count = in.read(buf);
                if (count < 0) {
                    break;
                } else {
                }
            }
        } catch (IOException ignored) {
            ignored.printStackTrace();
        }finally {
            interrupt();
        }
    }
}










package com.javarush.test.level25.lesson07.task01;

import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;

/* Работать в поте лица!
Реализуйте логику метода interrupt, который должен прерывать трэд предварительно закрыв используемые ресурсы
Используйте метод super-класса в блоке finally
*/
public class Solution extends Thread {

    private static final int BUFFER_SIZE = 2000;    //2000 bytes
    private final Socket socket;
    private final InputStream in;

    public Solution(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }

    public void interrupt() {
        //implement logic here

        try {

            socket.close();
            in.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void run() {
        try {
            byte[] buf = new byte[BUFFER_SIZE];
            while (true) {
                int count = in.read(buf);
                if (count < 0) {
                    break;
                } else {
                }
            }
        } catch (IOException ignored) {
            ignored.printStackTrace();
        }finally {
            interrupt();
        }
    }
}













package com.javarush.test.level25.lesson07.home01;

/* Не валять дурака
Восстановите логику класса TaskManipulator.
*/
public class Solution
{
    /*
     Output:
     first
     first
     second
     second
     second
     third
     fifth
     */
    public static void main(String[] args) throws InterruptedException {
        CustomThreadManipulator manipulator = new TaskManipulator();

        manipulator.start("first");
        Thread.sleep(150);
        manipulator.stop();

        manipulator.start("second");
        Thread.sleep(250);
        manipulator.stop();

        manipulator.start("third");
        Thread.sleep(50);
        manipulator.stop();

        manipulator.start("forth");
        manipulator.stop();

        manipulator.start("fifth");
        Thread.sleep(1);
        manipulator.stop();
    }
}






package com.javarush.test.level25.lesson07.home01;

public interface CustomThreadManipulator extends Runnable {
    public void start(String threadName) throws InterruptedException;
    public void stop();
}


package com.javarush.test.level25.lesson07.home01;

public class TaskManipulator implements Runnable, CustomThreadManipulator {

    private Thread thread;

    @Override
    public void run() {

        while(!thread.isInterrupted())
        {
            try
            {
                Thread.sleep(0);
                System.out.println(thread.getName());
                Thread.sleep(90);
            }catch (Exception ignored) {
                break;
            }
        }
    }
    @Override
    public void start(String threadName)
    {
        thread = new Thread(this, threadName);
        thread.start();
    }
    @Override
    public void stop()
    {
        thread.interrupt();
    }
}









public static void main(String[] args) throws IOException, InterruptedException {

        final String url[] = {"www.ya.ru", "www.rbc.ru", "www.ixbt.com", "www.lenta.ru"}; // Откуда качаем
        // Создаем пул задач (может в параллели выполнять 2 задачи)
        ThreadPoolExecutor pool = new Solution(2, 2, 2L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
        List<Future<String>> lf = new ArrayList<>(); // Список отложенных задач на выполнение (обертка для демонстрации отмены)

        for (int i = 0; i < url.length; i++) {
            final Socket socketF = new Socket(url[i], 80); // Создаем сокет для общения по http
            final String mainSitePage =  url[i];
            lf.add(pool.submit(
                    new SocketTask<String>() { // Собственно отложенная задача для закачки
                        @Override
                        public String call() throws Exception {
                            setSocket(socketF);
                            String res = "";
                            try(DataOutputStream os1  = new DataOutputStream(socketF.getOutputStream());
                                DataInputStream is1  = new DataInputStream(socketF.getInputStream()))
                            {
                                System.out.println("start loading from " + mainSitePage);
                                os1.writeBytes("GET http://"   + mainSitePage + "/ HTTP/1.1\r\n"); // Http-запрос
                                os1.writeBytes("Host: http://" + mainSitePage + ":80\r\n\r\n");
                                os1.flush(); // Пошлем его на сервер
                                String responseLine;
                                while ((responseLine = is1.readLine()) != null) // Сформируем ответ от сервера
                                    res += responseLine;
                            }
                            System.out.print("got info from " + mainSitePage + ",: "); // Информируем, что задача завершилась
                            System.out.println(res);
                            return res;
                        }
                    }));
        }
        lf.get(3).cancel(true); // Отменим предпоследнюю задачу (можно поставить точку останова в SocketTask для отладки)
        pool.shutdown();        // По завершению всех задач освободим пул
    }

	
	
	
	package com.javarush.test.level25.lesson07.home02;

import java.util.concurrent.*;

/* Все не так легко, как кажется
1. Почитать в инете про Socket, ThreadPoolExecutor, RunnableFuture, Callable
2. Реализуйте логику метода cancel в классе SocketTask
3. Реализуйте логику метода cancel для локального класса внутри метода newTask в классе SocketTask
*/
public class Solution extends ThreadPoolExecutor {


    public Solution(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        if (callable instanceof CancellableTask) {
            return ((CancellableTask<T>) callable).newTask();
        } else {
            return super.newTaskFor(callable);
        }
    }
}




package com.javarush.test.level25.lesson07.home02;

import java.io.IOException;
import java.net.Socket;
import java.util.concurrent.FutureTask;
import java.util.concurrent.RunnableFuture;

public abstract class SocketTask<T> implements CancellableTask<T> {
    private Socket socket;

    protected synchronized void setSocket(Socket socket) {
        this.socket = socket;
    }

    public synchronized void cancel() {
        try{
            if (socket != null){
                socket.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }

    public RunnableFuture<T> newTask() {
        return new FutureTask<T>(this) {
            public boolean cancel(boolean mayInterruptIfRunning) {
                try{
                    SocketTask.this.cancel();
                }catch (Exception e){

                }finally {
                    super.cancel(mayInterruptIfRunning);
                }
                return true;
            }
        };
    }
}



package com.javarush.test.level25.lesson07.home02;

import java.util.concurrent.Callable;
import java.util.concurrent.RunnableFuture;

public interface CancellableTask<T> extends Callable<T> {
    void cancel();

    RunnableFuture<T> newTask();
}










package com.javarush.test.level25.lesson09.task01;

/* Поживем - увидим
Все исключения, которые возникают в процессе работы нити Solution, должны быть обработаны одним из вариантов:
1. Если это Error, то вывести в консоль "Нельзя дальше работать"
2. Если это Exception, то вывести в консоль "Надо обработать"
3. Если это Throwable, то вывести в консоль "ХЗ"
Реализуйте эту логику.
*/
public class Solution extends Thread {


    public Solution() {

        this.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                if(e instanceof Error){
                    System.out.println("Нельзя дальше работать");
                }else if(e instanceof Exception){
                    System.out.println("Надо обработать");
                }else if(e instanceof Throwable){
                    System.out.println("ХЗ");
                }
            }
        });
    }
}









package com.javarush.test.level25.lesson09.task02;

import java.util.TimerTask;

/* Вооружаемся до зубов!
Создайте свой UncaughtExceptionHandler в виде локального класса внутри конструктора.
UncaughtExceptionHandler должен маскать звездочками имя трэда.
"Thread-0" должно быть заменено на "********"
"Thread-4321" должно быть заменено на "***********"
*/
public class Solution extends TimerTask {
    protected TimerTask original;
    protected final Thread.UncaughtExceptionHandler handler;

    public static void main(String[] args)
    {
        Thread th = new Thread(new Solution(new TimerTask()
        {
            @Override
            public void run()
            {
                throw new Error();
            }
        }));
        th.start();
    }

    public Solution(TimerTask original) {
        if (original == null) {
            throw new NullPointerException();
        }
        this.original = original;
        this.handler = new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                String[] arr = new String[t.getName().length()];

                String fin = "";

                for(String s: arr){
                    s = "*";
                    fin += s;
                }

                System.out.println(e.getMessage().replace(t.getName(), fin));
            }
        };    //init handler here
    }

    public void run() {
        try {
            original.run();
        } catch (Throwable cause) {
            Thread currentThread = Thread.currentThread();
            handler.uncaughtException(currentThread, new Exception("Blah " + currentThread.getName() + " blah-blah-blah", cause));
        }
    }

    public long scheduledExecutionTime() {
        return original.scheduledExecutionTime();
    }

    public boolean cancel() {
        return original.cancel();
    }
}











package com.javarush.test.level25.lesson09.task03;

/* Живем своим умом
В классе Solution реализуйте интерфейс UncaughtExceptionHandler, который должен:
1. прервать нить, которая бросила исключение.
2. вывести в консоль стек исключений начиная с самого вложенного.
Пример исключения: new Exception("ABC", new RuntimeException("DEF", new IllegalAccessException("GHI")))
Пример вывода:
java.lang.IllegalAccessException: GHI
java.lang.RuntimeException: DEF
java.lang.Exception: ABC
*/
public class Solution extends Thread implements Thread.UncaughtExceptionHandler {


    @Override
    public void uncaughtException(Thread t, Throwable e) {

        if(t != null) {
            t.interrupt();
        }

        Throwable eCause = e.getCause();
        if (eCause != null) {
            uncaughtException(t, eCause);
        }
        System.out.println(e.getClass().getName() + ": " + e.getMessage());

    }
}











package com.javarush.test.level25.lesson11.task01;

import java.util.Random;

/* Обеспечение отсутствия прерывания важной операции
Просмотрите метод moveMoney
Если RANDOM.nextInt(5000) больше порогового значения THRESHOLD_VALUE,
то обеспечьте переуступку кванта времени (переход хода для текущей нити)
Добавьте этот код в единственное допустимое место.
*/
public class Solution {
    private static final double THRESHOLD_VALUE = 500;
    private static final Random RANDOM = new Random();

    public synchronized void moveMoney(Account from, Account to, int amount) {
        from.setBalance(from.getBalance() - amount);
        if(RANDOM.nextInt(5000) > THRESHOLD_VALUE){
            Thread.yield();
        }
        to.setBalance(to.getBalance() + amount);
    }

    private class Account {
        private int balance;

        public int getBalance() {
            return balance;
        }

        public void setBalance(int balance) {
            this.balance = balance;
        }
    }
}











package com.javarush.test.level25.lesson11.task02;

/* Первый закон Финэйгла: если эксперимент удался, что-то здесь не так...
Обеспечьте переуступку кванта времени (переход хода для текущей нити) для последовательных выводов текста в консоль
*/
public class Solution {
    public static void main(String[] args) {
        Thread t1 = new Thread(new YieldRunnable(4));
        Thread t2 = new Thread(new YieldRunnable(3));
        Thread t3 = new Thread(new YieldRunnable(2));
        Thread t4 = new Thread(new YieldRunnable(1));

        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
    public static class YieldRunnable implements Runnable {
        private int index;

        public YieldRunnable(int index) {
            this.index = index;
        }

        public void run() {
            System.out.println("begin-" + index);
            Thread.yield();
            System.out.println("end-" + index);
        }
    }
}












package com.javarush.test.level26.lesson02.task01;

import java.util.Arrays;
import java.util.Comparator;

/* Почитать в инете про медиану выборки
Реализовать логику метода sort, который должен сортировать данные в массиве по удаленности от его медианы
Вернуть отсортированный массив от минимального расстояния до максимального
Если удаленность одинаковая у нескольких чисел, то выводить их в порядке возрастания
*/
public class Solution{

    public static void main(String[] args) {

        Integer[] arr = {-3, 5, -5, -9, 11};

        sort(arr);

        for(Integer i : arr) {
            System.out.print(i + " ");
        }
    }

    public static Integer[] sort(Integer[] array) {

        Arrays.sort(array);
        
        final double median;
        if (array.length % 2 == 0)
            median = ((double)array[array.length/2-1]+(double)array[array.length/2])/2;
        else
            median = array[array.length/2];
        
        
        Comparator<Integer> compareByMedian = new Comparator<Integer>()
        {
            @Override
            public int compare(Integer o1, Integer o2)
            {
                double value = Math.abs(o1-median) - Math.abs(o2-median);
                if (value == 0)
                    value = o1 - o2;
                return (int)value;
            }
        };
        Arrays.sort(array, compareByMedian);
        System.out.println(median);
        return array;
    }
}













package com.javarush.test.level26.lesson02.task02;

import java.util.*;

/* Был бы ум - будет и успех.
Солдаты всегда строились, строятся и будут строиться по убыванию роста.
Отсортируйте солдат, предварительно подумав, что лучше использовать при таких условиях - Comparable или Comparator.
*/
public class Solution {
    public static void main(String[] args) {
        Set<Soldier> soldiers = new TreeSet<Soldier>();
        soldiers.add(new Soldier("Ivanov", 170));
        soldiers.add(new Soldier("Petrov", 180));
        soldiers.add(new Soldier("Kuklov", 147));
        soldiers.add(new Soldier("Karaev", 150));
        soldiers.add(new Soldier("Sidorov", 175));

        for (Soldier soldier : soldiers) {
            System.out.println(soldier.name);
        }

    }

    public static class Soldier implements Comparable<Soldier> {
        private String name;
        private int height;

        public Soldier(String name, int height) {
            this.name = name;
            this.height = height;
        }

        @Override
        public int compareTo(Soldier o) {
            return o.height - height;
        }
    }
}








package com.javarush.test.level26.lesson02.task03;

import java.util.Comparator;

/* Убежденному убеждать других не трудно.
В таблице есть колонки, по которым можно сортировать.
Пользователь имеет возможность настроить под себя список колонок, которые будут сортироваться.
Напишите public static компаратор CustomizedComparator, который будет:
1. в конструкторе принимать список компараторов
2. сортировать данные в порядке, соответствующем последовательности компараторов.
Все переданные компараторы сортируют дженерик тип Т
В конструктор передается как минимум один компаратор
*/
public class Solution {

    public static class CustomizedComparator<T> implements Comparator<T> {
        Comparator<T>[] comparatorList;

        public CustomizedComparator(Comparator<T>... comparators) {
            this.comparatorList = comparators;
        }

        @Override
        public int compare(T o1, T o2) {
            int arrLength = 0;

            int result = 0;

            while (result == 0) {
                result = comparatorList[arrLength].compare(o1, o2);
                arrLength++;
                if (arrLength == comparatorList.length)
                    break;
            }
            return result;
        }
    }

}










package com.javarush.test.level26.lesson05.task01;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;

/* Для того, чтобы усовершенствовать ум, надо больше размышлять, чем заучивать.
Расставьте volatile там, где необходимо
*/
public class Solution extends Thread {
    public static final String DEFAULT_JAVARUSH_THREAD_NAME = "JavaRushThread";

    private static final AtomicInteger createdThreadIndex = new AtomicInteger();
    private static final AtomicInteger aliveThreadIndex = new AtomicInteger();
    private static final Logger log = Logger.getAnonymousLogger();

    private static volatile boolean debugLifecycle = false;

    public Solution(Runnable runnable) {
        this(runnable, DEFAULT_JAVARUSH_THREAD_NAME);
    }

    public Solution(Runnable runnable, String name) {
        super(runnable, name + "-" + createdThreadIndex.incrementAndGet());

        setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
            public void uncaughtException(Thread t, Throwable e) {
                log.log(Level.SEVERE, "An error occurred in thread " + t.getName(), e);
            }
        });
    }

    public void run() {
        boolean debug = debugLifecycle;
        if (debug) {
            log.log(Level.FINE, "Created " + getName());
        }
        try {
            aliveThreadIndex.incrementAndGet();
            super.run();
        }
        finally {
            aliveThreadIndex.decrementAndGet();
            if (debug) {
                log.log(Level.FINE, "Exiting " + getName());
            }
        }
    }

    public static void main(String[] args) {
        new Solution(new Runnable() {
            @Override
            public void run() {
                System.out.println("test JavaRush Runnable for Solution class");
            }
        }).start();


        new Solution(new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException("Oops");
            }
        }).start();
    }

}














package com.javarush.test.level26.lesson05.task02;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/* Трудолюбие - душа всякого дела и залог благосостояния.
Расставьте volatile там, где необходимо
*/
public class Solution {
    private static ScheduledExecutorService interruptScheduledExecutor;
    private static Thread taskThread;
    private static RethrowableTask task;

    public static void main(String[] args) throws Exception {
        runTaskBySchedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("A");
                throw new RuntimeException("it's test");
            }
        }, 1_000, TimeUnit.MILLISECONDS
        );

        interruptScheduledExecutor.shutdown();
    }

    public static void runTaskBySchedule(final Runnable runnable, long timeout, TimeUnit unit) throws Exception {
        task = new RethrowableTask(runnable);
        taskThread = new Thread(task);
        taskThread.start();

        interruptScheduledExecutor = Executors.newScheduledThreadPool(1);
        interruptScheduledExecutor.schedule(new Runnable() {
            public void run() {
                taskThread.interrupt();
            }
        }, timeout, unit);
        taskThread.join(unit.toMillis(timeout));
        try {
            task.rethrow();
        } catch (Throwable throwable) {
            System.out.println(throwable.getMessage());
        }
    }

    public static class RethrowableTask implements Runnable {
        private volatile Throwable throwable;
        private Runnable runnable;

        public RethrowableTask(Runnable runnable) {
            this.runnable = runnable;
        }

        public void run() {
            try {
                runnable.run();
            } catch (Throwable throwable) {
                this.throwable = throwable;
            }
        }

        public void rethrow() throws Exception {
            if (throwable != null) {
                System.out.println("B");
                throw new Exception(throwable);
            }
        }
    }
}

ПЕРЕВОД:

<code>package com.javarush.test.level26.lesson05.task02;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/* Трудолюбие - душа всякого дела и залог благосостояния.
Расставьте volatile там, где необходимо
*/
public class Solution {
    private static ScheduledExecutorService interruptScheduledExecutor;
    private static Thread taskThread;
    private static RethrowableTask task;

    public static void main(String[] args) throws Exception {
        //  Запуск задании Шедулером(графиком)+ переопределяем метод run для какой-то нити,
        // НО она не стартуется
        //  Скорее всего run - это инициаилизатор
        runTaskBySchedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("A");
                throw new RuntimeException("it's test");
            }
        }, 1_000, TimeUnit.MILLISECONDS
        );

        interruptScheduledExecutor.shutdown();
    }

    public static void runTaskBySchedule(final Runnable runnable, long timeout, TimeUnit unit) throws Exception {
        // Этот RethrowableTask task как бы запускает наш инициализаотр runnable в своем run методе 
        //и стартует свою нить
        task = new RethrowableTask(runnable);
        taskThread = new Thread(task);
        // Нить стартовала
        taskThread.start();

        // Используются утилиты конкурент
        // ScheduledExecutorService - запуск задания через определенные интервалы времени
        interruptScheduledExecutor = Executors.newScheduledThreadPool(1);
        // Вот у нас задание, которое останавливает наш таск , скорее всего для запутывания
        // т.к наш таск НЕ while(!iSInterupted)
        interruptScheduledExecutor.schedule(new Runnable() {
            public void run() {
                taskThread.interrupt();
            }
        }, timeout, unit);
        // Текущая main нить присоединяется к нашему таску
        taskThread.join(unit.toMillis(timeout));
        // Итого 1-нить main 2- нить таск 3-нить в Шедулере
        // итого все три нити выкинут есепшн
        // 1ая main-  через task.rethrow()- Exception
        // 2ая task - RuntimeException в блоке run при инициализации
        // 3я - InteruptedException
        // Ответ готов, кто то первый из них займет перменную
        try {
            task.rethrow();
        } catch (Throwable throwable) {
            System.out.println(throwable.getMessage());
        }
    }

    public static class RethrowableTask implements Runnable {
        private Throwable throwable;
        private Runnable runnable;

        public RethrowableTask(Runnable runnable) {
            this.runnable = runnable;
        }

        public void run() {
            try {
                // запуск нити инициализатора параметров таска шедулера
                runnable.run();
            } catch (Throwable throwable) {
                this.throwable = throwable;
            }
        }

        public void rethrow() throws Exception {
            if (throwable != null) {
                System.out.println("B");
                throw new Exception(throwable);
            }
        }
    }
}
</code>













package com.javarush.test.level26.lesson05.task03;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/* Тот, кто любит труд, не нуждается в развлечениях.
Расставьте volatile там, где необходимо
*/
public class Solution {
    private final URL javarushUrl;
    private final URL javarushUrl1Child;
    private final URL javarushVkGroupUrl;
    private final URL javarushVkGroupUrl1Child;
    private final URL javarushVkGroupUrl2Child;
    private final URL javarushVkGroupUrl3Child;

    private volatile ExecutorService executorService;
    private final Set<URL> urlsForProcessing = new HashSet();

    public static void main(String[] args) throws MalformedURLException, InterruptedException {
        Solution solution = new Solution();
        solution.start();
        Thread.sleep(1000);
        solution.stop();
    }

    public Solution() throws MalformedURLException {
        javarushUrl = new URL("http://javarush.ru/");
        javarushVkGroupUrl = new URL("http://vk.com/javarush");
        javarushUrl1Child = new URL("http://info.javarush.ru/page/FAQ/");
        javarushVkGroupUrl1Child = new URL("https://plus.google.com/114772402300089087607/about");
        javarushVkGroupUrl2Child = new URL("https://www.facebook.com/pages/Javarush/524321077686033");
        javarushVkGroupUrl3Child = new URL("https://twitter.com/javarush_ru");

        urlsForProcessing.add(javarushUrl);
        urlsForProcessing.add(javarushVkGroupUrl);
    }

    public synchronized void start() {
        executorService = Executors.newCachedThreadPool();
        for (URL url : urlsForProcessing) {
            submitUrlTask(url);
        }
        urlsForProcessing.clear();
    }

    public synchronized void stop() throws InterruptedException {
        try {
            saveUnprocessedUrls(executorService.shutdownNow());
            if (executorService.awaitTermination(1_000, TimeUnit.MILLISECONDS)) {
                saveUnprocessedUrls(getCancelledTasksFromExecutor());
            }
        } finally {
            executorService = null;
        }
    }

    private List<Runnable> getCancelledTasksFromExecutor() {
        return Collections.EMPTY_LIST;
    }

    protected List<URL> processPage(URL url) {
        System.out.println(url + " will be processed");
        return getChildUrlByParent(url);
    }

    private List<URL> getChildUrlByParent(URL url) {
        List<URL> result = new ArrayList<>();

        if (javarushUrl.equals(url)) {
            result.add(javarushUrl1Child);
        } else if (javarushVkGroupUrl.equals(url)) {
            result.add(javarushVkGroupUrl1Child);
            result.add(javarushVkGroupUrl2Child);
            result.add(javarushVkGroupUrl3Child);
        }
        return result;
    }

    private void saveUnprocessedUrls(List<Runnable> unprocessed) {
        for (Runnable task : unprocessed) {
            urlsForProcessing.add(((UrlTask) task).getPage());
        }
    }

    private void submitUrlTask(URL url) {
        executorService.execute(new UrlTask(url));
    }

    public class UrlTask implements Runnable {
        private final URL url;

        private UrlTask(URL url) {
            this.url = url;
        }

        public void run() {

            for (URL link : processPage(url)) {
                if (Thread.currentThread().isInterrupted())
                    return;
                submitUrlTask(link);
            }
        }

        public URL getPage() {
            return url;
        }
    }
}


С ПРОВЕРОЧКОЙ

package com.javarush.test.level26.lesson08.task01;

import java.util.concurrent.atomic.AtomicReference;

/* Вежливость - это искусственно созданное хорошее настроение.
В классе Solution создайте public static класс IntegerHolder.
IntegerHolder должен быть для типа int, быть нитебезопасным и изменяемым.
В этом классе должны быть два public метода get и set
*/
public class Solution {

    static IntegerHolder instance = new IntegerHolder();
    static {
        instance.set(0);
    }
    public static void main(String[] args) throws InterruptedException
    {
        Thread t1 = new TestThread();
        Thread t2 = new TestThread();
        t1.start();
        t2.start();
        while (!(t1.getState() == Thread.State.TERMINATED && t2.getState() == Thread.State.TERMINATED));
        System.out.println(instance.get());
    }
    public static class TestThread extends Thread
    {
        @Override
        public void run()
        {
            for (int i = 0; i < 1000000; i++)
            {
                synchronized (instance) {
                    instance.set(instance.get() + 1);
                }
            }
        }
    }
    public static class IntegerHolder
    {
        private final AtomicReference<Integer> hi = new AtomicReference<>();

        public int get() {
            synchronized (this) {
                return hi.get();
            }
        }
        public synchronized void set(int i) {
            synchronized (this) {
                hi.set(i);
            }
        }
    }
}









package com.javarush.test.level26.lesson08.task02;

/* Мудрый человек думает раз, прежде чем два раза сказать.
Все методы класса Solution должны быть потоково-безопасными.
Сделайте так, чтобы оба метода могли выполняться одновременно двумя различными трэдами.
synchronized(this) для этого не подходит, используйте другой объект для лока.
*/
public class Solution {
    int var1;
    int var2;
    int var3;
    int var4;

    private final Object lock = new Object();
    private final Object lock1 = new Object();

    public Solution(int var1, int var2, int var3, int var4) {
        this.var1 = var1;
        this.var2 = var2;
        this.var3 = var3;
        this.var4 = var4;
    }

    public int getSumOfVar1AndVar2() {
        synchronized (lock) {
            return var1 + var2;
        }
    }

    public int getSumOfVar3AndVar4() {
        synchronized (lock1) {
            return var3 + var4;
        }
    }
}











package com.javarush.test.level26.lesson08.task03;

/* Распределение элементов по корзинам с собственным локом.
В синхронизированных блоках используйте нужный лок.
*/
public class Solution {
    private static final int NUMBER_LOCKS = 12;
    private final Node[] buckets;
    private final Object[] locks;

    private static class Node {
        public Node next;
        public Object key;
        public Object value;
    }

    public Solution(int numberBuckets) {
        buckets = new Node[numberBuckets];
        locks = new Object[NUMBER_LOCKS];
        for (int i = 0; i < NUMBER_LOCKS; i++) {
            locks[i] = new Object();
        }
    }

    private final int hash(Object key) {
        return Math.abs(key.hashCode() % buckets.length);
    }

    public Object get(Object key) {
        int hash = hash(key);
        synchronized (locks[hash%NUMBER_LOCKS]) {
            for (Node m = buckets[hash]; m != null; m = m.next) {
                if (m.key.equals(key)) return m.value;
            }
        }
        return null;
    }

    public void clear() {
        for (int i = 0; i < buckets.length; i++) {
            synchronized (locks[i%NUMBER_LOCKS]) {
                buckets[i] = null;
            }
        }
    }
}










package com.javarush.test.level26.lesson08.task03;

/* Распределение элементов по корзинам с собственным локом.
В синхронизированных блоках используйте нужный лок.
*/
public class Solution {

    public static void main(String[] args) {

        Object o1 = new Object();
        Object o2 = new Object();
        Object o3 = new Object();
        Object o4 = new Object();
        Object o5 = new Object();
        Object o6 = new Object();

        Solution solution = new Solution(10);
        for (int i = 0; i < 10; i++) {
            solution.buckets[i] = new Node(o1, o2);
            solution.buckets[i].next = new Node(o3, o4);
            solution.buckets[i].next.next = new Node(o5, o6);
        }
        for (int i = 0; i < 10; i++) {
            System.out.println(solution.hash(solution.buckets[i].key));
            System.out.println(solution.hash(solution.buckets[i].next.key));
            System.out.println(solution.hash(solution.buckets[i].next.next.key));
            System.out.println(1111);
        }

        System.out.println(solution.get(solution.buckets[0].key));
    }


    private static final int NUMBER_LOCKS = 12;
    private final Node[] buckets;
    private final Object[] locks;

    private static class Node {
        public Node next;
        public Object key;
        public Object value;

        public Node(Object o1, Object o2) {
            this.key = o1;
            this.value = o2;
        }
    }

    public Solution(int numberBuckets) {
        buckets = new Node[numberBuckets];
        locks = new Object[NUMBER_LOCKS];
        for (int i = 0; i < NUMBER_LOCKS; i++) {
            locks[i] = new Object();
        }
    }


    /**
     * final int hash(Object k) {
     int h = hashSeed;
     if (0 != h && k instanceof String) {
     return sun.misc.Hashing.stringHash32((String) k);
     }

     h ^= k.hashCode();

     // This function ensures that hashCodes that differ only by
     // constant multiples at each bit position have a bounded
     // number of collisions (approximately 8 at default load factor).
     h ^= (h >>> 20) ^ (h >>> 12);
     return h ^ (h >>> 7) ^ (h >>> 4);
     }
     * @param key
     * @return
     */

    private final int hash(Object key) {
        return Math.abs(key.hashCode() % buckets.length);
    }
    
    
    

    /**
     * public V get(Object key) {
     if (key == null)
     return getForNullKey();
     Entry<K,V> entry = getEntry(key);

     return null == entry ? null : entry.getValue();
     }
     */

    public Object get(Object key) {
        int hash = hash(key);
        synchronized (locks[hash%NUMBER_LOCKS]) {
            for (Node m = buckets[hash]; m != null; m = m.next) {
                if (m.key.equals(key)) return m.value;
            }
        }
        return null;
    }

    

    public void clear() {
        for (int i = 0; i < buckets.length; i++) {
            synchronized (locks[i%NUMBER_LOCKS]) {
                buckets[i] = null;
            }
        }
    }
}











объекты thread-safe?
- Да, сделал бы все методы synchronized и все:
Пример
class synchronized Counter 
{
 private int c = 0;

 public synchronized void increment() 
 {
  c++;
 }

 public synchronized void decrement() 
 {
  c--;
 }

 public synchronized int value() 
 {
  return c;
 }
}
- Отличная работа. А вот, как бы он выглядел с использованием атомарных типов:
Пример
class AtomicCounter
{
 private AtomicInteger c = new AtomicInteger(0);

 public void increment() 
 {
  c.incrementAndGet();
 }

 public void decrement() 
 {
  c.decrementAndGet();
 }

 public int value() 
 {
  return c.get();
 }
}


И твой и мой классы работают одинаково, но класс с AtomicInteger работает быстрее.












package com.javarush.test.level26.lesson10.task01;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/* Весь мир играет комедию.
Почитать про java.util.concurrent.locks.Lock на http://docs.oracle.com/  (там все есть в джавадоках!)
Написать реализацию метода someMethod:
1. попытаться захватить лок
1.1. если лок занят, то вызвать метод ifLockIsBusy
1.2. если лок свободен, то:
1.2.1 вызвать метод ifLockIsFree
1.2.2 отпустить лок при любых условиях, даже если ifLockIsFree будет кидать исключение
*/
public class Solution {
    protected Lock lock = new ReentrantLock();

    public void someMethod() {
        if (lock.tryLock())
        {
            // Got the lock
            try
            {
                ifLockIsFree();
            }
            finally
            {
                // Make sure to unlock so that we don't cause a deadlock
                lock.unlock();
            }
        }
        else
        {
            ifLockIsBusy();
        }
        //implement logic here, use the lock field
    }

    public void ifLockIsFree() {
    }

    public void ifLockIsBusy() {
    }
}














package com.javarush.test.level26.lesson10.home01;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/* Мир скучен для скучных людей.
Разберитесь с BlockingQueue
По образу и подобию класса Producer создайте класс Consumer, который будет выводить данные из BlockingQueue в консоль
*/
public class Solution {

    public static void main(String[] args) throws Exception {

        BlockingQueue queue = new ArrayBlockingQueue(32);

        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.submit(producer);
        executorService.submit(consumer);

        Thread.sleep(2000);

        executorService.shutdownNow();

    }
}



package com.javarush.test.level26.lesson10.home01;

import java.util.concurrent.BlockingQueue;

/**
 * Created by Кира on 07.11.2016.
 */
public class Consumer implements Runnable {

        protected BlockingQueue queue;

        public Consumer(BlockingQueue queue) {
            this.queue = queue;
        }

    public void run() {
        try {
            while (true) {
                System.out.println(queue.take());
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println(String.format("[%s] thread was terminated", Thread.currentThread().getName()));
        }
    }
}


package com.javarush.test.level26.lesson10.home01;

import java.util.concurrent.BlockingQueue;

public class Producer implements Runnable {
    protected BlockingQueue queue;

    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            int i = 0;
            while (true) {
                queue.put(String.valueOf(i++));
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println(String.format("[%s] thread was terminated", Thread.currentThread().getName()));
        }
    }
}









package com.javarush.test.level26.lesson10.home02;

import com.javarush.test.level26.lesson10.home02.Producer;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/* Мир не меняется, меняемся мы.
Разберитесь с ConcurrentHashMap
В отдельном файле создайте класс Producer, который будет:
1. каждые полсекунды выводить на консоль с новой строки начиная с 1 фразу [Some text for i] , пример "Some text for 1"
2. при возникновении исключения выводить в консоль [[TREAD_NAME] thread was terminated], пример "[thread-1] thread was terminated"
*/
public class Solution {
    public static void main(String[] args) throws Exception {
        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

        Producer producer = new Producer(map);
        Consumer consumer = new Consumer(map);

        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.submit(producer);
        executorService.submit(consumer);

        Thread.sleep(2000);

        executorService.shutdownNow();
        //finally 5 lines have to be printed
    }
}

package com.javarush.test.level26.lesson10.home02;

import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by Кира on 07.11.2016.
 */
public class Producer implements Runnable {

    protected ConcurrentHashMap<String, String> map;

    public Producer(ConcurrentHashMap<String, String> map) {
        this.map = map;
    }

    public void run() {

        try {
            int i = 1;
            while (true) {
                System.out.println("Some text for "+i++);
                Thread.sleep(500);
            }
        } catch (Exception e) {

            System.out.println(String.format("[%s] thread was terminated", Thread.currentThread().getName()));

        }
    }

}


package com.javarush.test.level26.lesson10.home02;

import java.util.concurrent.ConcurrentHashMap;

public class Consumer implements Runnable {

    protected ConcurrentHashMap<String, String> map;

    public Consumer(ConcurrentHashMap<String, String> map) {
        this.map = map;
    }

    public void run() {

        Thread currentThread = Thread.currentThread();

        while (!currentThread.isInterrupted()) {
            if (!map.isEmpty()) {
                for (String key : map.keySet()) {
                    System.out.println(map.remove(key));
                }
            }
        }
    }
}











package com.javarush.test.level27.lesson02.task01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/* Рефакторинг
Перепишите код без использования меток, сохранив при этом логику.
Не оставляйте закомментированный код.
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bis = new BufferedReader(new InputStreamReader(System.in));
        int a;
        int sum = 0;
        do {
            a = Integer.parseInt(bis.readLine());
            sum += a;
        } while (isContinueWhile(sum));
        System.out.println(sum);
    }

    private static boolean isContinueWhile(int sum) {
        for (int k = 0; k < 100; k += 20)
            if (sum < 100 && k <= 20) {
                System.out.println(k < 2 ? k : sum % k);
            } else {
                break;
            }

        return false;
    }
}










package com.javarush.test.level27.lesson02.task02;

/* Нужный оператор
Вставьте в код единственную строчку - оператор (не break), чтобы выводился треугольник из букв S
*/
public class Solution {
    public static void main(String args[]) {
        label:
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (j > i) {
                    System.out.println();
                    continue label;
                }
                System.out.print("S");
            }
        }
    }

}









package com.javarush.test.level27.lesson04.task01;

/* Создаем дедлок
Расставьте модификаторы так, чтобы при работе с этим кодом появился дедлок
Метод main порождает deadLock, поэтому не участвует в тестировании
*/
public class Solution {
    private final String field;

    public Solution(String field) {
        this.field = field;
    }

    public String getField() {
        return field;
    }

    public synchronized void sout(Solution solution) {
        System.out.format("111:  %s: %s %n", this.field, solution.getField());
        solution.sout2(this);
    }

    public synchronized void sout2(Solution solution) {
        System.out.format("222:  %s: %s %n", this.field, solution.getField());
        solution.sout(this);
    }




    public static void main(String[] args) {
        final Solution solution = new Solution("first");
        final Solution solution2 = new Solution("second");
        new Thread(new Runnable() {
            public void run() {
                solution.sout(solution2);
            }
        }).start();

        new Thread(new Runnable() {
            public void run() {
                solution2.sout(solution);
            }
        }).start();
    }
}











package com.javarush.test.level27.lesson04.task02;

/* Второй вариант дедлока
В методе secondMethod в синхронизированных блоках расставьте локи так,
чтобы при использовании класса Solution нитями образовывался дедлок
*/
public class Solution {
    private final Object lock = new Object();

    public synchronized void firstMethod() {
        synchronized (lock) {
            doSomething();
        }
    }

    public void secondMethod() {
        synchronized (lock) {
            synchronized (this) {
                doSomething();
            }
        }
    }

    private void doSomething() {
    }
}








package com.javarush.test.level27.lesson04.home01;

/* Модификаторы и дедлоки
Расставьте модификаторы так, чтобы при работе с этим кодом появился дедлок
*/
public class Solution {
    public synchronized Object getData() {
        return new ThreadDeadlock().getData();
    }
}

package com.javarush.test.level27.lesson04.home01;

public class ThreadDeadlock {
    Object data;
    public synchronized Object getData() {
        return data;
    }
}











package com.javarush.test.level27.lesson06.task01;

/* Убираем deadLock
Используя стратегию избегания deadLock-а сделайте так, чтобы он не возник.
Метод main не участвует в тестировании.
Действуйте аналогично примеру из лекций.
Изменения вносите только в safeMethod.
*/
public class Solution {
    public void safeMethod(Object obj1, Object obj2) {
        Object max = obj1.hashCode() > obj2.hashCode() ? obj1 : obj2;
        Object min = obj1.hashCode() > obj2.hashCode() ? obj2 : obj1;
        synchronized (max) {
            longTimeMethod();
            synchronized (min) {
                unsafeMethod(obj1, obj2);
            }
        }
    }

    public void longTimeMethod() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException ignored) {
        }
    }

    protected void unsafeMethod(Object obj1, Object obj2) {
        System.out.println(obj1 + " " + obj2);
    }





    public static void main(String[] args) {
        final Object o1 = new Object();
        final Object o2 = new Object();
        final Solution solution = new Solution();

        new Thread(){
            @Override
            public void run() {
                solution.safeMethod(o1, o2);
            }
        }.start();

        new Thread(){
            @Override
            public void run() {
                solution.safeMethod(o2, o1);
            }
        }.start();
    }
}









package com.javarush.test.level27.lesson06.home01;

import java.util.Set;

/* Убираем deadLock используя Открытые вызовы
Синхронизированные методы, которые вызывают внутри себя синхронизированные методы других классов, приводят к dead-lock-у.
1. Перенесите синхронизацию с метода в синхронизированный блок, куда поместите лишь необходимые части кода.
2. Уберите избыточную синхронизацию методов.
3. В стеке вызова методов не должно быть перекрестной синхронизации,
т.е. такого synchronizedMethodAClass().synchronizedMethodBClass().synchronizedMethodAClass()

Этот способ избавления от дэдлока называется Открытые вызовы, о нем читайте в дополнительном материале к лекции.
Метод main не участвует в тестировании.
*/
public class Solution {
    public static void main(String[] args) {
        final long deadLineTime = System.currentTimeMillis() + 5000; //waiting for 5 sec

        final RealEstate realEstate = new RealEstate();

        Set<Apartment> allApartments = realEstate.getAllApartments();

        final Apartment[] apartments = allApartments.toArray(new Apartment[allApartments.size()]);

        for (int i = 0; i < 20; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        realEstate.revalidate();
                    }
                }
            }, "RealEstateThread" + i).start();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < apartments.length; i++) {
                        apartments[i].revalidate(true);
                    }
                }
            }, "ApartmentThread" + i).start();
        }

        Thread deamonThread = new Thread(new Runnable() {

            @Override
            public void run() {
                while (System.currentTimeMillis() < deadLineTime)
                    try {
                        Thread.sleep(2);
                    } catch (InterruptedException ignored) {
                    }
                System.out.println("The dead lock occurred");
            }
        });
        deamonThread.setDaemon(true);
        deamonThread.start();
    }
}




package com.javarush.test.level27.lesson06.home01;

public class Apartment {
    private String location;
    private final RealEstate realEstate;

    public Apartment(RealEstate realEstate) {
        this.realEstate = realEstate;
        setLocation(String.valueOf(Math.random() * 10));
    }

    public synchronized String getLocation() {
        return location;
    }

    /////////////////////////////////////////////////////
    public synchronized void setLocation(String location) {

        this.location = location;
    }
    //////////////////////////////////////////////////////

    public void revalidate(boolean isEmpty) {
        boolean temp = false;
        if(isEmpty){
            temp = isEmpty;
        }
        synchronized (this) {
            if (temp)
                realEstate.up(this);

        }
    }
}



package com.javarush.test.level27.lesson06.home01;

import java.util.HashSet;
import java.util.Set;

public class RealEstate {

    private final Set<Apartment> allApartments;
    private final Set<Apartment> activeApartments;

    public RealEstate() {
        allApartments = new HashSet();
        activeApartments = new HashSet();

        //add some data
        allApartments.add(new Apartment(this));
        allApartments.add(new Apartment(this));
        allApartments.add(new Apartment(this));
        allApartments.add(new Apartment(this));
        allApartments.add(new Apartment(this));
        allApartments.add(new Apartment(this));
    }

    public Set<Apartment> getAllApartments() {
        return allApartments;
    }

    public synchronized void up(Apartment apartment) {
        activeApartments.add(apartment);
    }

    public void revalidate() {
        activeApartments.clear();
        Set<Apartment> tempSet;
        tempSet = new HashSet<Apartment>(allApartments);
        for (Apartment apartment : tempSet) {
            boolean randomValue = Math.random() * 2 % 2 == 0;
            synchronized (apartment){
                apartment.revalidate(randomValue);
            }
        }
    }
}















?????????

ublic void someMethodWithSynchronizedBlocks(Object obj1, Object obj2) {
        //следующие 4 строки в тестах имеют другую реализацию
        int lock1 = obj1.hashCode();
        int lock2 = obj2.hashCode();
        Object firstLock = lock1 > lock2 ? obj1 : obj2;
        Object secondLock = lock1 > lock2 ? obj2 : obj1;

        synchronized (firstLock) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ignored) {
            }

            synchronized (secondLock) {
                System.out.println(obj1 + " " + obj2);
            }
        }
    }

    public static boolean isNormalLockOrder(final Solution solution, final Object o1, final Object o2) throws Exception {
        //do something here
        final long h1 = System.currentTimeMillis();
        final long[] h2 = {0};

        Thread t1 = new Thread(){
            @Override
            public void run() {
                solution.someMethodWithSynchronizedBlocks(o1, o2);
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2){
                    h2[0] = System.currentTimeMillis();
                    }
                }
            };

        t1.start();

        return (h1 - h2[0]) < 100;

    }


------------------------------------



	
	
	
		ДОРЕШАТЬ!!!!!!!!!!!!!!!!!!!!!!!!!!_________________________________
	
	
	
	
	package com.javarush.test.level27.lesson06.task02;

/* Определяем порядок захвата монитора. Сложная.
Реализуйте логику метода isNormalLockOrder, который должен определять:
соответствует ли порядок synchronized блоков в методе someMethodWithSynchronizedBlocks - порядку
передаваемых в него аргументов. Должно выполняться условие:
для разных объектов o1 и o2 isNormalLockOrder(o1, o2) != isNormalLockOrder(o2, o1), для одинаковых объектов одинаковый результат
Метод main не участвует в тестировании.
*/
public class Solution {
    public void someMethodWithSynchronizedBlocks(Object obj1, Object obj2) {
        //следующие 4 строки в тестах имеют другую реализацию
        int lock1 = obj1.hashCode();
        int lock2 = obj2.hashCode();
        Object firstLock = lock1 > lock2 ? obj1 : obj2;
        Object secondLock = lock1 > lock2 ? obj2 : obj1;

        synchronized (firstLock) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ignored) {
            }

            synchronized (secondLock) {
                System.out.println(obj1 + " " + obj2);
            }
        }
    }

    public static boolean isNormalLockOrder(final Solution solution, final Object o1, final Object o2) throws Exception {

        Thread thread1 = new Thread(){
            @Override
            public void run() {
                synchronized (o1) {
                    try{
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }
        };
        Thread thread2 = new Thread(){
            @Override
            public void run() {
                synchronized (o1) {
                    synchronized (o2) {
                        solution.someMethodWithSynchronizedBlocks(o1, o2);
                    }
                }
            }
        };
        thread1.start();
        thread2.start();

        if (thread2.getState().equals(Thread.State.BLOCKED)){
            thread1.interrupt();
            thread2.interrupt();
            return true;
        }
        return false;

    }

    public static void main(String[] args) throws Exception {
        final Solution solution = new Solution();
        final Object o1 = new Object();
        final Object o2 = new Object();

        String o1s = o1.toString().substring( o1.toString().lastIndexOf("@") ); //test
        String o2s = o2.toString().substring( o2.toString().lastIndexOf("@") ); //test
        System.out.println("o1 = " + o1s + "   o2 = " + o2s + "\n");            //test

        new Thread() {
            @Override
            public void run() {
                try {
                    String o1s = o1.toString().substring( o1.toString().lastIndexOf("@") ); //test
                    String o2s = o2.toString().substring( o2.toString().lastIndexOf("@") ); //test
                    System.out.println("main -> " + this.getName() + " -> isNLO(o1, o2) - " + "("+o1s+", "+o2s+") " +
                            "; o1.hashCode() > o2.hashCode() = " + (o1.hashCode() > o2.hashCode()) +
                            " ["+o1.hashCode()+" > "+o2.hashCode()+"] ; isNLO = " +
                            isNormalLockOrder(solution, o1, o2) //expected boolean b
                    ); //test
                } catch (Exception ignored) {
                }
            }
        }.start();

        Thread.sleep(1000);    //test
        System.out.println();  //test

        new Thread() {
            @Override
            public void run() {
                try {
                    String o1s = o1.toString().substring( o1.toString().lastIndexOf("@") ); //test
                    String o2s = o2.toString().substring( o2.toString().lastIndexOf("@") ); //test
                    System.out.println("main -> " + this.getName() + " -> isNLO(o2, o1) - " + "("+o2s+", "+o1s+") " +
                            "; o2.hashCode() > o1.hashCode() = " + (o2.hashCode() > o1.hashCode()) +
                            " ["+o2.hashCode()+" > "+o1.hashCode()+"] ; isNLO = " + //test
                            isNormalLockOrder(solution, o2, o1) //expected boolean !b
                    ); //test
                } catch (Exception ignored) {
                }
            }
        }.start();

        Thread.sleep(1000);    //test
        System.out.println();  //test

        /* **************************************
                  test (o1, o1) and (o2, o2)
           ************************************** */
        new Thread() {
            @Override
            public void run() {
                try {
                    String o1s = o1.toString().substring( o1.toString().lastIndexOf("@") ); //test
                    System.out.println("main -> " + this.getName() + " -> isNLO(o1, o1) - " + "("+o1s+", "+o1s+") " +
                            "; o1.hashCode() > o1.hashCode() = " + (o1.hashCode() > o1.hashCode()) +
                            " ["+o1.hashCode()+" > "+o1.hashCode()+"] ; isNLO = " + //test
                            isNormalLockOrder(solution, o1, o1)
                    ); //test
                } catch (Exception ignored) {
                }
            }
        }.start();

        Thread.sleep(1000);
        System.out.println();

        new Thread() {
            @Override
            public void run() {
                try {
                    String o2s = o2.toString().substring( o2.toString().lastIndexOf("@") ); //test
                    System.out.println("main -> " + this.getName() + " -> isNLO(o2, o2) - " + "("+o2s+", "+o2s+") " +
                            "; o2.hashCode() > o2.hashCode() = " + (o2.hashCode() > o2.hashCode()) +
                            " ["+o2.hashCode()+" > "+o2.hashCode()+"] ; isNLO = " + //test
                            isNormalLockOrder(solution, o2, o2)
                    ); //test
                } catch (Exception ignored) {
                }
            }
        }.start();
    }
}

	
	
	
	ДОРЕШАТЬ!!!!!!!!!!!!!!!!!!!!!!!!!!_________________________________
	
	
	
	
	
	
	
	
	
	
	
	
package com.javarush.test.level27.lesson09.task01;

import java.util.concurrent.CountDownLatch;

/* CountDownLatch
Дана стандартная реализация методологии wait-notify.
Почитайте про CountDownLatch и перепишите тело метода someMethod используя поле latch.
Весь лишний код удалите из класса.
*/
public abstract class Solution {

    private final CountDownLatch latch = new CountDownLatch(1);

    public void someMethod() throws InterruptedException {

        latch.await();
        retrieveValue();
        latch.countDown();

    }

    abstract void retrieveValue();
}
	
	
	
	
	
	
	
	



package com.javarush.test.level27.lesson09.home01;

public class TransferObject {
    private int value;
    protected volatile boolean isValuePresent = false; //use this variable



    public synchronized int get() {

        while (!isValuePresent) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                System.out.println("INTERRUPTED GET");
            }
        }

        System.out.println("Got: " + value);

        isValuePresent = false;

        notifyAll();

        return value;
    }

    public synchronized void put(int value) {

        while (isValuePresent) {
            try {
                wait();
            } catch (InterruptedException ex) {
                System.out.println("INTERRUPTED PUT");
            }
        }
        this.value = value;
        
        System.out.println("Put: " + value);
        
        isValuePresent = true;
        
        notifyAll();
    }
}



package com.javarush.test.level27.lesson09.home01;

public class ConsumerTask implements Runnable {
    private TransferObject transferObject;
    protected volatile boolean stopped;

    public ConsumerTask(TransferObject transferObject) {
        this.transferObject = transferObject;
        new Thread(this, "ConsumerTask").start();
    }

    public void run() {
        while (!stopped) {
            transferObject.get();
        }
    }

    public void stop() {
        stopped = true;
    }
}



package com.javarush.test.level27.lesson09.home01;

import java.util.concurrent.atomic.AtomicInteger;

public class ProducerTask implements Runnable {
    private TransferObject transferObject;
    protected volatile boolean stopped;
    static volatile AtomicInteger i = new AtomicInteger(0);

    public ProducerTask(TransferObject transferObject) {
        this.transferObject = transferObject;
        new Thread(this, "ProducerTask").start();
    }

    public void run() {
        while (!stopped) {
            transferObject.put(i.incrementAndGet());
        }
    }

    public void stop() {
        stopped = true;
    }
}


package com.javarush.test.level27.lesson09.home01;

public class TransferObject {
    private int value;
    protected volatile boolean isValuePresent = false; //use this variable



    public synchronized int get() {

        while (!isValuePresent) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                System.out.println("INTERRUPTED GET");
            }
        }

        System.out.println("Got: " + value);

        isValuePresent = false;

        notifyAll();

        return value;
    }

    public synchronized void put(int value) {

        while (isValuePresent) {
            try {
                wait();
            } catch (InterruptedException ex) {
                System.out.println("INTERRUPTED PUT");
            }
        }
        this.value = value;

        System.out.println("Put: " + value);

        isValuePresent = true;

        notifyAll();
    }
}










package com.javarush.test.level27.lesson09.home02;

/* Расставьте wait-notify.
Расставьте wait-notify.
Пример вывода:
Thread-0 MailServer has got: [Person [Thread-1] has written an email 'AAA'] in 1001 ms after start
*/
public class Solution {

    public static void main(String[] args) {
        Mail mail = new Mail();
        Thread server = new Thread(new MailServer(mail));
        Thread amigo = new Thread(new Person(mail));

        server.start();
        amigo.start();
    }
}

package com.javarush.test.level27.lesson09.home02;

public class Person implements Runnable {
    private final Mail mail;

    public Person(Mail mail) {
        this.mail = mail;
    }

    @Override
    public void run() {
        String name = Thread.currentThread().getName();
        try {
            Thread.sleep(1000);

            synchronized (mail) {

                mail.setText("Person [" + name + "] has written an email 'AAA'");

                mail.notifyAll();
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


package com.javarush.test.level27.lesson09.home02;

public class MailServer implements Runnable {
    private Mail mail;

    public MailServer(Mail mail) {
        this.mail = mail;
    }

    @Override
    public void run() {
        long beforeTime = System.currentTimeMillis();

        synchronized (mail) {
                try {
                    mail.wait();
                } catch (InterruptedException e) {

                }
        }

        String name = Thread.currentThread().getName();
        long afterTime = System.currentTimeMillis();


        System.out.format("%s MailServer has got: [%s] in %d ms after start", name, mail.getText(), (afterTime - beforeTime));
    }
}


package com.javarush.test.level27.lesson09.home02;

public class Mail {
    private String text;

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}









package com.javarush.test.level28.lesson02.task01;

/* Осваиваем switch
Реализуйте логику метода switchTest:
1. Не используйте условные операторы
2. Используйте 1 switch, у которого 2 case и 1 default
3. Ожидаемый вывод:
Вывод для E1.A - "it's E1.A"
Вывод для E1.B - "it's E1.B"
Вывод для E1.C - "it's E1.C"
Вывод для E1.Y - "it's E1.Y"
Вывод для E2.D - "it's E2.D"
Вывод для E2.E - "it's E2.E"
Вывод для E2.F - "it's E2.F"
Вывод для всех других значений - "undefined"
*/
public class Solution {
    public static enum E1 {
        A, B, C, Y
    }

    public static enum E2 {
        D, E, F
    }

    public static enum E3 {
        D, E, F
    }

    public static void main(String[] args) {
        Solution.switchTest(E1.C);
        Solution.switchTest(E3.D);
        Solution.switchTest(E2.D);
        /* output
        it's E1.C
        undefined
        it's E2.D
         */
    }

    public static void switchTest(Enum obj) {
        //add your code here
        switch (obj.getClass().getSimpleName()){
            case "E1":
                System.out.println("it's E1." + obj.name());
                break;
            case "E2":
                System.out.println("it's E2." + obj.name());
                break;
            default:
                System.out.println("undefined");
                break;
        }
    }
}











несколько методов класса ThreadGroup:

Метод	Описание
String	getName()	Возвращает имя группы
ThreadGroup getParent()	Возвращает группу-родителя
void interrupt()	Прерывает все нити в группе.
boolean isDaemon()	Проверяет, является ли группа демоном
void setDaemon(boolean daemon)	Устанавливает группе свойство daemon
int activeCount()	Возвращает количество живых нитей в группе и ее подгруппах
int activeGroupCount()	Возвращает количество живых групп в группе и ее подгруппах
int enumerate(Thread[] list)	Помещает в массив все живые нити и возвращает их количество.
int getMaxPriority()	Возвращает максимальный приоритет для нитей в группе.
void setMaxPriority(int priority)	Позволяет задать максимальный приоритет нитей в группе и подгруппах.








package com.javarush.test.level28.lesson04.task01;

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

/* Пишем свою ThreadFactory
В классе Solution создайте публичный статический класс AmigoThreadFactory, реализующий интерфейс ThreadFactory
1.Реализация интерфейсного метода - создайте и верните трэд, который должен:
1.1. не быть демоном
1.2. иметь нормальный приоритет
1.3. имя трэда должно иметь шаблон "GN-pool-A-thread-B", где
GN - это имя группы,
A - это номер фабрики инкрементируется в пределах класса начиная с 1, используйте AtomicInteger
B - номер треда инкрементируется в пределах конкретной фабрики начиная с 1, используйте AtomicInteger
2.Каждая фабрика должна иметь ту группу тредов (ThreadGroup), в которой она была создана
3. Методы main и emulateThreadFactory не участвуют в тестировании
Пример вывода:
secondGroup-pool-2-thread-1
firstGroup-pool-1-thread-1
firstGroup-pool-1-thread-3
secondGroup-pool-2-thread-3
firstGroup-pool-1-thread-2
secondGroup-pool-2-thread-2
*/
public class Solution {

    public static void main(String[] args) {
        class EmulateThreadFactoryTask implements Runnable {
            @Override
            public void run() {
                emulateThreadFactory();
            }
        }

        ThreadGroup group = new ThreadGroup("firstGroup");
        Thread thread = new Thread(group, new EmulateThreadFactoryTask());

        ThreadGroup group2 = new ThreadGroup("secondGroup");
        Thread thread2 = new Thread(group2, new EmulateThreadFactoryTask());

        thread.start();
        thread2.start();
    }

    private static void emulateThreadFactory() {
        AmigoThreadFactory factory = new AmigoThreadFactory();
        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        };
        factory.newThread(r).start();
        factory.newThread(r).start();
        factory.newThread(r).start();
    }

    public static class AmigoThreadFactory implements ThreadFactory{

        private AtomicInteger threadNumber = new AtomicInteger(0);
        private AtomicInteger factoryNum = new AtomicInteger(0);
        private static AtomicInteger factoryCount = new AtomicInteger(0);

        public AmigoThreadFactory() {
            factoryNum.set(factoryCount.incrementAndGet());
        }

        @Override
        public Thread newThread(Runnable r)
        {
            Thread newThread = new Thread(r);

            newThread.setName(newThread.getThreadGroup().getName() + "-pool-" + factoryNum + "-thread-" + threadNumber.incrementAndGet());

            return newThread;
        }
    }
}










package com.javarush.test.level28.lesson04.task02;

import java.util.concurrent.ThreadLocalRandom;

/* ThreadLocalRandom
Класс Solution будет использоваться трэдами.
Реализуйте логику всех методов, используйте класс ThreadLocalRandom.
getRandomIntegerBetweenNumbers должен возвращать случайный int между from и to
getRandomDouble должен возвращать случайный double
getRandomLongBetween0AndN должен возвращать случайный long между 0 и n
*/
public class Solution implements Runnable {

    public static int getRandomIntegerBetweenNumbers(int from, int to) {

        int newRandom = ThreadLocalRandom.current().nextInt(from, to);

        return newRandom;
    }

    public static double getRandomDouble() {

        double newRandom = ThreadLocalRandom.current().nextDouble(Math.random());

        return newRandom;
    }

    public static long getRandomLongBetween0AndN(long n) {

        long newRandom = ThreadLocalRandom.current().nextLong(n);

        return newRandom;
    }

    @Override
    public void run() {

    }
}














package com.javarush.test.level22.lesson09.task03;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

/* Составить цепочку слов
В методе main считайте с консоли имя файла, который содержит слова, разделенные пробелом.
В методе getLine используя StringBuilder расставить все слова в таком порядке,
чтобы последняя буква данного слова совпадала с первой буквой следующего не учитывая регистр.
Каждое слово должно участвовать 1 раз.
Метод getLine должен возвращать любой вариант.
Слова разделять пробелом.
В файле не обязательно будет много слов.

Пример тела входного файла:
Киев Нью-Йорк Амстердам Вена Мельбурн

Результат:
Амстердам Мельбурн Нью-Йорк Киев Вена
*/
public class Solution {
    public static void main(String[] args) throws FileNotFoundException {
        String file;
        Scanner scanner = new Scanner(System.in);

        file = scanner.nextLine();

        scanner.close();

        String s = "";

        Scanner sc = new Scanner(new File(file));

        while (sc.hasNext()){
            s += sc.next() + " ";
        }

        sc.close();

        String[] words = s.split(" ");

        //...
        StringBuilder result = getLine(words);
        System.out.println(result.toString());
    }

    public static StringBuilder getLine(String... words) {

        if (words == null || words.length == 0)
        {
            return new StringBuilder();
        }

        if (words.length == 1)
        {
            return new StringBuilder(words[0]);
        }

        StringBuilder result = new StringBuilder();

        ArrayList<String> list = new ArrayList<String>();

        for (int i = 0; i < words.length; i ++)
                list.add(words[i]);

        while (!isOK(list))
        {
            Collections.shuffle(list);
        }

        for (String s : list)
            result.append(s+ " ");
        result.deleteCharAt(result.length()-1);
        return result;

    }

    private static boolean isOK(ArrayList<String> list) {

        for (int i = 0; i < list.size()-1; i++)
        {
            String first = list.get(i);
            String second = list.get(i+1);
            first = first.toLowerCase();
            second =second.toLowerCase();
            if (first.charAt(first.length()-1)!=second.charAt(0))
                return false;
        }
        return true;
    }


}










package com.javarush.test.level28.lesson06.task01;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ThreadLocalRandom;

/* Magic class
В пакете java.util.concurrent найдите такую реализацию List, у которой
1. итератор не содержит какие-либо данные, вставленные в список после создания итератора
2. внутри данные хранятся в виде массива
3. итератор гарантированно не бросает ConcurrentModificationException
4. допускаются все элементы включая null
5. Исправьте строку List<String> list = null ... в методе main
*/
public class Solution {
    public static void main(String[] args) throws InterruptedException {
        Solution solution = new Solution();
        List<String> list = new CopyOnWriteArrayList<>();

        solution.startUpdatingThread(list);
        solution.copyOnWriteSolution(list);
        solution.stopUpdatingThread();

        /* The output example
size = 0
Element :s781859336
Element :s1453499757
Element :s911312405
Element :s-877520242
Element :s-1636258097
size = 5

Element2 :s781859336
Element2 :s1453499757
Element2 :s911312405
Element2 :s-877520242
Element2 :s-1636258097
Element2 :s-1739827856
Element2 :s-938954654
Element2 :s925086217
size = 8
         */
    }

    public void copyOnWriteSolution(List<String> list) throws InterruptedException {
        System.out.println("size = " + list.size());
        System.out.println();
        Thread.sleep(20);
        for (String element : list) {   //создает новую копию на момент создания итератора
            System.out.println("Element :" + element);
        }
        System.out.println("size = " + list.size());
        System.out.println();
        Thread.sleep(200);

        for (String element : list) {  //создает новую копию на момент создания итератора
            System.out.println("Element2 :" + element);
        }
        System.out.println("size = " + list.size());
        stopUpdatingThread();
    }

    public void stopUpdatingThread() throws InterruptedException {
        t.stop();
        t.join();
    }

    private Thread t;

    private void startUpdatingThread(final List<String> list) {
        t = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    list.add("s" + ThreadLocalRandom.current().nextInt());
                    try {
                        Thread.sleep(5);
                    } catch (InterruptedException e) {
                    }
                }
            }
        });
        t.start();
    }
}


















	
package com.javarush.test.level28.lesson06.home01;

/* Приоритеты в Threads
В отдельном файле создайте класс MyThread унаследовавшись от Thread. MyThread должен:
1. иметь возможность быть созданным используя любой конструктор супер-класса  (Alt+Insert)
2. приоритет у трэдов должен проставляться циклично от минимального значения до максимального значения.
3. если у трэда установлена трэд-группа(ThreadGroup), то приоритет трэда не может быть больше
максимального приоритета его трэд-группы
*/
public class Solution {

    public static void main(String[] args) {
        for (int i = 0; i < 12; i++) {
            System.out.print(new MyThread().getPriority() + " ");
        }
        //output
        //1 2 3 4 5 6 7 8 9 10 1 2

        System.out.println();
        ThreadGroup group = new ThreadGroup("someName");
        group.setMaxPriority(7);
        for (int i = 0; i < 12; i++) {
            System.out.print(new MyThread(group, "name" + i).getPriority() + " ");
        }
        //output
        //3 4 5 6 7 7 7 7 1 2 3 4
    }

}
	
	
	package com.javarush.test.level28.lesson06.home01;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by Кира on 11.11.2016.
 */
public class MyThread extends Thread {

    private static AtomicInteger currentPriority = new AtomicInteger(0);

    public MyThread() {
        init();
    }

    public MyThread(Runnable target) {
        super(target);
        init();
    }

    public MyThread(ThreadGroup group, Runnable target) {
        super(group, target);
        init();
    }

    public MyThread(String name) {
        super(name);
        init();
    }

    public MyThread(ThreadGroup group, String name) {
        super(group, name);
        init();
    }

    public MyThread(Runnable target, String name) {
        super(target, name);
        init();
    }

    public MyThread(ThreadGroup group, Runnable target, String name) {
        super(group, target, name);
        init();
    }

    public MyThread(ThreadGroup group, Runnable target, String name, long stackSize) {
        super(group, target, name, stackSize);
        init();
    }

    private void init() {
        currentPriority.incrementAndGet();
        currentPriority.compareAndSet(11, 1);

        int newPriority = currentPriority.get();

        if (getThreadGroup() != null) {
            if (newPriority > getThreadGroup().getMaxPriority()) {
                newPriority = getThreadGroup().getMaxPriority();
            }
        }
        setPriority(newPriority);
    }

}

	
	

	
	
	
	
	
	
	
package com.javarush.test.level28.lesson08.task01;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/* Знакомство с Executors
1. В методе main создай фиксированный пул из 5 трэдов используя класс Executors.
2. В цикле отправь на исполнение в пул 10 тасок Runnable.
3. У каждой таски в методе run вызови метод doExpensiveOperation с порядковым номером таски начиная с 1, см. пример вывода
4. Запрети добавление новых тасок на исполнение в пул (метод shutdown)
5. Дай экзэкьютору 5 секунд на завершение всех тасок (метод awaitTermination и параметр TimeUnit.SECONDS)
Не должно быть комментариев кроме приведенного output example
*/
public class Solution {
    public static void main(String[] args) throws InterruptedException {

        final ExecutorService exec = Executors.newFixedThreadPool(5);

        for(int i = 0; i < 10; i++){
            final int localId = i;

            exec.submit(new Runnable() {
                @Override
                public void run() {

                    doExpensiveOperation(localId);
                }
            });
        }

        exec.shutdown();

        exec.awaitTermination(5, TimeUnit.SECONDS);


        /* output example
pool-1-thread-2, localId=2
pool-1-thread-1, localId=1
pool-1-thread-3, localId=3
pool-1-thread-1, localId=7
pool-1-thread-1, localId=9
pool-1-thread-4, localId=4
pool-1-thread-5, localId=5
pool-1-thread-2, localId=6
pool-1-thread-1, localId=10
pool-1-thread-3, localId=8
         */
    }

    private static void doExpensiveOperation(int localId) {
        System.out.println(Thread.currentThread().getName() + ", localId="+localId);
    }
}
	
	
	
	
	
	
	
	
	
	
package com.javarush.test.level28.lesson08.task02;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/* Знакомство с ThreadPoolExecutor
1. В методе main создай очередь LinkedBlockingQueue<Runnable>
2. В цикле добавь в очередь 10 тасок Runnable.
3. У каждой таски в методе run вызови метод doExpensiveOperation с порядковым номером таски начиная с 1, см. пример вывода
4. Создай объект ThreadPoolExecutor со следующими параметрами:
- основное количество трэдов (ядро) = 3
- максимальное количество трэдов = 5
- время удержания трэда живым после завершения работы = 1000
- тайм-юнит - миллисекунды
- созданная в п.1. очередь с тасками
5. Запусти все трэды, которые входят в основное кол-во трэдов - ядро), используй метод prestartAllCoreThreads
6. Запрети добавление новых тасок на исполнение в пул (метод shutdown)
7. Дай экзэкьютору 5 секунд на завершение всех тасок (метод awaitTermination и параметр TimeUnit.SECONDS)
Не должно быть комментариев кроме приведенного output example
*/
public class Solution {
    public static void main(String[] args) throws InterruptedException {

        LinkedBlockingQueue<Runnable> que = new LinkedBlockingQueue<>();

        for(int i = 0; i < 11; i++){

            final int localId = i;

            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    doExpensiveOperation(localId);
                }
            };
            que.put(runnable);
        }

        ThreadPoolExecutor exec = new ThreadPoolExecutor(3, 5, 1000, TimeUnit.MILLISECONDS, que);
        exec.prestartAllCoreThreads();

        exec.shutdown();
        exec.awaitTermination(5, TimeUnit.SECONDS);


        /* output example
pool-1-thread-2, localId=2
pool-1-thread-3, localId=3
pool-1-thread-1, localId=1
pool-1-thread-3, localId=5
pool-1-thread-2, localId=4
pool-1-thread-3, localId=7
pool-1-thread-1, localId=6
pool-1-thread-3, localId=9
pool-1-thread-2, localId=8
pool-1-thread-1, localId=10
         */
    }

    private static void doExpensiveOperation(int localId) {
        System.out.println(Thread.currentThread().getName() + ", localId=" + localId);
    }
}
	
	








package com.javarush.test.level28.lesson10.task01;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/* Осваиваем Callable
Реализуйте логику метода getTask, который должен возвращать объект Callable.
Объект Callable должен вычислять сумму всех чисел от 1 до переданного числа i включая его, и возвращать его в виде строки
Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) throws Exception {
        List<Future<String>> futures = new ArrayList<>();

        ExecutorService executor = Executors.newFixedThreadPool(5);

        for (int i = 1000; i <= 1010; i++) {
            futures.add(executor.submit(getTask(i)));
        }

        futures.add(executor.submit(getTask(10000000)));

        for(Future<String> future : futures) {
            System.out.println(future.get());
        }

        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);

/* output
500500
501501
502503
503506
504510
505515
506521
507528
508536
509545
510555
50000005000000
*/
    }

    public static class TotalSum implements Callable<String> {

        public TotalSum(int i){

            this.i = i;
        }

        int i = 0;

        @Override
        public String call() throws Exception {
            long sum = 0;
            for(int j = 1; j <= i; j++) {
                sum += j;
            }
            return Long.toString(sum);
        }
    }

    public static Callable<String> getTask(final int i) throws Exception {

        return new TotalSum(i);
    }
}















package com.javarush.test.level28.lesson10.home01;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Phaser;

/* Plants vs Zombies
1. Почитайте про java.util.concurrent.Phaser
2. Расставь методы в нужных местах
-arriveAndDeregister() - начинает запускать методы run у тасок
-arriveAndAwaitAdvance() - ждет, когда все трэды будут созданы

Пример вывода см. в output.txt
Логика:
Сначала все персонажи присоединяются к игре.
После того, как все персонажи присоединятся к игре и готовы играть, выводится фраза "Игра началась!".
После этого персонажи вступают в игру, после чего умирают.
Не должно быть закоментированного кода
*/
public class Solution {
    public static void main(String[] args) throws InterruptedException {
        List<Character> characters = new ArrayList<>();
        characters.add(new Plant());
        characters.add(new Plant());
        characters.add(new Zombie());
        characters.add(new Zombie());
        characters.add(new Zombie());
        start(characters);
    }

    private static boolean isEveryoneReady = false;

    private static void start(List<Character> characters) throws InterruptedException {
        final Phaser phaser = new Phaser(1 + characters.size()); // 1 - чтоб зарегистрировать себя

        for (final Character character : characters) {
            final String member = character.toString();
            System.out.println(member + " присоединился к игре");
            new Thread() {
                @Override
                public void run() {
                    System.out.println(member + " готовится играть");
                    phaser.arriveAndAwaitAdvance();
                    if (!isEveryoneReady) {
                        isEveryoneReady = true;
                        System.out.println("Игра началась!");
                    }
                    character.run();
                }
            }.start();
        }
        phaser.arriveAndDeregister();
    }
}



package com.javarush.test.level28.lesson10.home01;

import java.util.concurrent.atomic.AtomicInteger;

public class Zombie extends Character {
    private final static AtomicInteger idSequence = new AtomicInteger();
    private final int id = idSequence.incrementAndGet();

    protected int getId() {
        return id;
    }
}


package com.javarush.test.level28.lesson10.home01;

import java.util.concurrent.ThreadLocalRandom;

public abstract class Character implements Runnable {
    protected abstract int getId();

    public void run() {
        System.out.println(toString() + " вступил в игру");
        doSomething();
        System.out.println(toString() + " умер");
    }

    private void doSomething() {
        try {
            Thread.currentThread().sleep(ThreadLocalRandom.current().nextInt(10, 100));
        } catch (InterruptedException ignored) {
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + " #" + getId();
    }

}


package com.javarush.test.level28.lesson10.home01;

import java.util.concurrent.atomic.AtomicInteger;

public class Plant extends Character {
    private final static AtomicInteger idSequence = new AtomicInteger();
    private final int id = idSequence.incrementAndGet();

    protected int getId() {
        return id;
    }
}












package com.javarush.test.level29.lesson02.task01;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

/* Рефакторинг в соответствии с Naming and Code Convention
Исправить код в соответствии с Naming and Code Convention (Shift+F6 для рефакторинга)
Не оставлять комментариев, проверяется строгое соответствие стандарту

Подсказка: IDEA не умеет правильно переименовывать имена классов, если меняется только регист.
Переименуйте имя класса во вспомогательное имя, а мотом в это же в правильном регистре.
*/
public class Solution {
    public static final String DEFAULT_FILE_NAME = "C:/tmp/file_strange_name.tmp";
    private final String localFileName;
    private List<String> contentAsLines;
    private boolean fileLoaded;

    public Solution(String firstFileName) {
        localFileName = firstFileName == null ? DEFAULT_FILE_NAME : firstFileName;
    }

    public boolean isFileLoaded() {
        return fileLoaded;
    }

    public void downloadFileContent() {
        Path source = Paths.get(localFileName);

        try {
            contentAsLines = Files.readAllLines(source, Charset.defaultCharset());
            fileLoaded = true;
        } catch (IOException e) {
            System.out.println("Unsuccessful. What a surprise!");
        }
    }

    public boolean hasFileExpectedLine(String expectedLine) {
        return contentAsLines.contains(expectedLine);
    }

    public static void main(String[] args) throws FileNotFoundException {
        String packageName = Solution.class.getPackage().getName().replaceAll("[.]", "\\\\");
        String fileName = "src\\" + packageName + "\\Solution.java";

        Solution solution = new Solution(fileName);
        solution.downloadFileContent();
        if (solution.isFileLoaded()) {
            System.out.println(solution.hasFileExpectedLine("public class Solution {"));
            System.out.println(solution.hasFileExpectedLine(" public class Solution {"));
        }
    }
}










package com.javarush.test.level29.lesson02.task02;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

/* Рефакторинг в соответствии с Naming and Code Convention 2
Исправить код в соответствии с Naming and Code Convention (Shift+F6 для рефакторинга)
Не оставлять комментариев, проверяется строгое соответствие стандарту
*/
public class Solution {
    public static void main(String[] args) throws IOException, InterruptedException {
        Solution solution = new Solution();
        String fileNameToBeOpenedByNotepad = solution.getAbsolutePathToDefaultTxtFile().toString();
        Process notepad = solution.getProcessStartNotepad(fileNameToBeOpenedByNotepad);
        notepad.waitFor();
    }

    public Process getProcessStartNotepad(String fileName) throws IOException {
        String[] cmdArray = new String[]{"notepad.exe", fileName};
        return Runtime.getRuntime().exec(cmdArray);
    }

    public Path getAbsolutePathToDefaultTxtFile() {
        String packageName = Solution.class.getPackage().getName().replaceAll("[.]", "\\\\");
        String fileName = "src\\" + packageName + "\\file.txt";
        Path path = Paths.get(fileName);
        return path.toAbsolutePath();
    }
}




	
	









package com.javarush.test.level29.lesson05.task01;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ThreadLocalRandom;

/* И еще раз рефакторинг
1. Исправить код в соответствии с Naming and Code Convention (Shift+F6 для рефакторинга)
2. Просмотрите методы класса ConcurrentMap.
3. В строке "String previousEntry = null;" у concurrentMap вызовите метод,
который вставит пару (randomInt, text) только для ключа, которого нет в concurrentMap.
Метод должен возвращать предыдущее значение либо null для новой пары.
*/
public class Solution {
    public static final ThreadLocalRandom RANDOM = ThreadLocalRandom.current();

    public static void main(String[] args) {
        ConcurrentMap<Integer, String> concurrentMap = new ConcurrentHashMap<>();
        for (int i = 0; i < 100; i++) {
            new Thread(getRunnable(i, concurrentMap)).start();
        }
        sleepASecond();
    }

    private static void sleepASecond() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static Runnable getRunnable(final int i, final ConcurrentMap<Integer, String> concurrentMap) {
        return new Runnable() {
            @Override
            public void run() {
                final String name = "Thread #" + i;
                int randomInt = RANDOM.nextInt(20);
                String text = name + " вставил запись для " + randomInt;
                String previousEntry = concurrentMap.putIfAbsent(randomInt, text);
                if (previousEntry != null) {
                    System.out.println(name + " хочет обновить " + randomInt + ", однако уже " + previousEntry);
                } else {
                    System.out.println(text);
                }
            }
        };
    }
}












package com.javarush.test.level29.lesson05.task02;

/* Особенности автобоксинга
Исправьте ошибку в методе getValueByIndex.
Читайте доп. статью про особенности автобоксинга.
*/
public class Solution {
    private Integer[] array = new Integer[]{1, 2, 3, 4};

    Number getValueByIndex(int index) {
        if ((index >= 0) && (index < array.length)){
            return new Integer(array[index]);
        }
        else{
            return new Double(-1);
        }
    }

    public static void main(String[] args) {
        Number value1 = new Solution().getValueByIndex(5); //-1.0, class java.lang.Double expected
        Number value2 = new Solution().getValueByIndex(2); //3, class java.lang.Integer expected

        System.out.println(value1 + ", " + value1.getClass().toString());
        System.out.println(value2 + ", " + value2.getClass().toString());
    }
}












package com.javarush.test.level29.lesson07.task01;

import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.logging.Level;
import java.util.logging.Logger;

/* Странные ошибки О_о
Исправьте 2 ошибки:
1) возникновение исключения
2) подвисание
Сделайте минимальные изменения.
*/
public class Solution {
    final int NUMBER_OF_THREADS = 3; //3 треда будет обрабатывать нашу очередь
    final int MAX_BATCH_SIZE = 100; //будем вытаскивать по 100 сообщений

    private Logger logger = Logger.getLogger(Solution.class.getName());
    private BlockingQueue messageQueue = new LinkedBlockingQueue();//тут будут храниться все сообщения

    private BlockingQueue fakeDataBase = new LinkedBlockingQueue();//тут будут храниться все сообщения*/

    public void startMessageCreating() {
        new Thread() {
            @Override
            public void run() {
                for (int i = 0; i < 100000; i++) {
                    messageQueue.add(String.valueOf(i));
                }
            }
        }.start();
    }

    public void startMessagePersisting() {
        for (int i = 0; i < NUMBER_OF_THREADS; i++) {
            new Thread() {
                private final Collection batch = new ArrayList(MAX_BATCH_SIZE);
                {
                    setDaemon(true);
                }

                @Override
                public void run() {
                    while (true) {
                        try {
                            messageQueue.drainTo(batch, MAX_BATCH_SIZE);
                            persistData(batch);
                            batch.clear();
                            Thread.sleep(1);
                        } catch (Throwable e) {
                            logger.log(Level.SEVERE, "impossible to persist a batch", e);
                        }
                    }
                }
            }.start();
        }
    }

    private void persistData(Collection batch) {
        //представим, что тут мы коннектимся к базе данных, и сохраняем данные в нее
        //сохранение данных по 1 записи тратит много ресурсов, поэтому делают батчем (группой по несколько)
        fakeDataBase.addAll(batch);
    }

    private void printResults() {
        System.out.println();
        System.out.println("messageQueue size is " + messageQueue.size());
        System.out.println("fakeDataBase size is " + fakeDataBase.size());
    }

    public static void main(String[] args) throws InterruptedException {
        // статики во многих местах неуместны, поэтому помещаем все данные в поля класса,
        // затем создаем объект и вызываем его метод
        Solution solution = new Solution();

        solution.startMessageCreating();
        solution.startMessagePersisting();

        Thread.sleep(100);
        solution.printResults();

        Thread.sleep(100);
        solution.printResults();

        Thread.sleep(100);
        solution.printResults();

        Thread.sleep(500);
        solution.printResults();
    }
}









package com.javarush.test.level29.lesson07.task02;

/* Особенности автобоксинга - 2
Исправьте ошибку реализации, приводящую к NullPointerException, в методе getValue.
Читайте доп. статью про особенности автобоксинга.
*/
public class Solution {
    public static void main(String[] args) {
        Integer a = getValue(Boolean.TRUE, Boolean.TRUE);   //100 expected
        Integer b = getValue(Boolean.FALSE, Boolean.TRUE);  //200 expected
        Integer c = getValue(Boolean.FALSE, Boolean.FALSE); //null expected

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
    }

    public static Integer getValue(boolean first, boolean second) {
        if (second){
            if(first)
                return 100;
            else{
                return 200;
            }
        }
        else{
            if(first){
                return 100;

            }else{
                return null;
            }
        }
    }
}










package com.javarush.test.level29.lesson09.task01;

import java.math.BigDecimal;

/* Этот странный BigDecimal
Исправьте ошибку реализации, приводящую к погрешности вычисления, в методе getValue.
Сигнатуру метода не менять. Округление не использовать.
Читайте доп. статью про особенности автобоксинга.
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(getValue(1.1d, 1.2d));
    }

    public static BigDecimal getValue(double v1, double v2) {
        return new BigDecimal(v1 + "").add(new BigDecimal(v2 + ""));
    }
}

	
	
	




	
	
	
	



package com.javarush.test.level29.lesson09.bonus01;

/* Кеширование
В CacheComputeManager реализуйте логику пустого метода.
Догадайтесь, что он должен делать по названию метода и по логике класса.
*/
public class Solution {
    public static void main(String[] args) throws InterruptedException {
        //////////////first example///////////////////
        Square square = new Square();
        CacheComputeManager<Integer, Integer> manager = new CacheComputeManager(square);

        for (int i = 0; i < 8; i++) {
            int j = i % 4;
            Integer result = manager.compute(j);
            System.out.format("%d * %d = %d\n", j, j, result);
        }

        /* output
            0 will be cached  0 * 0 = 0
            1 will be cached  1 * 1 = 1
            2 will be cached  2 * 2 = 4
            3 will be cached  3 * 3 = 9
            0 taken from cache  0 * 0 = 0
            1 taken from cache  1 * 1 = 1
            2 taken from cache  2 * 2 = 4
            3 taken from cache  3 * 3 = 9
         */

        //////////////second example///////////////////
        Copyright copyright = new Copyright();
        CacheComputeManager manager2 = new CacheComputeManager(copyright);
        System.out.println(manager2.compute(new Copyright.Period(3012, 3147)));
        System.out.println(manager2.compute(new Copyright.Period(3012, 3146)));
        System.out.println(manager2.compute(new Copyright.Period(3012, 3147)));

        /* output
        Period{firstYear=3012, secondYear=3147} will be cached  All rights reserved (c) 3012-3147
        Period{firstYear=3012, secondYear=3146} will be cached  All rights reserved (c) 3012-3146
        Period{firstYear=3012, secondYear=3147} taken from cache  All rights reserved (c) 3012-3147
         */
    }
}

package com.javarush.test.level29.lesson09.bonus01;

/* Argument and Value are generic types*/
public interface Computable<Argument, Value> {
    Value compute(Argument argument) throws InterruptedException;
}


package com.javarush.test.level29.lesson09.bonus01;

public class Square implements Computable<Integer, Integer> {
    @Override
    public Integer compute(Integer integer) throws InterruptedException {
        int val = integer.intValue();
        return val * val;
    }
}


package com.javarush.test.level29.lesson09.bonus01;

public class Copyright implements Computable<Copyright.Period, String> {
    @Override
    public String compute(Period period) throws InterruptedException {
        return "All rights reserved (c) " + period.firstYear + "-" + period.secondYear;
    }

    public static class Period {
        int firstYear;
        int secondYear;

        public Period(int firstYear, int secondYear) {
            this.firstYear = firstYear;
            this.secondYear = secondYear;
        }

        @Override
        public String toString() {
            return "Period{" +
                    "firstYear=" + firstYear +
                    ", secondYear=" + secondYear +
                    '}';
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Period)) return false;

            Period period = (Period) o;

            if (firstYear != period.firstYear) return false;
            if (secondYear != period.secondYear) return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = firstYear;
            result = 31 * result + secondYear;
            return result;
        }
    }
}


package com.javarush.test.level29.lesson09.bonus01;

import java.util.concurrent.*;

/* Argument and Value are generic types*/
public class CacheComputeManager<Argument, Value> implements Computable<Argument, Value> {
    private final ConcurrentHashMap<Argument, Future<Value>> cache = new ConcurrentHashMap<>();
    private Computable<Argument, Value> computable;

    public CacheComputeManager(Computable<Argument, Value> computable) {
        this.computable = computable;
    }

    @Override
    public Value compute(final Argument arg) throws InterruptedException {
        Future<Value> f = cache.get(arg);
        if (f == null) {
            FutureTask<Value> ft = createFutureTaskForNewArgumentThatHaveToComputeValue(arg);
            cache.putIfAbsent(arg, ft);
            f = ft;
            ft.run();
            System.out.print(arg + " will be cached  ");
        } else {
            System.out.print(arg + " taken from cache  ");
        }
        try {
            return f.get();
        } catch (CancellationException e) {
            cache.remove(arg, f);
        } catch (ExecutionException e) {
            throw new RuntimeException(e.getCause());
        }
        return null;
    }

    public FutureTask<Value> createFutureTaskForNewArgumentThatHaveToComputeValue(final Argument arg) {

        return new FutureTask<Value>(new Callable<Value>() {
            @Override
            public Value call() throws Exception {
                return computable.compute(arg);
            }
        });
    }
}









1) Для записи числа используются 16 цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

2) Число 54316 значит 5*162+4*161+3*160. Т.е. это 5*256+4*16+3*1 =1280+64+3=134710

- Т.е. мы просто добавили буквы в качестве цифр? О_о

- Ага. А что в этом такого? Зачем придумывать новые цифры, когда с этой ролью отлично справляются буквы. Вот смотри:

Шестнадцатеричная цифра	Десятичное значение
0	0
1	1
8	8
9	9
A	10
B	11
C	12
D	13
E	14
F	15
Про перевод из десятичной системы в шестнадцатеричную тоже рассказывать не буду. Зато есть один интересный факт. Шестнадцатеричная цифра – это ровно 4 бита со значениями от 0 до 15. Поэтому один байт можно записать восемью двоичными цифрами (0 или 1) или двумя шестнадцатеричными.

Пример:

Десятичное число	Двоичное число	Шестнадцатеричное число
0	0000 0000	00
1	0000 0001	01
15	0000 1111	0f
16	0001 0000	10
31	0001 1111	1f
32	0010 0000	20
128	1000 0000	80
129	1000 0001	81
255	1111 1111	ff
Шестнадцатеричное представление легко приводится к двоичному (и обратно). Поэтому, если где-то в программировании нужно показать именно внутреннее байтовое представление числа, то очень редко прибегают к двоичной записи через 0 и 1. Слишком длинно и не понятно. Шестнадцатеричная запись гораздо читабельней и компактней.

- Согласен. Даже мне понравилось.

- Кстати, в Java можно прямо в коде записывать числа в различных системах исчисления:

Основание	Отличительный признак	Примеры	Неправильные числа
2	0b в начале числа	0b00001111	0b1111121
8	0 в начале числа	01234343	0128
10	нет	95459	909a
16	0x в начале числа	0x10ff	0x1cgh













package com.javarush.test.level30.lesson02.task01;

/* Осваиваем методы класса Integer
Используя метод Integer.parseInt(String, int) реализуйте логику метода convertToDecimalSystem,
который должен переводить переданную строку в десятичное число и возвращать его в виде строки.
*/
public class Solution {

    public static void main(String[] args) {
        System.out.println(convertToDecimalSystem("0x16")); //22
        System.out.println(convertToDecimalSystem("012"));  //10
        System.out.println(convertToDecimalSystem("0b10")); //2
        System.out.println(convertToDecimalSystem("62"));   //62
    }

    public static String convertToDecimalSystem(String s) {
        if (s.startsWith("0x")) {
            return String.valueOf(Integer.parseInt(s.substring(2, s.length()), 16));
        } else if (s.startsWith("0b")) {
            return String.valueOf(Integer.parseInt(s.substring(2, s.length()), 2));
        } else if (s.startsWith("0")) {
            return String.valueOf(Integer.parseInt(s.substring(1, s.length()), 8));
        } else {
            return s;
        }
    }
}







!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

package com.javarush.test.level30.lesson02.home01;

import java.math.BigInteger;

/* Конвертер систем счислений
Реализуйте логику метода convertNumberToOtherNumerationSystem, который должен переводить число number.getDigit()
из одной системы счисления(numerationSystem) в другую (expectedNumerationSystem)
бросьте NumberFormatException, если переданное число некорректно, например, число "120" с системой счисления 2
Валидация для - number.getDigit() - целое не отрицательное
Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        Number number = new Number(NumerationSystemType._10, "6");
        Number result = convertNumberToOtherNumerationSystem(number, NumerationSystemType._2);
        System.out.println(result);    //expected 110
    }

    public static Number convertNumberToOtherNumerationSystem(Number number, NumerationSystem expectedNumerationSystem) {

            BigInteger decimalNumber = new BigInteger(number.getDigit(), number.getNumerationSystem().getNumerationSystemIntValue());
            String str = decimalNumber.toString(expectedNumerationSystem.getNumerationSystemIntValue());
            return new Number(expectedNumerationSystem, str);

    }
}

!!!!!!!!!!!!!!!!

 /**
     * Returns the String representation of this BigInteger in the
     * given radix.  If the radix is outside the range from {@link
     * Character#MIN_RADIX} to {@link Character#MAX_RADIX} inclusive,
     * it will default to 10 (as is the case for
     * {@code Integer.toString}).  The digit-to-character mapping
     * provided by {@code Character.forDigit} is used, and a minus
     * sign is prepended if appropriate.  (This representation is
     * compatible with the {@link #BigInteger(String, int) (String,
     * int)} constructor.)
     *
     * @param  radix  radix of the String representation.
     * @return String representation of this BigInteger in the given radix.
     * @see    Integer#toString
     * @see    Character#forDigit
     * @see    #BigInteger(java.lang.String, int)
     */
	 
	 
	 
	 
    public String toString(int radix) {
        if (signum == 0)
            return "0";
        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
            radix = 10;

        // Compute upper bound on number of digit groups and allocate space
        int maxNumDigitGroups = (4*mag.length + 6)/7;
        String digitGroup[] = new String[maxNumDigitGroups];

        // Translate number to string, a digit group at a time
        BigInteger tmp = this.abs();
        int numGroups = 0;
        while (tmp.signum != 0) {
            BigInteger d = longRadix[radix];

            MutableBigInteger q = new MutableBigInteger(),
                              a = new MutableBigInteger(tmp.mag),
                              b = new MutableBigInteger(d.mag);
            MutableBigInteger r = a.divide(b, q);
            BigInteger q2 = q.toBigInteger(tmp.signum * d.signum);
            BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);

            digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);
            tmp = q2;
        }

        // Put sign (if any) and first digit group into result buffer
        StringBuilder buf = new StringBuilder(numGroups*digitsPerLong[radix]+1);
        if (signum<0)
            buf.append('-');
        buf.append(digitGroup[numGroups-1]);

        // Append remaining digit groups padded with leading zeros
        for (int i=numGroups-2; i>=0; i--) {
            // Prepend (any) leading zeros for this digit group
            int numLeadingZeros = digitsPerLong[radix]-digitGroup[i].length();
            if (numLeadingZeros != 0)
                buf.append(zeros[numLeadingZeros]);
            buf.append(digitGroup[i]);
        }
        return buf.toString();
    }

    /* zero[i] is a string of i consecutive zeros. */
    private static String zeros[] = new String[64];
    static {
        zeros[63] =
            "000000000000000000000000000000000000000000000000000000000000000";
        for (int i=0; i<63; i++)
            zeros[i] = zeros[63].substring(0, i);
    }
	
	
	

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	










в каком порядке выполняются операторы в таком выражении?

 
boolean a = true;
boolean b = false;
boolean c = true;

boolean result = a && b || !c &&b || !a;
- Тут все очень просто.

Сначала выполняется операция NOT(!) , затем AND(&&), а в самом конце OR(||).

Т.е. если добавить скобки, то у нас получится:

 
boolean a = true;
boolean b = false;
boolean c = true;

boolean result = (a && b) || ((!c) && b) || (!a);
- Все правильно, молодец. И какой же будет ответ?

- 1) (a && b) == (true && false) == false

2) ((!c) && b) == (false && false) == false

3) (!a) == false

4) false || false || false == false

Ответ – false.











package com.javarush.test.level30.lesson04.home01;

import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TransferQueue;

/* Экономим время
1. Создайте Producer и Consumer (См. комментарий к методу main)
2. Создайте методы toString, equals и hashCode в классе ShareItem. Для этого в теле класса ShareItem выполни:
2.1. Alt+Enter -> toString() -> Enter
2.2. Alt+Enter -> equals() and hashCode() -> click all 'Next'-s
3. В Producer и Consumer реализуйте метод run так, чтобы вызов метода interrupt прерывал работу consumer и producer трэдов

4. Реализация метода run для Producer:
4.1. Используя метод offer добавить в очередь 9 ShareItem-ов с такими параметрами: ("ShareItem-N", N), где N - номер элемента от 1 до 9
4.2. Перед каждым добавлением вывести фразу "Элемент 'ShareItem-N' добавлен". Используйте System.out.format
4.3. Усыпить трэд на 0.1 секунды
4.4. Если у очереди есть Consumer, не занятый работой, то вывести фразу "Consumer в ожидании!".
Просмотрите методы интерфейса TransferQueue, там есть нужный метод.

5. Реализация метода run для Consumer:
5.1. Усыпить трэд на 0.5 секунды
5.2. В бесконечном цикле заберите элемент из очереди методом take и выведите в консоль "Processing item.toString()".

6. Сверьте вывод с файлом output.txt
7. Стек-трейс не выводите в консоль
*/
public class Solution {
    /*
    1. Создайте класс Producer. Для этого на красном имени класса нажмите Alt+Enter -> Create Class ...
    2. Станьте на имени аргумента в конструкторе (queue) и нажмите Alt+Enter -> Create Field for Parameter 'queue' -> Enter -> Enter
    3. Станьте на подчеркнутой строке - описании класса. Далее Alt+Enter -> Implement Methods -> Enter
    4. Проделайте п.1-3 для класса Consumer
     */

    public static void main(String[] args) throws InterruptedException {
        TransferQueue<ShareItem> queue = new LinkedTransferQueue<>();

        Thread producer = new Thread(new Producer(queue));
        Thread consumer = new Thread(new Consumer(queue));
        producer.start();
        consumer.start();

        Thread.sleep(1500);

        producer.interrupt();
        consumer.interrupt();
    }

}



package com.javarush.test.level30.lesson04.home01;

import java.util.concurrent.TransferQueue;

/**
 * Created by Кира on 15.11.2016.
 */
public class Producer implements Runnable {

    /**
     * 4. Реализация метода run для Producer:
     4.1. Используя метод offer добавить в очередь 9 ShareItem-ов с такими параметрами: ("ShareItem-N", N), где N - номер элемента от 1 до 9
     4.2. Перед каждым добавлением вывести фразу "Элемент 'ShareItem-N' добавлен". Используйте System.out.format
     4.3. Усыпить трэд на 0.1 секунды
     4.4. Если у очереди есть Consumer, не занятый работой, то вывести фразу "Consumer в ожидании!".
     Просмотрите методы интерфейса TransferQueue, там есть нужный метод.
     */

    private TransferQueue<ShareItem> queue;

    public Producer(TransferQueue<ShareItem> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 9; i++) {
            if (Thread.currentThread().isInterrupted()) {
                return;
            }
            System.out.format("Элемент 'ShareItem-%d' добавлен%n", i);
            queue.offer(new ShareItem("ShareItem-"+i, i));
            try {
                Thread.sleep(100);
            }
            catch (InterruptedException e) {}

            if (queue.hasWaitingConsumer()) {
                System.out.println("Consumer в ожидании!");
            }
        }
    }
}



package com.javarush.test.level30.lesson04.home01;

import java.util.concurrent.TransferQueue;

/**
 * Created by Кира on 15.11.2016.
 */
public class Consumer implements Runnable {

    /**
     * 5. Реализация метода run для Consumer:
     5.1. Усыпить трэд на 0.5 секунды
     5.2. В бесконечном цикле заберите элемент из очереди методом take и выведите в консоль "Processing item.toString()".
     */

    private TransferQueue<ShareItem> queue;

    public Consumer(TransferQueue<ShareItem> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {

        while (!Thread.currentThread().isInterrupted()) {
            try {

                Thread.sleep(500);

                while (true){
                    ShareItem item = queue.take();
                    System.out.println("Processing " + item.toString());
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

    }
}



package com.javarush.test.level30.lesson04.home01;

//this class shows how to call other constructors using 'this'
public class ShareItem {
    public String description;
    public int itemId;

    public ShareItem() {
        this("Test Item", 0);
    }

    public ShareItem(String description) {
        this(description, 0);
    }

    public ShareItem(int itemId) {
        this("Test Item", itemId);
    }

    public ShareItem(String description, int itemId) {
        this.description = description;
        this.itemId = itemId;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ShareItem)) return false;

        ShareItem shareItem = (ShareItem) o;

        if (itemId != shareItem.itemId) return false;
        return description.equals(shareItem.description);

    }

    @Override
    public int hashCode() {
        int result = description.hashCode();
        result = 31 * result + itemId;
        return result;
    }

    @Override
    public String toString() {
        return "ShareItem{description='ShareItem-" + itemId + "', itemId=" + itemId + "}";
    }

    public String getDescription() {
        return description;
    }

    public int getItemId() {
        return itemId;
    }
}



OUTPUT:
Элемент 'ShareItem-1' добавлен
Элемент 'ShareItem-2' добавлен
Элемент 'ShareItem-3' добавлен
Элемент 'ShareItem-4' добавлен
Элемент 'ShareItem-5' добавлен
Processing ShareItem{description='ShareItem-1', itemId=1}
Processing ShareItem{description='ShareItem-2', itemId=2}
Processing ShareItem{description='ShareItem-3', itemId=3}
Processing ShareItem{description='ShareItem-4', itemId=4}
Processing ShareItem{description='ShareItem-5', itemId=5}
Consumer в ожидании!
Элемент 'ShareItem-6' добавлен
Processing ShareItem{description='ShareItem-6', itemId=6}
Consumer в ожидании!
Элемент 'ShareItem-7' добавлен
Processing ShareItem{description='ShareItem-7', itemId=7}
Consumer в ожидании!
Элемент 'ShareItem-8' добавлен
Processing ShareItem{description='ShareItem-8', itemId=8}
Consumer в ожидании!
Элемент 'ShareItem-9' добавлен
Processing ShareItem{description='ShareItem-9', itemId=9}
Consumer в ожидании!














package com.javarush.test.level30.lesson06.task01;

import java.util.ArrayList;
import java.util.List;

/* Такие хитрые исключения!
Исправьте реализацию метода checkAFlag, чтобы во всех случаях он не приводил к бросанию исключений.
Сохраните логику вывода данных.
Метод main не участвует в тестировании.
*/
public class Solution {
    public static void main(String[] args) {
        D d = new D();
        d.cs = null;
        B b = new B();
        b.as = null;
        checkAFlag(d);


    }

    public static void checkAFlag(D d) {
        if (   d != null
                && d.cs != null
                && !d.cs.isEmpty()
                && d.cs.get(0).bs != null
                && !d.cs.get(0).bs.isEmpty()
                && d.cs.get(0).bs.get(0).as != null
                && !d.cs.get(0).bs.get(0).as.isEmpty()
                && d.cs.get(0).bs.get(0).as.get(0).flag)
        {
            System.out.println("A's flag is true");
        } else { //all other cases
            System.out.println("Oops!");
        }
    }

    static class A {
        boolean flag = true;
    }

    static class B {
        List<A> as = new ArrayList<>();
        {
            as.add(new A());
        }
    }

    static class C {
        List<B> bs = new ArrayList<>();
        {
            bs.add(new B());
        }
    }

    static class D {
        List<C> cs = new ArrayList<>();
        {
            cs.add(new C());
        }
    }
}












package com.javarush.test.level30.lesson06.home01;

import java.util.concurrent.ForkJoinPool;

/* Fork/Join
1. Создайте класс BinaryRepresentationTask. Для этого на красном имени класса нажмите Alt+Enter -> Create Class ...
(класс должен наследоваться от RecursiveTask)
2. Реализуйте логику метода compute, должна переводить число в двоичное представление.
3. Используйте методы fork и join.
4. Пример функциональной реализации - метод binaryRepresentationMethod.
*/
public class Solution {
    private String binaryRepresentationMethod(int x) {

        int a = x % 2;
        int b = x / 2;
        String result = String.valueOf(a);
        if (b > 0) {
            return binaryRepresentationMethod(b) + result;
        }
        return result;
    }


    public static void main(String[] args) {
        Solution solution = new Solution();
        String result1 = solution.binaryRepresentationMethod(6);
        System.out.println(result1);

        System.out.println();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        String result2 = (String) forkJoinPool.invoke(new BinaryRepresentationTask(6));
        System.out.println(result2);
    }

}



package com.javarush.test.level30.lesson06.home01;

import java.util.concurrent.RecursiveTask;

/**
 * Created by Кира on 16.11.2016.
 */
public class BinaryRepresentationTask extends RecursiveTask{

    private int num;

    public BinaryRepresentationTask(int i) {

        this.num = i;

    }


    @Override
    protected String compute() {

        int a = num % 2;  //1
        int b = num / 2;  //3

        String result = String.valueOf(a);

        System.out.println(a);
        System.out.println(b);

        if (b > 0) {
            BinaryRepresentationTask task = new BinaryRepresentationTask(b);
            task.fork();
            return task.join() + result;
        }
        return result;
    }
}









package com.javarush.test.level30.lesson08.task01;

/* Найдем число 2 в максимальной степени
Реализуйте логику метода maxPowerOf2,
который должен возвращать число 2 в максимальной степени, которое получается поместить в переданное число
Аргументом maxPowerOf2 может быть только положительное число
Используйте только операции: 1)побитовые сдвиги, 2) присваивание, 3) побитовое ИЛИ
Не оставляйте комментарии
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(maxPowerOf2(140_000));   //131072
        System.out.println(maxPowerOf2(1026));      //1024
        System.out.println(maxPowerOf2(17));        //16
    }

    public static int maxPowerOf2(int x) {

        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        return x - (x >> 1);
    }
}











package com.javarush.test.level30.lesson08.home01;

/* Swap по-новому
В классе Pair реализуйте метод swap, который должен для x, y менять местами их значения.
Можно использовать только операции 1)исключающее или, 2) присваивание
Не оставляйте комментарии, не меняйте остальной код
*/
public class Solution {
    public static void main(String[] args) {

        Pair pair = new Pair(4, 5);
        System.out.println(pair);
        pair.swap();
        System.out.println(pair);
    }
}




package com.javarush.test.level30.lesson08.home01;

public class Pair {
    private int x;
    private int y;

    public Pair(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("x=%d, y=%d", x, y);
    }

    public void swap() {

        x ^= y;
        x ^= (y ^= x);
    }
	
	//OR:
	
	x ^= y; // стало 2
	System.out.println(x);
	y ^= x; // стало 5
	System.out.println(y);
	x ^= y; //стало 7
	System.out.println(x);
}







___________________________________________________________________CHAT___________________________________________________


package com.javarush.test.level30.lesson15.big01;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by Кира on 16.11.2016.
 */
public class Server {

    private static final Map<String, Connection> connectionMap = new ConcurrentHashMap<>();


    public static void main(String[] args) throws IOException {

        ConsoleHelper.writeMessage("Введите порт сервера: ");
        int serverPort = ConsoleHelper.readInt();

        try (ServerSocket serverSocket = new ServerSocket(serverPort)) {

            ConsoleHelper.writeMessage("Сервер запущен! Вы можете начать обмен сообщениями");

            while (true) {
                //Слушаем
                Socket socket = serverSocket.accept();
                Handler handler = new Handler(socket);
                //запускаем handler
                handler.start();
            }
        }
    }


    public static void sendBroadcastMessage(Message message) {

        for (Map.Entry<String, Connection> entry : connectionMap.entrySet()) {
            try{
                entry.getValue().send(message);

            }catch(IOException e){
                ConsoleHelper.writeMessage("Произошла ошибка! В данный момент сообщение не может ыть отправлено.");
            }
        }
    }

    private static class Handler extends Thread {

        private Socket socket;

        public Handler(Socket socket) {
            this.socket = socket;
        }


        public void run() {

            String errorMessage = null;
            String userName = null;

            SocketAddress socketAddress = null;

            try (Connection connection = new Connection(socket)) {
                socketAddress = connection.getRemoteSocketAddress();

                errorMessage = "Произошла ошибка обмена данных с удаленным адресом: " + socketAddress;

                ConsoleHelper.writeMessage("Установлено новое соединение с удаленным адресом: " + socketAddress);

                userName = serverHandshake(connection);
                sendBroadcastMessage(new Message(MessageType.USER_ADDED, userName));
                sendListOfUsers(connection, userName);
                serverMainLoop(connection, userName);

            } catch (IOException e) {
                ConsoleHelper.writeMessage(errorMessage);
            } catch (ClassNotFoundException e) {
                ConsoleHelper.writeMessage(errorMessage);
            } finally {
                if (userName != null) {
                    connectionMap.remove(userName);
                    sendBroadcastMessage(new Message(MessageType.USER_REMOVED, userName));
                }
            }
            ConsoleHelper.writeMessage("Закрыто соединение с удаленным адресом: " + socketAddress);


        }


        private String serverHandshake(Connection connection) throws IOException, ClassNotFoundException {

            while (true) {

                try {
                    connection.send(new Message(MessageType.NAME_REQUEST));
                    Message message = connection.receive();
                    if (message.getType() == MessageType.USER_NAME) {
                        String userName = message.getData();
                        if (userName != null && !userName.isEmpty() && !connectionMap.containsKey(userName)) {
                            connectionMap.put(userName, connection);
                            connection.send(new Message(MessageType.NAME_ACCEPTED));
                            return userName;
                        }
                    }
                } catch (Exception e) {
                    connection.send(new Message(MessageType.NAME_REQUEST));
                }
            }
        }

        private void sendListOfUsers(Connection connection, String userName) throws IOException {

            for (Map.Entry<String, Connection> entry : connectionMap.entrySet()) {

                if (!userName.equals(entry.getKey())) {
                    connection.send(new Message(MessageType.USER_ADDED, entry.getKey()));
                }

            }

        }


        private void serverMainLoop(Connection connection, String userName) throws IOException, ClassNotFoundException {

            while (true) {

                Message message = connection.receive();
                // Если принятое сообщение – это текст (тип TEXT)
                if (message.getType() == MessageType.TEXT) {

                    String s = userName + ": " + message.getData();

                    Message formattedMessage = new Message(MessageType.TEXT, s);
                    sendBroadcastMessage(formattedMessage);

                } else {
                    ConsoleHelper.writeMessage("Error");
                }
            }
        }


    }
}


package com.javarush.test.level30.lesson15.big01.client;

import com.javarush.test.level30.lesson15.big01.Connection;
import com.javarush.test.level30.lesson15.big01.ConsoleHelper;
import com.javarush.test.level30.lesson15.big01.Message;
import com.javarush.test.level30.lesson15.big01.MessageType;

import java.io.IOException;
import java.net.Socket;

/**
 * Created by Кира on 17.11.2016.
 */
public class Client {

    volatile boolean clientConnected = false;
    protected Connection connection;

    public static void main(String[] args) {

        Client client = new Client();
        client.run();
    }

    public void run(){

        SocketThread socketThread = getSocketThread();

        socketThread.setDaemon(true);

        socketThread.start();

        synchronized (this){
            try {
                this.wait();
            } catch (InterruptedException e) {
                ConsoleHelper.writeMessage("Во время ожидания ответа возникло исключение. Программаа будет закрыта.");
                return;
            }
            if(clientConnected == true){
                ConsoleHelper.writeMessage("Соединение установлено. Для выхода наберите команду 'exit'.");

                    while (true) {
                        String mes = ConsoleHelper.readString();
                        if (mes.equals("exit")) {
                            break;
                        }else {
                            boolean shouldR = shouldSentTextFromConsole();
                            if(shouldR == true){
                                sendTextMessage(mes);
                            }
                        }
                    }

            }else {
                ConsoleHelper.writeMessage("Произошла ошибка во время работы клиента.");
            }
        }
    }

    protected String getServerAddress(){

        String serverAddress;

        ConsoleHelper.writeMessage("Введите адрес сервера:");
        serverAddress = ConsoleHelper.readString();

        return serverAddress;

    }

    protected int getServerPort(){

        int port;

        try {

            ConsoleHelper.writeMessage("Введите порт:");
            port = ConsoleHelper.readInt();

        }catch (Exception e){
            ConsoleHelper.writeMessage("Неверное значение! Введите порт еще раз:");
            port = ConsoleHelper.readInt();
        }

        return port;
    }

    protected String getUserName(){

        String userName;

        ConsoleHelper.writeMessage("Введите Ваше имя:");
        userName = ConsoleHelper.readString();

        return userName;
    }

    protected boolean shouldSentTextFromConsole(){

        return true;
    }

    protected SocketThread getSocketThread(){

        return new SocketThread();
    }

    protected void sendTextMessage(String text){

        Message newTextMes;
        try {
            newTextMes = new Message(MessageType.TEXT, text);
            connection.send(newTextMes);

        }catch (IOException e){
            ConsoleHelper.writeMessage("Во время отправки сообщения произошла ошибка!");
            clientConnected = false;
        }
    }


    public class SocketThread extends Thread {

        public void run(){

            try {
                // Создай новый объект класса java.net.Socket c запросом сервера и порта
                Socket socket = new Socket(getServerAddress(), getServerPort());

                // Создай объект класса Connection, используя сокет
                Client.this.connection = new Connection(socket);


                clientHandshake();
                clientMainLoop();


            } catch (IOException e) {
                notifyConnectionStatusChanged(false);
            } catch (ClassNotFoundException e) {
                notifyConnectionStatusChanged(false);
            }
        }


        protected void clientMainLoop() throws IOException, ClassNotFoundException {

            while (true) {

                // В цикле получать сообщения, используя соединение connection
                Message message = connection.receive();

                switch (message.getType()) {

                    // Если это текстовое сообщение (тип TEXT), обработай его с помощью метода processIncomingMessage()
                    case TEXT:
                        processIncomingMessage(message.getData());
                        break;

                    // Если это сообщение с типом USER_ADDED, обработай его с помощью метода informAboutAddingNewUser()
                    case USER_ADDED:
                        informAboutAddingNewUser(message.getData());
                        break;

                    // Если это сообщение с типом USER_REMOVED, обработай его с помощью метода informAboutDeletingNewUser()
                    case USER_REMOVED:
                        informAboutDeletingNewUser(message.getData());
                        break;

                    default:
                        throw new IOException("Unexpected MessageType");
                }
            }
        }


        protected void clientHandshake() throws IOException, ClassNotFoundException {

            while (true) {

                // В цикле получать сообщения, используя соединение connection
                Message message = connection.receive();

                switch (message.getType()) {

                    // 	Если тип полученного сообщения NAME_REQUEST (сервер запросил имя)
                    case NAME_REQUEST: {

                        // запросить ввод имени пользователя с помощью метода getUserName()
                        // создать новое сообщение с типом USER_NAME и введенным именем, отправить сообщение серверу.
                        String userName = getUserName();
                        connection.send(new Message(MessageType.USER_NAME, userName));
                        break;
                    }

                    // Если тип полученного сообщения NAME_ACCEPTED (сервер принял имя)
                    case NAME_ACCEPTED: {

                        // значит сервер принял имя клиента, нужно об этом сообщить главному потоку, он этого очень ждет.
                        // Сделай это с помощью метода notifyConnectionStatusChanged(), передав в него true. После этого выйди из метода.
                        notifyConnectionStatusChanged(true);
                        return;
                    }

                    default: {
                        throw new IOException("Unexpected MessageType");
                    }
                }
            }
        }


        protected void processIncomingMessage(String message){

            ConsoleHelper.writeMessage(message);
        }

        protected void informAboutAddingNewUser(String userName){

            ConsoleHelper.writeMessage("Участник с именем " + userName + " присоединился к чату");
        }

        protected void informAboutDeletingNewUser(String userName){

            ConsoleHelper.writeMessage("Участник с именем " + userName + " покинул чат");
        }

        protected void notifyConnectionStatusChanged(boolean clientConnected){

            Client.this.clientConnected = clientConnected;
            synchronized (Client.this) {
                Client.this.notify();
            }
        }



    }
}



package com.javarush.test.level30.lesson15.big01;

import java.io.Closeable;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.net.SocketAddress;

/**
 * Created by Кира on 16.11.2016.
 */
public class Connection implements Closeable {


    private final Socket socket;

    private final ObjectOutputStream out;
    private final ObjectInputStream in;

    public Connection(Socket socket) throws IOException {
        this.socket = socket;
        this.out = new ObjectOutputStream(socket.getOutputStream());
        this.in = new ObjectInputStream(socket.getInputStream());

    }

    public void send(Message message) throws IOException{

        synchronized (out) {
            out.writeObject(message);
        }
    }

    public Message receive() throws IOException, ClassNotFoundException{

        Message mes;

        synchronized (in) {
            mes = (Message) in.readObject();

            return mes;
        }
    }

    public SocketAddress getRemoteSocketAddress(){

        return socket.getRemoteSocketAddress();
    }

    public void close() throws IOException{

        out.close();
        in.close();
        socket.close();

    }

}


package com.javarush.test.level30.lesson15.big01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * Created by Кира on 16.11.2016.
 */
public class ConsoleHelper {


    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

    public static int readInt(){

        int n = 0;

        do {
            try {
                n = Integer.parseInt(readString());
            } catch (NumberFormatException e) {
                writeMessage("Произошла ошибка при попытке ввода текста. Попробуйте еще раз.");
                n = Integer.parseInt(readString());
            }
            return n;

        }while (true);
    }

    public static String readString(){

        String s = null;

        do {
            try {
                s = reader.readLine();
            } catch (IOException e) {
                writeMessage("Произошла ошибка при попытке ввода текста. Попробуйте еще раз.");
                continue;
            }
            return s;

        }while (true);

    }

    public static void writeMessage(String message){

        System.out.println(message);
    }


}


package com.javarush.test.level30.lesson15.big01;

import java.io.Serializable;

/**
 * Created by Кира on 16.11.2016.
 */
public class Message implements Serializable {

    private final MessageType type;
    private final String data;


    //Constructors
    public Message(MessageType type, String data) {
        this.type = type;
        this.data = data;
    }

    public Message(MessageType type) {
        this.type = type;
        this.data = null;
    }


    //getters

    public MessageType getType() {
        return type;
    }

    public String getData() {
        return data;
    }
}


package com.javarush.test.level30.lesson15.big01;

/**
 * Created by Кира on 16.11.2016.
 */
public enum  MessageType {

    NAME_REQUEST,
    USER_NAME,
    NAME_ACCEPTED,
    TEXT,
    USER_ADDED,
    USER_REMOVED;
}


package com.javarush.test.level30.lesson15.big01.client;

/**
 * Created by Кира on 17.11.2016.
 */
public class ClientGuiController extends Client {

    private ClientGuiModel model = new ClientGuiModel();
    private ClientGuiView view = new ClientGuiView(this);

    public static void main(String[] args) {
        ClientGuiController clientGuiController = new ClientGuiController();
        clientGuiController.run();
    }

    @Override
    public void run() {
        getSocketThread().run();
        //Разберись, почему нет необходимости вызывать
        //метод run в отдельном потоке, как мы это делали для консольного клиента.
    }


    @Override
    protected SocketThread getSocketThread() {
        return new GuiSocketThread();
    }

    @Override
    protected String getServerAddress() {
        return view.getServerAddress();
    }

    @Override
    protected int getServerPort() {
        return view.getServerPort();
    }

    @Override
    protected String getUserName() {
        return view.getUserName();
    }

    public ClientGuiModel getModel(){

        return model;
    }



    public class GuiSocketThread extends SocketThread {

        @Override
        protected void informAboutAddingNewUser(String userName) {
            model.addUser(userName);

            view.refreshUsers();
        }

        @Override
        protected void informAboutDeletingNewUser(String userName) {
            model.deleteUser(userName);

            view.refreshUsers();
        }

        @Override
        protected void processIncomingMessage(String message) {
            model.setNewMessage(message);

            view.refreshMessages();
        }

        @Override
        protected void notifyConnectionStatusChanged(boolean clientConnected) {
            view.notifyConnectionStatusChanged(clientConnected);
            super.notifyConnectionStatusChanged(clientConnected);
        }
    }
}



package com.javarush.test.level30.lesson15.big01.client;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Created by Кира on 17.11.2016.
 */
public class ClientGuiModel {


    private final Set<String> allUserNames = new HashSet<String>();

    private String newMessage;

    public void addUser(String newUserName){

        allUserNames.add(newUserName);
    }

    public void deleteUser(String userName){

        allUserNames.remove(userName);
    }

    public Set<String> getAllUserNames() {

        return Collections.unmodifiableSet(allUserNames);
    }

    public String getNewMessage() {
        return newMessage;
    }

    public void setNewMessage(String newMessage) {
        this.newMessage = newMessage;
    }
}



package com.javarush.test.level30.lesson15.big01.client;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ClientGuiView {
    private final ClientGuiController controller;

    private JFrame frame = new JFrame("Чат");
    private JTextField textField = new JTextField(50);
    private JTextArea messages = new JTextArea(10, 50);
    private JTextArea users = new JTextArea(10, 10);

    public ClientGuiView(ClientGuiController controller) {
        this.controller = controller;
        initView();
    }

    private void initView() {
        textField.setEditable(false);
        messages.setEditable(false);
        users.setEditable(false);

        frame.getContentPane().add(textField, BorderLayout.NORTH);
        frame.getContentPane().add(new JScrollPane(messages), BorderLayout.WEST);
        frame.getContentPane().add(new JScrollPane(users), BorderLayout.EAST);
        frame.pack();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        textField.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                controller.sendTextMessage(textField.getText());
                textField.setText("");
            }
        });
    }

    public String getServerAddress() {
        return JOptionPane.showInputDialog(
                frame,
                "Введите адрес сервера:",
                "Конфигурация клиента",
                JOptionPane.QUESTION_MESSAGE);
    }

    public int getServerPort() {
        while (true) {
            String port = JOptionPane.showInputDialog(
                    frame,
                    "Введите порт сервера:",
                    "Конфигурация клиента",
                    JOptionPane.QUESTION_MESSAGE);
            try {
                return Integer.parseInt(port.trim());
            } catch (Exception e) {
                JOptionPane.showMessageDialog(
                        frame,
                        "Был введен некорректный порт сервера. Попробуйте еще раз.",
                        "Конфигурация клиента",
                        JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    public String getUserName() {
        return JOptionPane.showInputDialog(
                frame,
                "Введите ваше имя:",
                "Конфигурация клиента",
                JOptionPane.QUESTION_MESSAGE);
    }

    public void notifyConnectionStatusChanged(boolean clientConnected) {
        textField.setEditable(clientConnected);
        if (clientConnected) {
            JOptionPane.showMessageDialog(
                    frame,
                    "Соединение с сервером установлено",
                    "Чат",
                    JOptionPane.INFORMATION_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(
                    frame,
                    "Клиент не подключен к серверу",
                    "Чат",
                    JOptionPane.ERROR_MESSAGE);
        }

    }

    public void refreshMessages() {
        messages.append(controller.getModel().getNewMessage() + "\n");
    }

    public void refreshUsers() {
        ClientGuiModel model = controller.getModel();
        StringBuilder sb = new StringBuilder();
        for (String userName : model.getAllUserNames()) {
            sb.append(userName).append("\n");
        }
        users.setText(sb.toString());
    }
}


package com.javarush.test.level30.lesson15.big01.client;

import com.javarush.test.level30.lesson15.big01.ConsoleHelper;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

/**
 * Created by Кира on 17.11.2016.
 */
public class BotClient extends Client {

    private static int botsCounter = 0;

    public static void main(String[] args) {
        BotClient botClient = new BotClient();
        botClient.run();
    }


    @Override
    protected SocketThread getSocketThread() {
        return new BotSocketThread();
    }

    @Override
    protected String getUserName() {

        if (botsCounter == 99) {
            botsCounter = 0;
        }

        return "date_bot_" + botsCounter++;
    }

    @Override
    protected boolean shouldSentTextFromConsole() {
        return false;
    }


    public class BotSocketThread extends SocketThread{

        @Override
        protected void clientMainLoop() throws IOException, ClassNotFoundException {
            sendTextMessage("Привет чатику. Я бот. Понимаю команды: дата, день, месяц, год, время, час, минуты, секунды.");
            super.clientMainLoop();

        }

        @Override
        protected void processIncomingMessage(String message) {
            // Вывести в консоль текст полученного сообщения message
            ConsoleHelper.writeMessage(message);

            // Получить из message имя отправителя и текст сообщения. Они разделены ": "
            String senderName = "";
            String senderMessageText;

            if (message.contains(": ")) {
                senderName = message.substring(0, message.indexOf(": "));
                senderMessageText = message.substring(message.indexOf(": ") + 2);
            }
            else {
                senderMessageText = message;
            }


            SimpleDateFormat format = null;
            // Отправить ответ в зависимости от текста принятого сообщения. Если текст сообщения:
            if ("дата".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("d.MM.YYYY");
            }
            else if ("день".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("d");
            }
            else if ("месяц".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("MMMM");
            }
            else if ("год".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("YYYY");
            }
            else if ("время".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("H:mm:ss");
            }
            else if ("час".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("H");
            }
            else if ("минуты".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("m");
            }
            else if ("секунды".equalsIgnoreCase(senderMessageText)) {
                format = new SimpleDateFormat("s");
            }

            if (format != null)
            {
                sendTextMessage("Информация для " + senderName + ": " + format.format(Calendar.getInstance().getTime()));
            }
        }
    }

}













	




А какие еще методы есть у класса File?

- Вот, смотри:

Метод	Описание
boolean isDirectory()	Является ли «объект файла» директорией
boolean isFile()	Является ли объект файлом
long length()	Возвращает размер/длину файла в байтах.
boolean createNewFile()	Создает файл. Если такой файл уже был, возвращает false.
boolean mkdir()	Создает директорию. Название mkdir происходит от "make directory".
boolean mkdirs()	Создает директорию и все поддиректории.
boolean delete()	Удаляет файл объекта на диске. Если объект – директория, то только, если в ней нет файлов.
void deleteOnExit()	Добавляет файл в специальный список файлов, которые будут автоматически удалены при закрытии программы.
File createTempFile(
 String prefix,
 String suffix,
 File directory)	Создает «временный файл» - файл с случайно сгенерированным уникальным именем – что-типа «dasd4d53sd».
Дополнительные параметры – префикс к имени, суффикс (окончание). Если директория не указана, то файл создается в специальной директории ОС для временных файлов
boolean exists()	Возвращает true, если файл с таким именем существует на диске компьютера.
String getAbsolutePath()	Возвращает полный путь файла со всеми поддиректориями.
String getCanonicalPath()	Возвращает канонический путь файла.
Например, преобразовывает путь «c:/dir/dir2/../a.txt» к пути «c:/dir/a.txt»
String[] list()	Возвращает массив имен файлов, которые содержатся в директории, которой является текущий объект-файл.
File[] listFiles()	Возвращает массив файлов, которые содержатся в директории, которой является текущий объект-файл.
long getTotalSpace()	Возвращает размер диска (количество байт) на котором расположен файл.
long getFreeSpace()	Возвращает количество свободного места (количество байт) на диске, на котором расположен файл.
boolean renameTo(File)	Переименовывает файл – содержимое файла фактически получает новое имя. Т.е. можно переименовать файл «c:/dir/a.txt» в «d:/out/text/b.doc».
String getName()	Возвращает только имя файла, без пути.
String getParent()	Возвращает только путь (директорию) к текущему файлу, без самого имени.
Path toPath()	Возвращает объект Path, который соответствует текущему объекту File.















package com.javarush.test.level31.lesson02.home01;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/* Проход по дереву файлов
1. На вход метода main подаются два параметра.
Первый - path - путь к директории, второй - resultFileAbsolutePath - имя файла, который будет содержать результат.
2. Для каждого файла в директории path и в ее всех вложенных поддиректориях выполнить следующее:
2.1. Если у файла длина в байтах больше 50, то удалить его.
2.2. Если у файла длина в байтах НЕ больше 50, то для всех таких файлов:
2.2.1. отсортировать их по имени файла в возрастающем порядке, путь не учитывать при сортировке
2.2.2. переименовать resultFileAbsolutePath в 'allFilesContent.txt'
2.2.3. в allFilesContent.txt последовательно записать содержимое всех файлов из п. 2.2.1. Тела файлов разделять "\n"
2.3. Удалить директории без файлов (пустые).
Все файлы имеют расширение txt.
*/
public class Solution {
    public static void main(String[] args) throws IOException {

        String directoryPath = args[0];
        String resultFileAbsolutePath = args[1];
        //String directoryPath = "src/main/resources/level31/lesson02/home01";
        //String resultFileAbsolutePath = "src/main/resources/level31/lesson02/home01/res.txt";
        String allFilesContent = "allFilesContent.txt";

        saveFilesLessThan50Bytes(directoryPath);

        // rename file
        Path source = Paths.get(resultFileAbsolutePath);
        Path newResPath = Files.move(source, source.resolveSibling(allFilesContent));

        // delete resultFileAbsolutePath if list contains it
        lessThan50BytesFiles.remove(new File(resultFileAbsolutePath));

        // sort file by name
        Collections.sort(lessThan50BytesFiles, new Comparator<File>() {
            @Override
            public int compare(File o1, File o2) {
                String fileName1 = o1.getName();
                String fileName2 = o2.getName();
                return fileName1.compareTo(fileName2);
            }
        });

        // write to result file
        BufferedWriter fout = new BufferedWriter(new FileWriter(newResPath.toFile()));
        for (File file : lessThan50BytesFiles) {
            BufferedReader fin = new BufferedReader(new FileReader(file));
            while (fin.ready()) {
                fout.write(fin.readLine());
                fout.newLine();
            }
            fin.close();
        }
        fout.close();
    }

    private static List<File> lessThan50BytesFiles = new ArrayList<>();

    private static void saveFilesLessThan50Bytes(String directory) {
        File dir = new File(directory);
        File[] files = dir.listFiles();

        if (files == null) {
            // it is not directory
            return;
        } else if (files.length == 0) {
            // directory is empty
            dir.delete();
        } else {
            for (File file : files) {
                if (file.isDirectory()) {
                    // nested directory
                    saveFilesLessThan50Bytes(file.getAbsolutePath());
                } else {
                    if (file.length() > 50) {
                        file.delete();
                    } else {
                        lessThan50BytesFiles.add(file);
                    }
                }
            }
        }
    }
}












Взяли за основу класс File, добавили в него немного нового, переименовывали методы, а в конце еще и разделили на два.
 Так что теперь есть два новых класса – Path и Files. Path – это, фактически новый аналог класса File, 
 а Files – это утилитный класс (по аналогии с классами Arrays & Collections), в него вынести все статические методы класса File.
 Так «правильнее» с точки зрения ООП.

- Ну, раз с точки зрения ООП, то – ок. А что поменялось-то?

- Во-первых, отказались от дублирования методов, которые возвращали String и File. В классе Path все методы возвращают Path.

Во-вторых, убрали многие статические утилитные методы в класс Files.

В третьих, удобнее стало работать с относительными путями.

Вот список методов:

Методы класса Path	Описание
boolean isAbsolute()	Возвращает true, если путь – абсолютный.
Path getRoot()	Возвращает корень текущего пути – директорию самого верхнего уровня.
Path getFileName()	Возвращает имя файла из текущего пути.
Path getParent()	Возвращает директорию из текущего пути.
boolean startsWith(Path other)	Проверяет, что текущий путь начинается с переданного пути.
boolean endsWith(Path other)	Проверяет, что текущий путь заканчивается на переданный путь.
Path normalize()	Нормализует текущий путь. Например, приводит путь «c:/dir/dir2/../a.txt» к пути «c:/dir/a.txt»
Path relativize(Path other)	Вычисляет относительный путь двух путей – «разницу путей»
Path resolve(String other)	Восстанавливает абсолютный путь по текущему и относительному.
URI toUri()	Возвращает URI текущего пути/файла.
Path toAbsolutePath()	Приводит путь к абсолютному, если был относительный.
File toFile()	Возвращает объект File, который соответствует текущему объекту Path.
- А текущий путь – это что?

- Это тот путь, который был передан в конструктор объекта Path, методы которого вызываются. Path – это «путь» по-английски.

- Ок. А какие методы есть у класса Files?

- Ну и куда же ты так спешишь-то? Сейчас все расскажу. Вот основные методы:

Методы класса Files	Описание
Path createFile(…)	Создает файл на диске.
Path createDirectory(…)	Создает директорию.
Path createDirectories(…)	Создает директорию и поддиректории.
Path createTempFile(…)	Создает «временный файл»
Path createTempDirectory(…)	Создает «временную директорию»
void delete(Path path)	Удаляет файл/директорию.
Path copy(Path source, Path target,…)	Копирует файл.
Path move(Path source, Path target,…)	Перемещает файл.
boolean isSameFile(Path, Path)	Сравнивает два файла.
boolean isDirectory(Path)	Путь - это директория?
boolean isRegularFile(Path)	Путь – это файл?
long size(Path)	Возвращает размер файла.
boolean exists(Path)	Объект с таким именем существует?
boolean notExists(Path)	Объект с таким именем не существует?
long copy(InputStream, OutputStream)	Копирует байты из InputStream в OutputStream.
long copy(Path, OutputStream)	Копирует все байты из Path в OutputStream.
long copy(InputStream, Path)	Копирует все байты из InputStream в Path.
byte[] read(InputStream, int initialSize)	Читает массив байт из InputStream.
byte[] readAllBytes(Path path)	Читает все байты из InputStream.
List<String> readAllLines(Path path,..)	Читает текстовый файл, возвращает список строк.
Path write(Path path, byte[] bytes,…)	Пишет массив байт в файл.
- Как интересно, столько крутых функций, и все в одном месте.

А зачем нужны временные файлы?

- Ну, смотри. Допустим, ты хочешь скачать файл из интернета, а потом отправить его кому-то. 
Для этого очень удобно создать временный файл на диске и сохранять считанные данные в него.

- А сложно скачать файл из интернета?

- Очень просто. Смотри пример:

 	Код
1
2
3
4
5
6
7	URL url = new URL("https://www.google.com.ua/images/srpr/logo11w.png");
InputStream inputStream = url.openStream();

Path tempFile = Files.createTempFile("temp-",".tmp");
Files.copy(inputStream, tempFile);













package com.javarush.test.level31.lesson02.home02;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/* Находим все файлы
Реализовать логику метода getFileTree, который должен в директории root найти список всех файлов включая вложенные.
Используйте очередь, рекурсию не используйте.
Верните список всех путей к найденным файлам, путь к директориям возвращать не надо.
Путь должен быть абсолютный.
*/
public class Solution {

    public static void main(String[] args) throws IOException {

        String r = "D:\\javatest";

        getFileTree(r);

    }


    public static List<String> getFileTree(String root) throws IOException {

        File dir = new File(root);

        List<String> fileNames = new ArrayList<>();

        Stack<File> stack = new Stack<File>();
        stack.push(dir);
        while(!stack.isEmpty()) {
            File child = stack.pop();
            if (child.isDirectory()) {
                for(File f : child.listFiles()) stack.push(f);
            } else if (child.isFile()) {
                fileNames.add(child.getAbsolutePath());
            }
        }

        for(String f: fileNames){
            System.out.println(f);
        }

        return fileNames;

    }
}















package com.javarush.test.level31.lesson04.home01;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

/* Своя реализация
Реализуйте логику методов:
1. readBytes - должен возвращать все байты файла fileName
2. readLines - должен возвращать все строки файла fileName. Используйте дефолтовую кодировку
3. writeBytes - должен записывать массив bytes в файл fileName
4. copy - должен копировать файл resourceFileName на место destinationFileName

ГЛАВНОЕ УСЛОВИЕ:
Никаких других импортов!
*/
public class Solution {

    public static byte[] readBytes(String fileName) throws IOException {
        return Files.readAllBytes(Paths.get(fileName));
    }
    public static List<String> readLines(String fileName) throws IOException {
        return Files.readAllLines(Paths.get(fileName), Charset.defaultCharset());
    }
    public static void writeBytes(String fileName, byte[] bytes) throws IOException {
        Files.write(Paths.get(fileName), bytes);
    }
    public static void copy(String resourceFileName, String destinationFileName) throws IOException {
        Files.copy(Paths.get(resourceFileName), Paths.get(destinationFileName));
    }
}












package com.javarush.test.level31.lesson04.home02;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;

/* Поиск скрытых файлов
В классе Solution переопределите логику двух методов:
-visitFile кроме своей логики должен добавлять в archived все пути к zip и rar файлам
-visitFileFailed должен добавлять в failed все пути к недоступным файлам и возвращать SKIP_SUBTREE
Пример вывода:
D:/mydir/BCD.zip
Метод main не участвует в тестировании
*/
public class Solution extends SimpleFileVisitor<Path> {
    public static void main(String[] args) throws IOException {
        EnumSet<FileVisitOption> options = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
        final Solution solution = new Solution();
        Files.walkFileTree(Paths.get("D:/"), options, 20, solution);

        List<String> result = solution.getArchived();
        System.out.println("All archived files:");
        for (String path : result) {
            System.out.println("\t" + path);
        }

        List<String> failed = solution.getFailed();
        System.out.println("All failed files:");
        for (String path : failed) {
            System.out.println("\t" + path);
        }
    }

    private List<String> archived = new ArrayList<>();
    private List<String> failed = new ArrayList<>();


    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {

        failed.add(file.toString());

        return FileVisitResult.SKIP_SUBTREE;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        if(file.toString().endsWith(".zip") || file.toString().endsWith(".rar")){
            archived.add(file.toString());
        }

        return super.visitFile(file, attrs);
    }

    public List<String> getArchived() {
        return archived;
    }

    public List<String> getFailed() {
        return failed;
    }
}












-----------------------------------------------------------------ZIP, ZipEntry:

пример, где мы создаем архив и кладем в него файл:

Код
// создаем архив
FileOutputStream zipFile = new FileOutputStream("c:/archive.zip");
ZipOutputStream zip = new ZipOutputStream(zipFile); 

//кладем в него ZipEntry – «архивный объект»
zip.putNextEntry(new ZipEntry("document.txt")); 

//копируем файл «document-for-archive.txt» в архив под именем «document.txt»
File file = new File("c:/document-for-archive.txt");
Files.copy(file.toPath(), zip);

// закрываем архив
zip.close();
- Как интересно. А разархивировать файлы так же легко?

- Ага. Вот тебе краткое описание методов классов ZipEntry, ZipInputStream и ZipOutputStream

ZipInputStream – это поток, поэтому все ZipEntry могут быть прочитаны только последовательно. Вот его методы:

Метод	Описание
ZipEntry getNextEntry()	Возвращает объект, описывающий следующий ZipEntry (пропускает все байты текущего entry).
void closeEntry()	Закрывает чтение текущего ZipEntry (пропускает все байты текущего entry).
int available()	Возвращает 1, если есть доступные ZipEntry, иначе 0.
int read(byte[] b, int off, int len)	Читает байты из текущего ZipEntry.
long skip(long n)	Пропускает n байт при чтении из потока.
void close()	Закрывает поток.
- Не очень понятно.

- Лучше всего - это представить, что ты читаешь текстовый файл, а ZipEntry – это строки в нем. Можно читать как данные текущей строки – текущий ZipEntry, так и прыгать по строкам – getNextEntry, closeEntry.

- Вроде понятно, хотя не уверен, что правильно.

- ZipOutputStrem и его методы:

Метод	Описание
void setComment(String comment)	Устанавливает комментарий к архиву.
void setMethod(int method)	Указывает метод (тип) сжатия.
void setLevel(int level)	Указывает степень сжатия. Чем сильнее, тем медленнее.
void putNextEntry(ZipEntry e)	Добавляет новый ZipEntry.
void closeEntry()	Закрывает текущий ZipEntry.
void write(byte[] b, int off, int len)	Пишет набор байт в текущий ZipEntry.
void close()	Закрывает поток.
- А мы же в примере выше почти ничего этого не использовали.

- Это необязательные методы. Можно не указывать степень и метод сжатия, тогда будут использованы настройки по умолчанию.

- Гм. Тоже не плохо. А ZipEntry?

- Ага. В ZipEntry дополнительно хранится только служебная информация:

Метод	Описание
String getName(), setName(String)	Внутреннее имя файла.
long getTime(), setTime(long)	Время последней модификации entry.
long getCRC(), setCRC(long)	Контрольная сумма.
long getSize(), setSize(long)	Размер до компрессии.
int getMethod(), setMethod(int)	Метод сжатия.
long get/setCompressedSize()	Размер после архивации.
boolean isDirectory()	Является ли entry директорией.











package com.javarush.test.level31.lesson08.home01;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/* Null Object Pattern
Почитайте на вики про паттерн "Null Object"
Используйте Files, чтобы в конструкторе класса Solution правильно инициализировать поле fileData объектом ConcreteFileData.
Если возникли какие-то проблемы со чтением файла по пути pathToFile, то инициализируйте поле объектом NullFileData.
*/
public class Solution {
    private FileData fileData;

    public Solution(String pathToFile) {

        try {
            Path path = Paths.get(pathToFile);

            fileData = new ConcreteFileData(Files.isHidden(path), Files.isExecutable(path), Files.isDirectory(path), Files.isWritable(path));
        }
        catch (Exception e) {
            fileData = new NullFileData(e);
        }
    }

    public FileData getFileData() {
        return fileData;
    }
}


package com.javarush.test.level31.lesson08.home01;

public class ConcreteFileData implements FileData {

    private boolean hidden;
    private boolean executable;
    private boolean directory;
    private boolean writable;

    public ConcreteFileData(boolean hidden, boolean executable, boolean directory, boolean writable) {
        this.hidden = hidden;
        this.executable = executable;
        this.directory = directory;
        this.writable = writable;
    }

    @Override
    public boolean isHidden() {
        return hidden;
    }

    @Override
    public boolean isExecutable() {
        return executable;
    }

    @Override
    public boolean isDirectory() {
        return directory;
    }

    @Override
    public boolean isWritable() {
        return writable;
    }
}


package com.javarush.test.level31.lesson08.home01;

public class NullFileData implements FileData {
    private Exception exception;

    public NullFileData(Exception e) {
        this.exception = e;
    }

    public Exception getException() {
        return exception;
    }

    @Override
    public boolean isHidden() {
        return false;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public boolean isExecutable() {
        return false;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public boolean isDirectory() {
        return false;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public boolean isWritable() {
        return false;  //To change body of implemented methods use File | Settings | File Templates.
    }
}



package com.javarush.test.level31.lesson08.home01;

public interface FileData {
    boolean isHidden();

    boolean isExecutable();

    boolean isDirectory();

    boolean isWritable();
}






















package com.javarush.test.level31.lesson06.home01;

import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

/* Добавление файла в архив
В метод main приходит список аргументов.
Первый аргумент - полный путь к файлу fileName.
Второй аргумент - путь к zip-архиву.
Добавить файл (fileName) внутрь архива в директорию 'new'.
Если в архиве есть файл с таким именем, то заменить его.

Пример входных данных:
C:/result.mp3
C:/pathToTest/test.zip

Файлы внутри test.zip:
a.txt
b.txt

После запуска Solution.main архив test.zip должен иметь такое содержимое:
new/result.mp3
a.txt
b.txt

Подсказка: нужно сначала куда-то сохранить содержимое всех энтри,
а потом записать в архив все энтри вместе с добавленным файлом.
Пользоваться файловой системой нельзя.
*/
public class Solution {
    public static void main(String[] args) throws IOException {

        String fileName = args[0];
        String zipName = args[1];

        Map<String, byte[]> tempZipEntries = new HashMap<>();
        byte[] buffer = new byte[2048];
        ByteArrayOutputStream baos;
        int len = 0;

        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipName));
		ZipEntry zipEntry;
        while ((zipEntry = zis.getNextEntry()) != null)
        {
            String entryName = zipEntry.getName();
            baos = new ByteArrayOutputStream();
            while ((len = zis.read(buffer)) > 0)
            {
                baos.write(buffer, 0, len);
            }
            tempZipEntries.put(entryName, baos.toByteArray());
        }
        
        zis.close();

        FileInputStream fis = new FileInputStream(fileName);
        baos = new ByteArrayOutputStream();
        while ((len = fis.read(buffer)) > 0)
        {
            baos.write(buffer, 0, len);
        }
        String shortFileName = fileName.substring(fileName.lastIndexOf("/") + 1, fileName.length());
        String args0FileName = "new/" + shortFileName;
        if (tempZipEntries.containsKey(shortFileName))
        {
            tempZipEntries.remove(shortFileName);
            tempZipEntries.put(args0FileName, baos.toByteArray());
        }

        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipName));
        for (Map.Entry<String, byte[]> entry : tempZipEntries.entrySet())
        {
            zos.putNextEntry(new ZipEntry(entry.getKey()));
            zos.write(entry.getValue());
            zos.closeEntry();
        }
        zos.close();
    }
}











package com.javarush.test.level31.lesson08.home02;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

/* Исследуем Path
Почитайте про все методы класса Path.
Найдите такой, который создает относительный путь между текущим и переданным путем.
Реализуйте логику метода getDiffBetweenTwoPaths, он должен возвращать относительный путь.
Метод main не участвует в тестировании.
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        Path path1 = Paths.get("D:/javatest/data/firstDir");
        Path path2 = Paths.get("D:/javatest/data/secondDir/third");
        Path resultPath = getDiffBetweenTwoPaths(path1, path2);
        System.out.println(resultPath);   //expected output '../secondDir/third' or '..\secondDir\third'
    }

    public static Path getDiffBetweenTwoPaths(Path path1, Path path2) {

        return path1.relativize(path2);
    }


}










PROPERTIES MEATHODS

void load(Reader reader)	Загружает свойства из файла, представленного объектом Reader
void load(InputStream inStream)	Загружает свойства из файла, представленного объектом InputStream
void loadFromXML(InputStream in)	Загружает свойства из XML-файла
Object get(Object key)	Возвращает значение по ключу. Метод унаследован от HashTable
String getProperty(String key)	Возвращает значение свойства (строку) по ключу.
String getProperty(String key, String defaultValue)	Возвращает значение свойства по ключу или defaultValue, если такого ключа нет.
Set<String> stringPropertyNames()	Возвращает список всех ключей











При возникновении ошибок должен возвращаться пустой объект.
Метод main не участвует в тестировании.
Подсказка: возможно, Вам понадобится File.separator.
*/
public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        Properties properties = solution.getProperties("E:\\JavaRush\\JavaRushHomeWork\\src\\com\\javarush\\test\\level31\\lesson10\\home01\\properties.xml");
        properties.list(System.out);

        properties = solution.getProperties("E:\\JavaRush\\JavaRushHomeWork\\src\\com\\javarush\\test\\level31\\lesson10\\home01\\properties.txt");
        properties.list(System.out);

        properties = solution.getProperties("E:\\JavaRush\\JavaRushHomeWork\\src\\com\\javarush\\test\\level31\\lesson10\\home01\\nonExists");
        properties.list(System.out);
    }

    public Properties getProperties(String fileName) {

        File file = new File(fileName);
        Properties properties = null;
        try {

            properties = new Properties();
            properties.load(new FileReader(file + File.separator));

        }catch(Exception e){
            return new Properties();
        }

        return properties;
    }
}










package com.javarush.test.level31.lesson10.home01;

import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.InvalidPropertiesFormatException;
import java.util.Properties;

/* Читаем конфиги
Реализовать метод getProperties, который должен считывать свойства из переданного файла fileName.
fileName может иметь любое расширение - как xml, так и любое другое, или вообще не иметь.
Нужно обеспечить корректное чтение свойств.
При возникновении ошибок должен возвращаться пустой объект.
Метод main не участвует в тестировании.
Подсказка: возможно, Вам понадобится File.separator.
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        Solution solution = new Solution();
        Properties properties = solution.getProperties("E:\\JavaRush\\JavaRushHomeWork\\src\\com\\javarush\\test\\level31\\lesson10\\home01\\properties.xml");
        properties.list(System.out);

        properties = solution.getProperties("E:\\JavaRush\\JavaRushHomeWork\\src\\com\\javarush\\test\\level31\\lesson10\\home01\\properties.txt");
        properties.list(System.out);

        properties = solution.getProperties("E:\\JavaRush\\JavaRushHomeWork\\src\\com\\javarush\\test\\level31\\lesson10\\home01\\nonExists");
        properties.list(System.out);
    }

    public Properties getProperties(String fileName) throws IOException {

        Properties properties = new Properties();
        try(FileInputStream fis = new FileInputStream(fileName);)
        {

            properties.loadFromXML(fis);
        }
        catch (InvalidPropertiesFormatException e)
        {
            try (FileReader reader = new FileReader(fileName);)
            {
                properties.load(reader);
            } catch (IOException e2) {/*NOP*/}

        } catch (IOException someException) {/*NOP*/}

        return properties;
    }
}










полный список методов класса RandomAccessFile?

- Конечно. Держи:

Метод	Описание
int read()	Читает один байт и возвращает его
int read(byte b[], int off, int len)	Читает массив байт
int read(byte b[])	Читает массив байт
void readFully(byte b[])	Читает массив байт, ждет, пока добавятся новые байты, если их не хватает для заполнения массива
int skipBytes(int n)	Пропускает n байт. Т.е. перемещает курсор на n байт вперед.
void write(int b)	Пишет один байт в то место, где стоит курсор
void write(byte b[])	Пишет массив байт в то место, где стоит курсор
void write(byte b[], int off, int len)	Пишет массив байт в то место, где стоит курсор
long getFilePointer()	Возвращает номер байта, на который указывает «курсор». Может быть от 0 до «длины файла»
void seek(long pos)	Перемещает «курсор», используемый для чтения/записи, в указанное место
long length()	Возвращает длину файла
void setLength(long newLength)	Устанавливает новую длину файла. Если файл был больше – он обрезается, если меньше – расширяется и новое место заполняется нулями
void close()	Закрывает файл
boolean readBoolean()	Читает boolean с текущей позиции курсора в файле
byte readByte()	Читает byte с текущей позиции курсора в файле
char readChar()	Читает char с текущей позиции курсора в файле
int readInt()	Читает int с текущей позиции курсора в файле
long readLong()	Читает long с текущей позиции курсора в файле
float readFloat()	Читает float с текущей позиции курсора в файле
double readDouble()	Читает double с текущей позиции курсора в файле
String readLine()	Читает строку из файла и возвращает ее
void writeBoolean(boolean v)	Пишет boolean в файл (начиная с позиции курсора)
void writeByte(int v) t	Пишет byte в файл (начиная с позиции курсора)
void writeChar(int v)	Пишет char в файл (начиная с позиции курсора)
void writeInt(int v)	Пишет int в файл (начиная с позиции курсора)
void writeLong(long v)	Пишет long в файл (начиная с позиции курсора)
void writeFloat(float v)	Пишет float в файл (начиная с позиции курсора)
void writeDouble(double v)	Пишет double в файл (начиная с позиции курсора)
void writeBytes(String s)	Пишет строку в файл (начиная с позиции курсора)
void writeChars(String s)	Пишет строку в файл (начиная с позиции курсора)











package com.javarush.test.level32.lesson02.task01;

import java.io.IOException;
import java.io.RandomAccessFile;

/* Запись в файл
В метод main приходят три параметра:
1) fileName - путь к файлу
2) number - число, позиция в файле
3) text - текст
Записать text в файл fileName начиная с позиции number.
Если файл слишком короткий, то записать в конец файла.
*/
public class Solution {
    public static void main(String... args) throws IOException {

        String filename = args[0];
        int number = Integer.parseInt(args[1]);
        String text = args[2];

        RandomAccessFile file = new RandomAccessFile(filename, "rw");

        if(file.length() >= number){
            file.seek(number);
            file.writeBytes(text);
        }else {
            file.seek(file.length());
            file.writeBytes(text);
        }

        file.close();
    }
}













package com.javarush.test.level32.lesson04.task01;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.io.StringWriter;

/* Пишем стек-трейс
Реализуйте логику метода getStackTrace, который в виде одной строки должен возвращать весь стек-трейс переданного исключения.
Используйте подходящий метод класса Throwable, который поможет записать стек-трейс в StringWriter.
*/
public class Solution {
    public static void main(String[] args) {
        String text = getStackTrace(new IndexOutOfBoundsException("fff"));
        System.out.println(text);
    }

    public static String getStackTrace(Throwable throwable) {

        StringWriter sw = new StringWriter();

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);
        throwable.printStackTrace(ps);

        sw.write(baos.toString());

        return String.valueOf(sw);
    }
}











package com.javarush.test.level32.lesson06.task01;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.SecureRandom;

/* Генератор паролей
Реализуйте логику метода getPassword, который должен возвращать ByteArrayOutputStream, в котором будут байты пароля.
Требования к паролю:
1) 8 символов
2) только цифры и латинские буквы разного регистра
3) обязательно должны присутствовать цифры, и буквы разного регистра
Все сгенерированные пароли должны быть уникальные.
Пример правильного пароля:
wMh7SmNu
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        ByteArrayOutputStream password = getPassword();
        System.out.println(password.toString());
    }

    public static ByteArrayOutputStream getPassword() throws IOException {

        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        char[] allowedRandomChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
        char[] allowedUpperChars = "abcdefghijklmnopqrstuvwxyz".toCharArray();
        char[] allowedLowerChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
        char[] allowedNums = "1234567890".toCharArray();

        SecureRandom random = new SecureRandom();
        StringBuffer password = new StringBuffer();


        password.append(allowedNums[ random.nextInt(allowedNums.length) ]);
        password.append(allowedLowerChars[ random.nextInt(allowedLowerChars.length) ]);
        password.append(allowedUpperChars[ random.nextInt(allowedUpperChars.length) ]);
        password.append(allowedRandomChars[ random.nextInt(allowedRandomChars.length)]);
        password.append(allowedRandomChars[ random.nextInt(allowedRandomChars.length)]);
        password.append(allowedRandomChars[ random.nextInt(allowedRandomChars.length)]);
        password.append(allowedRandomChars[ random.nextInt(allowedRandomChars.length)]);
        password.append(allowedRandomChars[ random.nextInt(allowedRandomChars.length)]);

        bos.write(String.valueOf(password).getBytes());

        return bos;
    }
}





To generate a random char in a-z:

Random r = new Random();
char c = (char)(r.nextInt(26) + 'a');












package com.javarush.test.level32.lesson08.home01;

import java.lang.reflect.Proxy;

/* Создание прокси-объекта
1) В отдельном файле создать публичный класс CustomInvocationHandler, который будет хэндлером при создании прокси-объекта.
2) CustomInvocationHandler должен иметь один публичный конструктор с одним агументом типа SomeInterfaceWithMethods.
3) Перед вызовом любого метода у оригинального объекта должна выводиться фраза [methodName in].
4) После вызова любого метода у оригинального объекта должна выводиться фраза [methodName out].
5) Реализовать логику метода getProxy, который должен создавать прокси для интерфейса SomeInterfaceWithMethods.
См. пример вывода в методе main. Метод main не участвует в тестировании.
*/
public class Solution {
    public static void main(String[] args) {
        SomeInterfaceWithMethods obj = getProxy();
        obj.stringMethodWithoutArgs();
        obj.voidMethodWithIntArg(1);

        /* expected output
        stringMethodWithoutArgs in
        inside stringMethodWithoutArgs
        stringMethodWithoutArgs out
        voidMethodWithIntArg in
        inside voidMethodWithIntArg
        inside voidMethodWithoutArgs
        voidMethodWithIntArg out
        */
    }

    public static SomeInterfaceWithMethods getProxy() {

        SomeInterfaceWithMethods methods = new SomeInterfaceWithMethodsImpl();
        ClassLoader classLoader = methods.getClass().getClassLoader();
        Class<?>[] interfaces = methods.getClass().getInterfaces();
        CustomInvocationHandler invocationHandler = new CustomInvocationHandler(methods);
        SomeInterfaceWithMethods someInterfaceWithMethods = (SomeInterfaceWithMethods)
                Proxy.newProxyInstance(classLoader,interfaces,invocationHandler);
        return someInterfaceWithMethods;
    }
}

package com.javarush.test.level32.lesson08.home01;

public class SomeInterfaceWithMethodsImpl implements SomeInterfaceWithMethods {


    public void voidMethodWithoutArgs() {
        System.out.println("inside voidMethodWithoutArgs");
    }

    public String stringMethodWithoutArgs() {
        System.out.println("inside stringMethodWithoutArgs");
        return null;
    }

    public void voidMethodWithIntArg(int i) {
        System.out.println("inside voidMethodWithIntArg");
        voidMethodWithoutArgs();
    }
}

package com.javarush.test.level32.lesson08.home01;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

/**
 * Created by Кира on 21.11.2016.
 */
public class CustomInvocationHandler implements InvocationHandler {

    private SomeInterfaceWithMethods someInterfaceWithMethods;

    public CustomInvocationHandler(SomeInterfaceWithMethods someInterfaceWithMethods){

        this.someInterfaceWithMethods = someInterfaceWithMethods;
    }


    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println(method.getName() + " in");

        method.invoke(someInterfaceWithMethods,args);

        System.out.println(method.getName() + " out");

        return null;
    }
}

package com.javarush.test.level32.lesson08.home01;

public interface SomeInterfaceWithMethods {
    void voidMethodWithoutArgs();

    String stringMethodWithoutArgs();

    void voidMethodWithIntArg(int i);
}











package com.javarush.test.level32.lesson08.bonus01;

import java.lang.reflect.Proxy;

/* Дженерики для создания прокси-объекта
В классе Solution создайте публичный метод getProxy
1) Метод getProxy должен возвращать прокси для любого интерфейса, который наследуется от Item
2) getProxy должен иметь два параметра. Первый - класс возвращаемого типа, второй - классы дополнительных интерфейсов.
3) Используйте ItemInvocationHandler для создания прокси
Метод main не участвует в тестировании
*/
public class Solution {

    public static void main(String[] args) {
        Solution solution = new Solution();
        test(solution.getProxy(Item.class));                        //true false false
        test(solution.getProxy(Item.class, Small.class));           //true false true
        test(solution.getProxy(Item.class, Big.class, Small.class));//true true true
        test(solution.getProxy(Big.class, Small.class));            //true true true т.к. Big наследуется от Item
        test(solution.getProxy(Big.class));                         //true true false т.к. Big наследуется от Item
    }

    public <T extends Item> T getProxy(Class <T> someClass, Class<?>... interfaces) {

        Class[] mas = new Class[interfaces.length + 1];
        System.arraycopy(interfaces, 0, mas, 0, interfaces.length);
        mas[mas.length - 1] = someClass;

        return (T) Proxy.newProxyInstance(someClass.getClassLoader(), mas, new ItemInvocationHandler());
    }


    private static void test(Object proxy) {
        boolean isItem = proxy instanceof Item;
        boolean isBig = proxy instanceof Big;
        boolean isSmall = proxy instanceof Small;

        System.out.format("%b %b %b\n", isItem, isBig, isSmall);
    }
}











package com.javarush.test.level33.lesson05.home01;


import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;

/* Первая сериализация в JSON
НЕОБХОДИМО: подключенные библиотеки Jackson Core, Bind и Annotation версии 2.6.1

1) В программе не выполнено основное требование к сериализации в JSON.
Найдите ошибку и исправьте.
2) Расставьте правильно Json аннотации у классов.
Все данные должны сериализоваться.
*/
public class Solution {
    public static void main(String[] args) throws IOException{
        Cat cat = new Cat ();
        cat.name = "Murka";
        cat.age = 5;
        cat.weight = 3;

        Dog dog = new Dog ();
        dog.name = "Killer";
        dog.age = 8;
        dog.owner = "Bill Jeferson";

        ArrayList<Pet> pets = new ArrayList();
        pets.add(cat);
        pets.add(dog);

        StringWriter writer = new StringWriter();
        convertToJSON(writer, pets);
        System.out.println(writer.toString());
        //[{"name":"Murka","age":5,"weight":3},{"name":"Killer","age":8,"owner":"Bill Jeferson"}]
    }

    public static void convertToJSON(StringWriter writer, Object object) throws IOException {
        ObjectMapper mapper = new ObjectMapper();

        mapper.writeValue(writer, object);

    }

    @JsonAutoDetect
    public static class Pet
    {
        public String name;
    }

    @JsonAutoDetect
    public static class Cat extends Pet
    {
        public int age;
        public int weight;
    }

    @JsonAutoDetect
    public static class Dog extends Pet
    {
        public int age;
        public String owner;
    }
}












package com.javarush.test.level33.lesson05.home03;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.io.IOException;

/* Десериализация JSON объекта
НЕОБХОДИМО: подключенные библиотеки Jackson Core, Bind и Annotation версии 2.6.1

В метод convertFromJsonToNormal первым параметром приходит имя файла, который содержит один ДЖЕЙСОН объект.
Вторым параметром приходит имя класса, объект которого находится в файле.
Метод convertFromJsonToNormal должен вычитать объект из файла, преобразовать его из JSON и вернуть его.
*/
public class Solution {

    public static void main(String[] args) throws IOException
    {
        Cat cat = convertFromJsonToNormal("D:/resultFile.txt", Cat.class);
        System.out.println(cat);
    }

    @JsonAutoDetect
    public static class Cat{
        public String name;
        public int age;

        Cat(){

        }

        @Override
        public String toString()
        {
            return "Cat{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }

    public static <T> T convertFromJsonToNormal(String fileName, Class<T> clazz) throws IOException {

        ObjectMapper mapper = new ObjectMapper();
        T value = mapper.readValue(new File(fileName), clazz);

        return value;
    }
}









package com.javarush.test.level33.lesson05.home04;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;

/* Конвертация из одного класса в другой используя JSON
НЕОБХОДИМО: подключенные библиотеки Jackson Core, Bind и Annotation версии 2.6.1

Два класса имеют одинаковые поля, но не имеют общий суперкласс. Пример, классы First и Second.
Реализовать логику метода convertOneToAnother, который должен возвращать объект класса resultClassObject,
значения полей которого равны значениям полей в объекте one.
Известно, что у классов есть Json аннотация, у которой значение проперти равно имени класса в нижнем регистре.
На примере класса First, это className="first"
Классы First и Second не участвуют в тестировании, они предоставлены в качестве тестовых данных.
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        Second s = (Second) convertOneToAnother(new First(), Second.class);
        First f = (First) convertOneToAnother(new Second(), First.class);

    }

    public static Object convertOneToAnother(Object one, Class resultClassObject) throws IOException {

        ObjectMapper om = new ObjectMapper();
        StringWriter stringWriter = new StringWriter();
        om.writeValue(stringWriter, one);

        String oneClassName = one.getClass().getSimpleName().toLowerCase();
        String resultClassName = resultClassObject.getSimpleName().toLowerCase();
        String jsonStr = stringWriter.toString().replaceFirst(oneClassName, resultClassName);

        StringReader stringReader = new StringReader(jsonStr);
        Object result = om.readValue(stringReader, resultClassObject);
        return result;
    }

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,  property="className")
    @JsonSubTypes(@JsonSubTypes.Type(value=First.class,  name="first"))
    public static class First {
        public int i;
        public String name;
    }

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,  property="className")
    @JsonSubTypes(@JsonSubTypes.Type(value=Second.class, name="second"))
    public static class Second {
        public int i;
        public String name;
    }
}









package com.javarush.test.level33.lesson05.home02;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.StringWriter;

/* Вторая сериализация в JSON
НЕОБХОДИМО: подключенные библиотеки Jackson Core, Bind и Annotation версии 2.6.1

Расставьте Json аннотации так, чтобы результат работы метода main был следующим
{"wildAnimal":"Murka","over":3}
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        Cat cat = new Cat();
        cat.name = "Murka";
        cat.age = 5;
        cat.weight = 3;

        StringWriter writer = new StringWriter();
        convertToJSON(writer, cat);
        System.out.println(writer.toString());
    }

    public static void convertToJSON(StringWriter writer, Object object) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(writer, object);
    }

    @JsonAutoDetect
    public static class Cat {

        @JsonProperty(value = "wildAnimal")
        public String name;

        @JsonIgnore
        public int age;

        @JsonProperty(value = "over")
        public int weight;

        Cat() {
        }
    }
}










package com.javarush.test.level33.lesson05.home05;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

/* Определение имени класса
НЕОБХОДИМО: подключенные библиотеки Jackson Core, Bind и Annotation версии 2.6.1

Расставьте Json аннотации так, чтобы результат выполнения метода main был следующий:
{
    "className" : ".Parking",
    "name" : "Super Parking",
    "city" : "Kyiv",
    "autos" : [ {
        "className" : "com.javarush.test.level33.lesson05.home05.RaceBike",
        "name" : "Simba",
        "owner" : "Peter",
        "age" : 2
    }, {
        "className" : "com.javarush.test.level33.lesson05.home05.Motorbike",
        "name" : "Manny",
        "owner" : null
    }, {
        "className" : "com.javarush.test.level33.lesson05.home05.Car"
    } ]
}

Подсказка: это всего два класса
*/
public class Solution {
    public static void main(String[] args) throws IOException {
        Parking parking = new Parking("Super Parking", "Kyiv");
        RaceBike raceBike = new RaceBike("Simba", "Peter", 2);
        Motorbike motorbike = new Motorbike("Manny");
        Car car = new Car();
        List<Auto> autos = new ArrayList<>();
        autos.add(raceBike);
        autos.add(motorbike);
        autos.add(car);
        parking.setAutos(autos);
        convertToJson(parking);
    }

    public static void convertToJson(Parking parking) throws IOException {
        StringWriter writer = new StringWriter();
        ObjectMapper mapper = new ObjectMapper();
        mapper.writerWithDefaultPrettyPrinter().writeValue(writer, parking);
        System.out.println(writer.toString());
    }
}




package com.javarush.test.level33.lesson05.home05;

public class RaceBike extends Motorbike {
    private String owner;
    private int age;

    public RaceBike(String name, String owner, int age) {
        super(name);
        this.owner = owner;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public String getOwner() {
        return owner;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "RaceBike{" +
                "name='" + name + '\'' +
                ", owner='" + owner + '\'' +
                ", age=" + age +
                '}';
    }
}
	
	
	
package com.javarush.test.level33.lesson05.home05;

import com.fasterxml.jackson.annotation.JsonTypeInfo;

import java.util.List;

@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS, property = "className")

public class Parking {
    public String name;
    public String city;
    public List<Auto> autos;

    public Parking(String name, String city) {
        this.name = name;
        this.city = city;
    }

    public void setAutos(List<Auto> autos) {
        this.autos = autos;
    }

    @Override
    public String toString() {
        return "Parking{" +
                "name='" + name + '\'' +
                ", city='" + city + '\'' +
                ", autos=" + autos +
                '}';
    }
}
	
	
package com.javarush.test.level33.lesson05.home05;

public class Motorbike extends Auto {
    private String owner;

    public Motorbike(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getOwner() {
        return owner;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    @Override
    public String toString() {
        return "Motorbike{" +
                "name='" + name + '\'' +
                ", owner='" + owner + '\'' +
                '}';
    }
}

package com.javarush.test.level33.lesson05.home05;

import com.fasterxml.jackson.annotation.JsonTypeInfo;


@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = "className")
public abstract class Auto {
    protected String name;
    protected String owner;
    protected int age;
}

package com.javarush.test.level33.lesson05.home05;

public class Car extends Auto {
}









XML ESCAPE SEQUENCES

Из-за того, что в XML используются символы « < > “ &», их нельзя использовать в других местах. Для их описания используют так называемые «эскейп последовательности» - 
набор символов для представления других символов/символа. Вот список некоторых из них:

Escape-последовательность	Символ, который она заменяет
&amp;	&
&quot;	"
&lt;	<
&gt;	>
&apos;	‘




Аннотации
@XmlTransient — помечаются поля, которые не будут включены в маршалинг

@XmlSeeAlso — используется, когда в классе существует объект другого класса

@XmlEnum — для перечислений

@XmlEnumValue — значение для полей в перечислении

@XmlAccessorType — что именно будет сериализовано

@XmlElements — контейнер для нескольких @XmlElement

@XmlMimeType — mime-type для поля











package com.javarush.test.level33.lesson08.home01;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import java.io.IOException;
import java.io.StringWriter;

/* Первая сериализация в XML
Раставьте правильно JAXB аннотации у статических классов.
Метод main не участвует в тестировании.
*/
public class Solution {
    public static void main(String[] args) throws IOException, JAXBException {
        Cat cat = new Cat ();
        cat.name = "Murka";
        cat.age = 5;
        cat.weight = 3;

        Dog dog = new Dog ();
        dog.name = "Killer";
        dog.age = 8;
        dog.owner = "Bill Jeferson";

        StringWriter writer = new StringWriter();
        convertToXml(writer, cat);
        convertToXml(writer, dog);
        System.out.println(writer.toString());
        /* expected output
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cat>
    <name>Murka</name>
    <age>5</age>
    <weight>3</weight>
</cat>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dog>
    <name>Killer</name>
    <age>8</age>
    <owner>Bill Jeferson</owner>
</dog>
        */
    }

    public static void convertToXml(StringWriter writer, Object obj) throws IOException, JAXBException {
        JAXBContext context = JAXBContext.newInstance(obj.getClass());
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        marshaller.marshal(obj, writer);
    }

    public static class Pet
    {
        public String name;
    }

    @XmlType(name = "cat")
    @XmlRootElement
    public static class Cat extends Pet
    {
        public int age;
        public int weight;
    }

    @XmlType(name = "dog")
    @XmlRootElement
    public static class Dog extends Pet
    {
        public int age;
        public String owner;
    }
}










package com.javarush.test.level33.lesson08.home02;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import java.io.StringReader;

/* Десериализация XML объекта
В метод convertFromXmlToNormal первым параметром приходит строка, содержащая xml объект.
Вторым параметром приходит имя класса, объект которого необходимо вернуть.
Метод convertFromXmlToNormal должен создать объект из xml-строки и вернуть его.
*/
public class Solution {
    public static void main(String[] args) throws Exception {
        String xmlData = "<cat><name>Murka</name><age>5</age><weight>4</weight></cat>";
        Cat cat = convertFromXmlToNormal(xmlData, Cat.class);
        System.out.println(cat);
    }

    public static <T> T convertFromXmlToNormal(String xmlData, Class<T> clazz) throws Exception {

        JAXBContext jaxbContext = JAXBContext.newInstance(clazz);
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();

        StringReader reader = new StringReader(xmlData);
        T value = (T) unmarshaller.unmarshal(reader);

        return value;
    }

    @XmlType(name = "cat")
    @XmlRootElement
    public static class Cat
    {
        public String name;
        public int age;
        public int weight;

        @Override
        public String toString() {
            return "Cat{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    ", weight=" + weight +
                    '}';
        }
    }
}










package com.javarush.test.level33.lesson10.home01;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import java.io.IOException;
import java.io.StringWriter;

/* Создание класса по строке xml
Восстановите класс по переданной строке xml.
Класс должен быть в отдельном файле.
Метод getClassName должен возвращать восстановленный класс.
Метод main не участвует в тестировании.
*/
public class Solution {
    public static void main(String[] args) throws IOException, JAXBException
    {
        Shop shop = new Shop();
        shop.names.add("S1");
        shop.names.add("S2");
        shop.count=12;
        shop.profit=123.4;
        shop.secretData.add("String1");
        shop.secretData.add("String2");
        shop.secretData.add("String3");
        shop.secretData.add("String4");
        shop.secretData.add("String5");
        StringWriter writer = new StringWriter();
        convertToXml(writer, shop);
        System.out.println(writer.toString());
    }
    public static void convertToXml(StringWriter writer, Object obj) throws IOException, JAXBException
    {
        JAXBContext context = JAXBContext.newInstance(obj.getClass());
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        marshaller.marshal(obj, writer);
    }

    public static Class getClassName() {

        return Shop.class;
    }
}


package com.javarush.test.level33.lesson10.home01;

import javax.xml.bind.annotation.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by Кира on 02.12.2016.
 */
@XmlType(name="shop")
@XmlRootElement
public class Shop
{
    @XmlElementWrapper(name="goods", nillable = true)
    public List<String> names = new ArrayList<>();
    public int count;
    public double profit;
    public List<String> secretData = new ArrayList<>();
}


<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<shop>
    <goods>
        <names>S1</names>
        <names>S2</names>
    </goods>
    <count>12</count>
    <profit>123.4</profit>
    <secretData>String1</secretData>
    <secretData>String2</secretData>
    <secretData>String3</secretData>
    <secretData>String4</secretData>
    <secretData>String5</secretData>
</shop>












package com.javarush.test.level33.lesson10.bonus01;

/* Комментарий внутри xml
Реализовать метод toXmlWithComment, который должен возвращать строку - xml представление объекта obj.
В строке перед каждым тэгом tagName должен быть вставлен комментарий comment.
Сериализация obj в xml может содержать CDATA с искомым тегом. Перед ним вставлять комментарий не нужно.

Пример вызова:  toXmlWithComment(firstSecondObject, "second", "it's a comment")
Пример результата:
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<first>
    <!--it's a comment-->
    <second>some string</second>
    <!--it's a comment-->
    <second>some string</second>
    <!--it's a comment-->
    <second><![CDATA[need CDATA because of < and >]]></second>
    <!--it's a comment-->
    <second/>
</first>
*/


import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.StringWriter;
import java.util.regex.Pattern;

public class Solution {

    public static void main(String[] args) throws Exception {

        String result = Solution.toXmlWithComment(new AnExample(), "needCDATA", "it's a comment");

        System.out.println(result);

    }

    @XmlType(name = "anExample")
    @XmlRootElement
    public static class AnExample {
        public String[] needCDATA = new String[]{"need CDATA because of < and >", ""};
    }


    public static String toXmlWithComment(Object obj, String tagName, String comment) {

        try {

            JAXBContext context = JAXBContext.newInstance(obj.getClass());
            Marshaller marshaller = context.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
            marshaller.marshal(obj, doc);

            NodeList nodes = doc.getElementsByTagName("*");

            for (int i = 0; i < nodes.getLength(); i++) {
                Node node = nodes.item(i);

                if (node.getNodeName().equals(tagName)) {
                    Comment com = doc.createComment(comment);
                    node.getParentNode().insertBefore(com, node);
                }
                replaceTextWithCDATA(node, doc);
            }
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");

            StringWriter sw = new StringWriter();
            transformer.transform(new DOMSource(doc), new StreamResult(sw));
            return sw.toString();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private static void replaceTextWithCDATA(Node node, Document doc) {
        if ((node.getNodeType() == 3) && (Pattern.compile("[<>&'\"]").matcher(node.getTextContent()).find())) {

            Node cnode = doc.createCDATASection(node.getNodeValue());
            node.getParentNode().replaceChild(cnode, node);
        }

        NodeList list = node.getChildNodes();

        for (int i = 0; i < list.getLength(); i++) {
            replaceTextWithCDATA(list.item(i), doc);
        }
    }

}









package com.javarush.test.level34.lesson02.task02;

/* Факториал с помощью рекурсии
Почитать про вычисление факториала.
Реализовать логику метода factorial, где n - это число, факториал которого нужно вычислить.
Не создавайте статические переменные и поля класса.
*/
public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(solution.factorial(9));     //362880
        System.out.println(solution.factorial(0));     //1
        System.out.println(solution.factorial(1));     //1
    }

    public int factorial(int n) {

        if(n <= 1){
            return 1;
        }else {

        return n*(factorial(n-1));
        }
    }
}









package com.javarush.test.level34.lesson02.task01;

/* Числа Фибоначчи с помощью рекурсии
Почитать про числа Фибоначчи.
Реализовать логику метода fibonacci, где n - это номер элемента в последовательности Фибоначчи.
Не создавайте статические переменные и поля класса.
*/
public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(solution.fibonacci(9));     //34
        System.out.println(solution.fibonacci(5));     //5
        System.out.println(solution.fibonacci(2));     //1
        System.out.println(solution.fibonacci(1));     //1
    }

    public int fibonacci(int n) {

        if (n == 1) return 1;
        if (n == 2) return 1;

        System.out.println(n);

        return fibonacci(n - 1) + fibonacci(n - 2);

    }
}








package com.javarush.test.level34.lesson02.task03;

/* Разложение на множители с помощью рекурсии
Разложить целое число n > 1 на простые множители.
Вывести в консоль через пробел все множители в порядке возрастания.
Написать рекуррентный метод для вычисления простых множителей.
Не создавайте статические переменные и поля класса.
Пример:
132
Вывод на консоль:
2 2 3 11
*/
public class Solution {

    public static void main(String[] args) {
        recursion(189);
    }

    public static void recursion(int n) {
        int a = 2;
        while (a <= n) {
            if ((n % a) == 0) {
                if (a != n) {
                    System.out.print(a + " ");
                    recursion(n / a);
                } else {
                    System.out.print(a);
                }
                return;
            }
            a++;
        }
    }
}











package com.javarush.test.level34.lesson04.task01;

import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

/* Мягкие ссылки
Разберитесь в примере.
Внутри метода main в нужном месте создайте мягкую ссылку reference на объект monkey.
Должны быть только используемые импорты.
*/
public class Solution {
    public static Helper helper = new Helper();

    public static class Monkey {
        private String name;

        public Monkey(String name) {
            this.name = name;
        }

        protected void finalize() {
            Helper.isFinalized = true;
            System.out.format("Bye-Bye, %s!\n", name);
        }
    }

    public static void main(String args[]) throws InterruptedException {
        helper.startTime();

        Monkey monkey = new Monkey("Simka");

        SoftReference<Monkey> reference = new SoftReference<Monkey>(monkey);
        helper.callGC();

        monkey = null;

        helper.callGC();
        helper.heapConsuming();

        if (reference.get() == null)
            System.out.println("Finalized");

        helper.finish();
    }

    public static class Helper {
        public static boolean isFinalized;

        private long startTime;

        void startTime() {
            this.startTime = System.currentTimeMillis();
        }

        int getTime() {
            return (int) (System.currentTimeMillis() - startTime) / 1000;
        }

        void callGC() throws InterruptedException {
            System.gc();
            Thread.sleep(1000);
        }

        void heapConsuming() {
            try {
                List<Solution> heap = new ArrayList<Solution>(100000);
                while (!isFinalized) {
                    heap.add(new Solution());
                }
            } catch (OutOfMemoryError e) {
                System.out.println("Out of memory error raised");
            }
        }

        public void finish() {
            System.out.println("Done");
            System.out.println("It took " + getTime() + " sec");
        }
    }
}






package com.javarush.test.level34.lesson06.task01;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

/* Слабые ссылки
Разберитесь в примере.
Внутри метода main в нужном месте создайте слабую ссылку reference на объект monkey.
*/
public class Solution {
    public static Helper helper = new Helper();

    public static class Monkey {
        private String name;

        public Monkey(String name) {
            this.name = name;
        }

        protected void finalize() {
            Helper.isFinalized = true;
            System.out.format("Bye-Bye, %s!\n", name);
        }
    }

   public static void main(String args[]) throws InterruptedException {
        helper.startTime();

        Monkey monkey = new Monkey("Simka");

        WeakReference<Monkey> reference = new WeakReference<Monkey>(monkey);
        helper.callGC();

        monkey = null;

        helper.callGC();
        helper.heapConsuming();

        if (reference.get() == null)
            System.out.println("Finalized");

        helper.finish();
    }

    public static class Helper {
        public static boolean isFinalized;

        private long startTime;

        void startTime() {
            this.startTime = System.currentTimeMillis();
        }

        int getTime() {
            return (int) (System.currentTimeMillis() - startTime) / 1000;
        }

        void callGC() throws InterruptedException {
            System.gc();
            Thread.sleep(1000);
        }

        void heapConsuming() {
            try {
                List<Solution> heap = new ArrayList<Solution>(100000);
                while (!isFinalized) {
                    heap.add(new Solution());
                }
            } catch (OutOfMemoryError e) {
                System.out.println("Out of memory error raised");
            }
        }

        public void finish() {
            System.out.println("Done");
            System.out.println("It took " + getTime() + " sec");
        }
    }
}












package com.javarush.test.level34.lesson08.task01;

import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.util.ArrayList;
import java.util.List;

/* Призрачные ссылки
Разберитесь в примере.
Реализуйте логику метода getFilledList класса Helper:
1) создайте список, котторый сможет хранить призрачные ссылки на объекты Monkey
2) добавьте в список 200 ссылок, используйте очередь helper.getQueue()
3) верните заполненный список
*/
public class Solution {
    public static Helper helper = new Helper();

    public static class Monkey {
    }

    public static void main(String args[]) throws InterruptedException {
        helper.startTime();
        List<PhantomReference<Monkey>> list = helper.getFilledList();

        //before GC
        helper.checkListWithReferences(list, "before");

        helper.callGC();
        helper.heapConsuming();

        //after GC
        helper.checkListWithReferences(list, "after");

        helper.finish();
    }

    public static class Helper {
        private ReferenceQueue<Monkey> queue = new ReferenceQueue<>();

        private long startTime;

        void startTime() {
            this.startTime = System.currentTimeMillis();
        }

        int getTime() {
            return (int) (System.currentTimeMillis() - startTime) / 1000;
        }

        void callGC() throws InterruptedException {
            System.gc();
            Thread.sleep(1000);
        }

        public ReferenceQueue<Monkey> getQueue() {
            return queue;
        }

        void heapConsuming() {
            try {
                List<Solution> heap = new ArrayList<Solution>(100000);
                while (true) {
                    heap.add(new Solution());
                }
            } catch (OutOfMemoryError e) {
                System.out.println("Out of memory error raised");
            }
        }

        public void checkListWithReferences(List<PhantomReference<Monkey>> list, String string) {
            int count = 0;
            for (PhantomReference<Monkey> reference : list) {
                if (reference.isEnqueued()) {
                    count++;
                }
            }

            System.out.println(String.format("The enqueue reference count is %d (%s GC was called)", count, string));
        }

        public List<PhantomReference<Monkey>> getFilledList() {

            List<PhantomReference<Monkey>> list = new ArrayList<>();

            for ( int i = 0; i < 200; i++)
            {
                Monkey monkey = new Monkey();
                list.add(new PhantomReference<Monkey>(monkey, getQueue()));
            }


            return list;
        }

        public void finish() throws InterruptedException {
            int count = 0;
            while (queue.poll() != null) {
                count++;
            }
            System.out.println(count + " objects are in the queue of phantom reference");
            System.out.println("It took " + getTime() + " sec");
        }
    }
}

















package com.javarush.test.level34.lesson10.home01;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

/* Настраиваем логгер
Дан файл log4j.properties, который содержит настройки для логгера для разработчиков.
Изменились требования к логированию для продакшена.
Список изменений, которые нужно сделать:
1) Размер файла для логирования не должен превышать 5 мегабайт
2) Файлы лога должны храниться на диске D в директории log, называться должны runApp.log
3) Файлы лога должны содержать 6 последних файлов. Если шестой файл уже заполнен(имеет размер 5Мб),
то нужно удалить самый первый и создать новый.
4) Уровень вывода сообщений в консоль нужно установить на уровне ERROR
5) Минимальный уровень логирования выставить в WARN
*/
public class Solution {
    public static void main(String args[]) throws IOException {
        String logProperties = "src/" + Solution.class.getPackage().getName().replaceAll("[.]", "/") + "/log4j.properties";
        Path path = Paths.get(logProperties).toAbsolutePath();
        try (InputStream is = new FileInputStream(path.toFile())) {
            Properties properties = new Properties();
            properties.load(is);
        }
    }
}


log4j.rootLogger=WARN, file, stdout

# Direct log messages to a log file
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.threshold=WARN
log4j.appender.file.File=D:\\log\\runApp.log
log4j.appender.file.MaxFileSize=5MB
log4j.appender.file.MaxBackupIndex=6
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern= %-5p %c{1}:%L - %m%n

# Direct log messages to stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.threshold=ERROR
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss}

log4j.logger.org.springframework=ERROR
log4j.logger.org.hibernate=ERROR
log4j.logger.org.apache.cxf=ERROR









package com.javarush.test.level35.lesson04.task01;

        import java.util.List;

/* Знакомство с дженериками
Параметризируйте классы SomeClass и Solution следующим образом:
1. SomeClass должен работать с типами, которые наследуются от Number;
2. Solution должен работать с типами, которые наследуются от List, который в свою очередь параметризируется типом SomeClass.
*/
public class Solution<K extends List<Solution.SomeClass>> {
    public static class SomeClass<T extends Number> {
    }
}









package com.javarush.test.level35.lesson04.home01;
/* Вызов статического метода
Измените статический метод в классе GenericStatic так, чтобы он стал дженериком.
Пример вызова дан в методе main.
*/
public class Solution {
    public static void main(String[] args) {
        Number number = GenericStatic.<Number>someStaticMethod(new Integer(3));
    }
}



package com.javarush.test.level35.lesson04.home01;

public class GenericStatic {


    public static <T extends Object> T someStaticMethod(Object genericObject) {
        System.out.println(genericObject);
        return (T) genericObject;
    }
}















package com.javarush.test.level35.lesson06.task01;

import java.util.HashMap;
import java.util.LinkedHashMap;

/* Простой generics
Параметризируйте класс Solution, чтобы он мог работать со всеми классами, которые наследуются от HashMap.
Метод getMap должен возвращать тип поля map.
*/
public class Solution {
    private HashMap map;

    public Solution(HashMap map) {
        this.map = map;
    }

    public <T extends HashMap> T getMap() {
        return (T) map;
    }

    public static void main(String[] args) {
        HashMap<String, Integer> hashMap = new HashMap<>();
        hashMap.put("string", 4);
        Solution solution = new Solution(hashMap);
        HashMap mapFromSolution = solution.getMap();
        System.out.println(mapFromSolution.getClass());


        LinkedHashMap<Solution, Solution> hashMap2 = new LinkedHashMap<>();
        hashMap2.put(solution, solution);
        Solution solution2 = new Solution(hashMap2);
        LinkedHashMap mapFromSolution2 = solution2.getMap();   //need to cast  :(
        System.out.println(mapFromSolution2.getClass());
    }
}











package com.javarush.test.level35.lesson06.home01;

/* Несколько суперклассов для дженерика
Дан класс Solution, параметризированный T.
Ограничьте параметр T.
T должен быть наследником класса ClassForGenerics и одновременно реализовывать интерфейс InterfaceForGenerics.
Менять можно только класс Solution.
*/
public class Solution<T extends ClassForGenerics & InterfaceForGenerics>{

    public static void main(String[] args) {
        Solution<TestClassGood> testClassSolution = new Solution<>();
        testClassSolution.check();

        //!!! Следующие оба варианта не должны работать:
        //Solution<TestClassWrong1> wrong1Solution = new Solution<>();
        //wrong1Solution.check();

        //Solution<TestClassWrong2> wrong2Solution = new Solution<>();
        //wrong2Solution.check();
    }

    public void check() {
        System.out.println("Works!");
    }

    public static class TestClassGood extends ClassForGenerics implements InterfaceForGenerics {

    }

    public static class TestClassWrong1 extends ClassForGenerics {

    }

    public static class TestClassWrong2 implements InterfaceForGenerics {

    }

}

package com.javarush.test.level35.lesson06.home01;

public interface InterfaceForGenerics {
}


package com.javarush.test.level35.lesson06.home01;

public class ClassForGenerics {
}











List<? super MyClass> list
Но между extends и super есть существенное различие.

«? extends T» обозначает, что класс должен быть наследником T.

«? super T» обозначает, что класс должен быть предком T.

- Ух ты. А где это используется?

- «? super T» используется, когда метод собирается добавлять в коллекцию объект типа T. Тогда это может быть коллекция типа T или любого типа-предка T.

- Ага. Ссылку на объект типа T можно же присвоить любому родительскому типу для T.

- Честно говоря – этот подход используется не очень часто. Тем более, что у него есть и обратная сторона. Пример:

Примеры
public void doSomething(List<? super MyClass> list)
{
 for(MyClass object : list) //ошибка!
 { 
  System.out.println(object.getState()); 
 }
}
public void doSomething(List<? super MyClass> list)
{
 list.add(new MyClass()); //тут все работает отлично.
}







package com.javarush.test.level35.lesson08.task01;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
/* Wildcards
Перепишите дженерики в методе add импользуя wildcards.
Логику не меняйте.
Не оставляйте закомментированный код.
*/
public class Solution {

    public static <D> void add(List<? super D> destinationList, List<? extends D> sourceList) {
        ListIterator<? super D> destListIterator = destinationList.listIterator();
        ListIterator<? extends D> srcListIterator = sourceList.listIterator();
        for (int i = 0; i < sourceList.size(); i++) {
            destListIterator.add(srcListIterator.next());
        }
    }


    public static void main(String[] args) {
        List<B> destination = new ArrayList<>();
        destination.add(new B());
        List<C> source = new ArrayList<>();
        source.add(new C());
        add(destination, source);
        System.out.println(destination);
        System.out.println(source);

        /*
[com.javarush.test.level39.lesson08.task01.Solution$C@203b4f0e, com.javarush.test.level39.lesson08.task01.Solution$B@15c330aa]
[com.javarush.test.level39.lesson08.task01.Solution$C@203b4f0e]
         */
    }

    static class A {
    }

    static class B extends A {
    }

    static class C extends B {
    }
}












package com.javarush.test.level35.lesson08.bonus01;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/* List to Map
Реализуйте логику метода convert в классе ConvertableUtil, который должен возвращать словарь,
значениями которого являются элементы переданного Списка,
а ключами являются объекты, полученные вызовом интерфейсного метода getKey.

Элементы Списка должны наследоваться от Convertable, который в свою очередь параметризирован каким-то ключом.
Например, ConvertableBook параметризирован String, т.е. ключ в результирующем словаре должен иметь тип - String
ConvertableUser параметризирован Integer, т.е. ключ в результирующем словаре должен иметь тип - Integer

Значения в словаре должны совпадать с элементами Списка.
Смотрите метод main для примера.

Расставьте в методе ConvertableUtil.convert дженерик типы.
*/
public class Solution {
    public static void main(String[] args) {
        List<ConvertableUser> users = new ArrayList<>();
        users.add(new ConvertableUser(234, "First User"));
        users.add(new ConvertableUser(235, "Second User"));
        users.add(new ConvertableUser(236, "Third User"));

        Map<Integer, ConvertableUser> newMap = ConvertableUtil.convert(users);
        System.out.println(newMap);
        //{236=ConvertableUser{id=236, name='Third User'},
        // 235=ConvertableUser{id=235, name='Second User'},
        // 234=ConvertableUser{id=234, name='First User'}}

        //////////////////////////////////////////////////////////

        List<ConvertableBook> books = new ArrayList<>();
        books.add(new ConvertableBook("First Book"));
        books.add(new ConvertableBook("Second Book"));
        books.add(new ConvertableBook("Third Book"));

        Map<String, ConvertableBook> bookMap = ConvertableUtil.convert(books);
        System.out.println(bookMap);
        //{Third Book=ConvertableBook{name='Third Book'},
        // First Book=ConvertableBook{name='First Book'},
        // Second Book=ConvertableBook{name='Second Book'}}
    }
}

package com.javarush.test.level35.lesson08.bonus01;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ConvertableUtil {

    public static <T> Map convert(List<? extends Convertable<T>> list) {
        Map result = new HashMap();

        for(Convertable<T> t : list){
            result.put(t.getKey(), t);
        }

        return result;
    }
}


package com.javarush.test.level35.lesson08.bonus01;

public class ConvertableBook implements Convertable<String> {
    private String name;

    public ConvertableBook(String name) {
        this.name = name;
    }

    @Override
    public String getKey() {
        return name;
    }

    @Override
    public String toString() {
        return "ConvertableBook{" +
                "name='" + name + '\'' +
                '}';
    }
}


package com.javarush.test.level35.lesson08.bonus01;

public class ConvertableUser implements Convertable<Integer> {
    private Integer id;
    private String name;

    public ConvertableUser(Integer id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public Integer getKey() {
        return id;
    }

    @Override
    public String toString() {
        return "ConvertableUser{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}


package com.javarush.test.level35.lesson08.bonus01;

public interface Convertable<Key> {
    Key getKey();
}













package com.javarush.test.level35.lesson10.task02;

import java.util.List;

/* extends vs super
Логика всех методов - добавить source в destination.
!!!Расставьте ?, extends и super где необходимо:!!!
1) one - должен работать с одним и тем же типом;
2) two - должен добавлять любых наследников типа T в список, умеющий хранить только тип T;
3) three - должен добавлять объекты типа T в любой список, параметризированный любым родительским классом;
4) four - должен добавлять любых наследников типа T в список, параметризированный любым родительским классом.
Не оставляйте закомментированный код.
*/
public abstract class Solution {
    public abstract <T> void one(List<T> destination, List<T> source);

    public abstract <T> void two(List<T> destination, List<? extends T> source);

    public abstract <T> void three(List<? super T> destination, List<T> source);

    public abstract <T> void four(List<? super T> destination, List<? extends T> source);
}










package com.javarush.test.level36.lesson04.home01;

/* MVC - простая версия
В отдельных файлах создай классы Service, Model, View, Controller.
Распредели методы из класса Solution по созданным классам учитывая, что должен получиться MVC.
Создай нужные поля класса при необходимости.
Не добавляй своих других методов.
Метод main оставь в классе Solution.
*/
public class Solution {
    public static void main(String[] args) {
        new View().fireEventShowData();
    }

}

package com.javarush.test.level36.lesson04.home01;

import java.util.List;

/**
 * Created by Кира on 08.12.2016.
 */
public class Model {

    private Service service = new Service();

    public List<String> getStringDataList() {
        return service.getData();
    }
}




/**
 * Created by Кира on 08.12.2016.
 */
public class View {

    private Controller controller = new Controller();

    public void fireEventShowData() {
        System.out.println(controller.onDataListShow());

    }
}


package com.javarush.test.level36.lesson04.home01;

import java.util.List;

/**
 * Created by Кира on 08.12.2016.
 */
public class Controller {

    private Model model = new Model();

    public List<String> onDataListShow() {
        return model.getStringDataList();
    }
}

package com.javarush.test.level36.lesson04.home01;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by Кира on 08.12.2016.
 */
public class Service {

    public List<String> getData() {
        List<String> data = new ArrayList<String>() {{
            add("First string");
            add("Second string");
            add("Third string");
        }};
        return data;
    }
}










Методы интерфейса Collection<E>:

Методы	Описание
boolean add(E e);	Добавляет элемент в коллекцию
boolean addAll(Collection<? extends E> c);	Добавляет элементы в коллекцию
void clear();	Удаляет все элементы из коллекции
boolean contains(Object o);	Проверяет – есть ли в коллекции элемент?
boolean containsAll(Collection<?> c);	Проверяет – есть ли в коллекции элементы?
boolean equals(Object o);	Сравнивает коллекции
int hashCode();	Возвращает хэш-код
boolean isEmpty();	Проверяет – пуста ли коллекция?
Iterator<E> iterator();	Возвращает объект-итератор
boolean remove(Object o);	Удаляет элемент из коллекции
boolean removeAll(Collection<?> c);	Удаляет элементы из коллекции
boolean retainAll(Collection<?> c);	Удаляет все элементы, которых нет «с»
int size();	Возвращает размер коллекции
Object[] toArray();	Преобразовывает коллекцию к массиву
<T> T[] toArray(T[] a);	Преобразовывает коллекцию к массиву



Методы интерфейса List<E>:

Методы	Описание
void add(int index, E element);	Добавляет элементы в середину коллекции
boolean addAll(int index, Collection<? extends E> c);	Добавляет элементы в коллекцию
E get(int index);	Возвращает элемент по номеру
int indexOf(Object o);	Возвращает индекс(номер) элемента
int lastIndexOf(Object o);	Возвращает последний индекс элемента.
ListIterator<E> listIterator();	Возвращает итератор для списка
ListIterator<E> listIterator(int index);	Возвращает итератор для списка
E remove(int index);	Удаляет элемент по индексу
E set(int index, E element);	Устанавливает новое значение по индексу
List<E> subList(int fromIndex, int toIndex);	Возвращает под-коллекцию




Методы интерфейса Set<E>:

Методы	Описание
нет методов
Интерфейс Set не содержит новых методов, только унаследованные.














package com.javarush.test.level36.lesson06.task01;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.Collections;
import java.util.List;

/* Найти класс по описанию
1. Реализует интерфейс List
2. Является приватным статическим классом внутри популярного утилитного класса
3. Доступ по индексу запрещен - кидается исключение IndexOutOfBoundsException
4. Используйте рефлекшн, чтобы добраться до искомого класса
*/
public class Solution {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        System.out.println(getExpectedClass());
    }

    public static Class getExpectedClass() {

        for (Class cls : Collections.class.getDeclaredClasses()) {
            if (List.class.isAssignableFrom(cls)
                    && Modifier.isPrivate(cls.getModifiers())
                    && Modifier.isStatic(cls.getModifiers())) {
                try {
                    Constructor constructor = cls.getDeclaredConstructor();
                    constructor.setAccessible(true);
                    List list = (List) constructor.newInstance();
                    try {
                        list.get(0);
                    } catch (IndexOutOfBoundsException e) {
                        return cls;
                    }
                } catch (IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) {

                }
                System.out.println(cls.toString());
            }
        }
        return null;
    }
}















package com.javarush.test.level36.lesson06.task02;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/* Поиск класса по описанию
Замените следующие слова на нужные:
1. ClassNameToBeReplaced - имя класса, потокобезопасный аналог ArrayList, в котором все операции изменения
(mutative operations) используют новую копию основного массива.

2. methodNameToBeReplaced - имя метода, который в текущий список 'list' добавляет те элементы переданной коллекции,
которые не содержатся в 'list'.

Не оставляйте комментированный код.
*/
public class Solution {
    public static void main(String... args) {    //it's correct line
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        list.remove("B");
        List<String> collection = Arrays.asList(new String[]{"B", "C", "D", "B"});

        list.addAllAbsent(collection);

        for (String string : list) {
            System.out.println(string);
        }
        /* Expected output
A
C
B
D
         */
    }
}










package com.javarush.test.level36.lesson10.task01;

/* Найти класс по описанию
1. Реализует интерфейс Queue
2. Используется при работе с трэдами
3. Из этой очереди элементы могут быть взяты только тогда, когда они заэкспарятся, их время задержки истекло
4. Головой очереди является элемент, который заэкспарился раньше всех
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(getExpectedClass());
    }

    public static Class getExpectedClass() {

        try
        {
            return Class.forName("java.util.concurrent.DelayQueue");
        }
        catch (ClassNotFoundException e)
        {
            e.printStackTrace();
        }
        return null;
    }
}











package com.javarush.test.level36.lesson08.task01;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.TreeSet;

/* Использование TreeSet
Первым параметром приходит имя файла: файл1.
файл1 содержит только буквы латинского алфавита, пробелы, знаки препинания, тире, символы перевода каретки.
Отсортировать буквы по алфавиту и вывести на экран первые 5 различных букв в одну строку без разделителей.
Если файл1 содержит менее 5 различных букв, то вывести их все.
Буквы различного регистра считаются одинаковыми.
Регистр выводимых букв не влияет на результат.
Закрыть потоки.

Пример 1 данных входного файла:
zBk yaz b-kN
Пример 1 вывода:
abkny

Пример 2 данных входного файла:
caAC
A, aB? bB
Пример 2 вывода:
abc

Подсказка: использовать TreeSet
*/
public class Solution {
    public static void main(String[] args) throws IOException {

        File inc = new File(args[0]);

        try(BufferedReader reader = new BufferedReader(new FileReader(inc))){

            String text = "";

            while (reader.ready()) {
                text += reader.readLine();
            }

            reader.close();

            TreeSet<String> set = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);

            for(int i = 0; i < text.length(); i++){
                if(Character.isLetter(text.charAt(i))) {
                    set.add(String.valueOf(text.charAt(i)).toLowerCase());
                }
            }

            StringBuilder sb = new StringBuilder();

            Object[] fin = set.toArray();

            if(fin.length < 5) {

                for (Object s : fin) {
                    sb.append(s);
                }
            }else {

                for(int j = 0; j < 5; j++){
                    sb.append(fin[j]);
                }
            }
            System.out.println(sb.toString());
        }
    }
}















package com.javarush.test.level36.lesson08.bonus01;

import javax.swing.*;
import java.awt.*;

/* Разбираемся в красно-черном дереве
Дана реализация красно-черного дерева.
Некоторые методы сломаны. Разберитесь в коде и исправьте ошибки.
Метод main не участвует в тестировании.
Все модификатры правильные.
Имена переменных и методов не изменяйте.
*/
public class Solution extends JFrame {
    private JPanel field = new JPanel()
    {
        private void paintArrow(Graphics g, int x1, int y1, int x2, int y2)
        {
            final float k = 0.25f;
            g.setColor(Color.blue);

            int xBeg = Math.round(x1 + k * (x2 - x1));
            int yBeg = Math.round(y1 + k * (y2 - y1));
            int xEnd = Math.round(x2 - k * (x2 - x1));
            int yEnd = Math.round(y2 - k * (y2 - y1));

            g.drawLine(xBeg, yBeg, xEnd, yEnd);
        }

        private void paintNode(RedBlackTree.Node node, Graphics g, int x, int y, int length) throws Exception
        {
            Color color = "black".equals(NodeHelperTestSolution.getNodeColor(node).toString().toLowerCase()) ?
                    Color.black : Color.red;

            g.setColor(color);
            g.fillRect(x - 5, y - 5, 10, 10);
            g.drawString(Integer.valueOf(NodeHelperTestSolution.getNodeIntValue(node)).toString(), x, y - 8);

            RedBlackTree.Node leftNode = NodeHelperTestSolution.getNodeValue("left", node);
            if (leftNode != NodeHelperTestSolution.getEmptyNode())
            {
                paintArrow(g, x, y, x - length, y + 30);
                paintNode(leftNode, g, x - length, y + 30, length / 2);
            }

            RedBlackTree.Node rightNode = NodeHelperTestSolution.getNodeValue("right", node);
            if (rightNode != NodeHelperTestSolution.getEmptyNode())
            {
                paintArrow(g, x, y, x + length, y + 30);
                paintNode(rightNode, g, x + length, y + 30, length / 2);
            }

        }

        @Override
        public void paint(Graphics g)
        {
            g.setColor(Color.white);
            g.fillRect(0, 0, getWidth(), getHeight());

            try
            {
                RedBlackTree.Node node = NodeHelperTestSolution.getFromTreeNodeByName("header", tree);
                paintNode(node, g, 20, 20, 400);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    };

    private Solution()
    {
        add(field);
        setSize(1000, 500);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        tree = new RedBlackTree();
    }

    private RedBlackTree tree;

    private static void insertValue(Solution solution, int value) throws InterruptedException
    {
        JOptionPane.showMessageDialog(solution, value);
        solution.tree.insert(value);
        solution.field.repaint();
    }

    public static void main(String[] args) throws Exception {
        Solution solution = new Solution();

        int[] ints = {10, 1, 15, 9, 18, 7, 14, 25, 10, 16, 28, 20, 8, 2, 17, 24, 25, 13, 6, 23, 45, 12, 31, 22, 3, 7, 1, 10};

        for (int i : ints)
            insertValue(solution, i);

        solution.field.repaint();
    }
}

	 
	 
package TempPack;

/**
 * Created by Кира on 13.12.2016.
 */
public class RedBlackTree {
    protected Node current;
    private Node parent;
    private Node grand;
    private Node great;
    private Node header;


    private static final Node EMPTY = new Node(0);

    static {
        EMPTY.left = EMPTY;
        EMPTY.right = EMPTY;
    }

    public RedBlackTree() {
        header = new Node(Integer.MIN_VALUE);
        header.left = EMPTY;
        header.right = EMPTY;
    }

    public boolean isEmpty() {
        return header.right == EMPTY;
    }

    public void clear() {
        header.right = EMPTY;
    }

    public void insert(int item) {
        current = grand = parent = header;
        EMPTY.element = item;
        while (current.element != item) {
            great = grand;
            grand = parent;
            parent = current;
            current = item < current.element ? current.left : current.right;

            if (current.left.color == Color.RED && current.right.color == Color.RED) {
                reorient(item);
            }
        }

        if (current != EMPTY) {
            return;
        }

        current = new Node(item, EMPTY, EMPTY);

        if (item < parent.element) {
            parent.left = current;
        } else {
            parent.right = current;
        }

        reorient(item);
    }

    protected void reorient(int item) {
        current.color = Color.RED;
        current.left.color = Color.BLACK;
        current.right.color = Color.BLACK;

        if (parent.color == Color.RED) {
            grand.color = Color.RED;
            if (item < grand.element != item < parent.element) {
                parent = rotate(item, grand);
            }
            current = rotate(item, great);
            current.color = Color.BLACK;
        }

        header.right.color = Color.BLACK;
    }

    private Node rotate(int item, Node parent) {
        if (item < parent.element) {
            Node node = parent.left;
            Node resultNode = item < node.element ? rotateWithLeftNode(node) : rotateWithRightNode(node);
            parent.left = resultNode;
            return parent.left;
        } else {
            Node node = parent.right;
            Node resultNode = item < node.element ? rotateWithLeftNode(node) : rotateWithRightNode(node);
            parent.right = resultNode;
            return parent.right;
        }
    }

    private Node rotateWithLeftNode(Node element) {
        Node left = element.left;
        element.left = left.right;
        left.right = element;
        return left;
    }

    private Node rotateWithRightNode(Node element) {
        Node right = element.right;
        element.right = right.left;
        right.left = element;
        return right;
    }

    public static enum Color {
        BLACK,
        RED
    }

    public static class Node {
        private int element;
        private Node left;
        private Node right;
        private Color color;

        public Node(int element) {
            this(element, null, null);
        }

        public Node(int element, Node left, Node right) {
            this.left = left;
            this.right = right;
            this.element = element;
            this.color = Color.BLACK;
        }
    }
}	 
	 
	 
package com.javarush.test.level36.lesson08.bonus01;

import java.lang.reflect.Field;

public class NodeHelperTestSolution {

    public static void changeNode(String nodName, RedBlackTree tree, String fieldName, RedBlackTree.Node newValue) throws
            Exception
    {
        RedBlackTree.Node header = getFromTreeNodeByName(nodName, tree);
        setNewNodeValue(fieldName, newValue, header);
    }

    public static void setNewNodeValue(String fieldName, RedBlackTree.Node newValue, RedBlackTree.Node node) throws
            NoSuchFieldException, IllegalAccessException
    {
        Field nodeField = node.getClass().getDeclaredField(fieldName);
        nodeField.setAccessible(true);
        nodeField.set(node, newValue);
    }

    public static RedBlackTree.Node getNodeValue(String fieldName, RedBlackTree.Node node) throws
            NoSuchFieldException, IllegalAccessException
    {
        Field nodeField = node.getClass().getDeclaredField(fieldName);
        nodeField.setAccessible(true);
        return (RedBlackTree.Node) nodeField.get(node);
    }

    public static RedBlackTree.Node getFromTreeNodeByName(String nodName, RedBlackTree tree) throws
            NoSuchFieldException,
            IllegalAccessException
    {
        Field headerField = RedBlackTree.class.getDeclaredField(nodName);
        headerField.setAccessible(true);
        return (RedBlackTree.Node) headerField.get(tree);
    }

    public static void changeColor(RedBlackTree.Node node, RedBlackTree.Color newColor) throws Exception {
        Field colorField = node.getClass().getDeclaredField("color");
        colorField.setAccessible(true);
        colorField.set(node, newColor);
    }

    public static RedBlackTree.Node getEmptyNode() throws NoSuchFieldException, IllegalAccessException {
        Field field = RedBlackTree.class.getDeclaredField("EMPTY");
        field.setAccessible(true);
        return (RedBlackTree.Node) field.get(RedBlackTree.class);
    }





    public static RedBlackTree.Color getNodeColor(RedBlackTree.Node node) throws Exception {

        Field colorField = node.getClass().getDeclaredField("color");
        colorField.setAccessible(true);

        Object i = colorField.get(node);
        if (i.equals(RedBlackTree.Color.RED)) {
            return RedBlackTree.Color.RED;
        } else if (i.equals(RedBlackTree.Color.BLACK)) {
            return RedBlackTree.Color.BLACK;
        }
        return null;
    }

    public static int getNodeIntValue(RedBlackTree.Node node) throws NoSuchFieldException, IllegalAccessException {

        Field nodeInt = node.getClass().getDeclaredField("element");
        nodeInt.setAccessible(true);

        return (int) nodeInt.get(node);
    }
}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
package com.javarush.test.level37.lesson04.task01;

import java.util.ArrayList;
import java.util.Iterator;

/* Круговой итератор
Класс Solution наследуется от ArrayList.
Напишите свой класс RoundIterator внутри Solution, который будет итератором для списка Solution.
Итератор должен ходить по кругу по всем элементам.
В остальном поведение должно быть идентичным текущему итератору.
*/
public class Solution<T> extends ArrayList<T> {
    public static void main(String[] args) {
        Solution<Integer> list = new Solution<>();
        list.add(1);
        list.add(2);
        list.add(3);

        int count = 0;
        for (Integer i : list) {
            //1 2 3 1 2 3 1 2 3 1
            System.out.print(i + " ");
            count++;
            if (count == 10) {
                break;
            }
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new RoundIterator();
    }

    public class RoundIterator implements Iterator<T> {

        private Iterator<T> iterator;

        public RoundIterator() {
            this.iterator = Solution.super.iterator();
        }

        @Override
        public boolean hasNext() {
            return (Solution.this.size() > 0);
        }

        @Override
        public T next() {
            if (!iterator.hasNext()) 
                iterator = Solution.super.iterator();
            return iterator.next();
        }

        @Override
        public void remove() {
            iterator.remove();
        }

    }
}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
package com.javarush.test.level36.lesson10.bonus01;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;

/* Осваиваем ClassLoader и Reflection
Аргументом для класса Solution является абсолютный путь к пакету,
например, "C:\JavaRushHomeWork\src\com\javarush\test\level36\lesson10\bonus01\data\second".
Имя пакета может содержать File.separator.
В этом пакете находятся только скомпилированные классы.
Известно, что каждый класс имеет конструктор без параметров и реализует интерфейс HiddenClass.
Считайте все классы с файловой системы, создайте фабрику - реализуйте метод getHiddenClassObjectByKey.
Известно, что есть только один класс, простое имя которого начинается с String key без учета регистра.
*/
public class Solution {
    private List<Class> hiddenClasses = new ArrayList<>();
    private String packageName;
    public Solution(String packageName) {
        this.packageName = packageName;
    }

    public static void main(String[] args) throws ClassNotFoundException {
        Solution solution = new Solution("E:\\JavaRushHomeWork\\src\\com\\javarush\\test\\level36\\lesson10\\bonus01\\data\\second");
        solution.scanFileSystem();
        System.out.println(solution.getHiddenClassObjectByKey("hiddenclassimplse"));
        System.out.println(solution.getHiddenClassObjectByKey("hiddenclassimplf"));
        System.out.println(solution.getHiddenClassObjectByKey("packa"));
    }

    public void scanFileSystem() throws ClassNotFoundException {
        File dir = new File(packageName);
        String[] classFiles = dir.list();
        for (String file : classFiles) {
            final String finalPath = dir.getAbsolutePath() + File.separator;
            ClassLoader loader = new ClassLoader() {
                @Override
                protected Class<?> findClass(String className) throws ClassNotFoundException {
                    byte[] temp = getBytesFromFile(finalPath + className + ".class");
                    return defineClass(null, temp, 0, temp.length);
                }

                private byte[] getBytesFromFile(String fileName) {
                    File file = new File(fileName);
                    FileInputStream fis = null;
                    try {
                        fis = new FileInputStream(file);
                    } catch (Exception e) {
                        return null;
                    }
                    BufferedInputStream bis = new BufferedInputStream(fis);
                    int size = (int) file.length();
                    byte[] b = new byte[size];
                    int rb = 0;
                    int chunk = 0;
                    try {
                        while (((int) size - rb) > 0) {
                            chunk = bis.read(b, rb, (int) size - rb);
                            if (chunk == -1) {
                                break;
                            }
                            rb += chunk;
                        }
                    } catch (IOException e) {
                        try {
                            throw new ClassNotFoundException();
                        } catch (ClassNotFoundException e1) {
                            e1.printStackTrace();
                        }
                        return null;
                    }
                    return b;
                }
            };

            Class clazz = loader.loadClass(file.substring(0, file.lastIndexOf(".")));
            if (HiddenClass.class.isAssignableFrom(clazz)) {
                hiddenClasses.add(clazz);
            }
        }
    }

    public HiddenClass getHiddenClassObjectByKey(String key) {
        for(Class clazz: hiddenClasses){
            if(clazz.getSimpleName().toLowerCase().startsWith(key.toLowerCase())){
                try {
                    Constructor[] constructors = clazz.getDeclaredConstructors();
                    for(Constructor constructor: constructors){
                        if(constructor.getParameterTypes().length==0){
                            constructor.setAccessible(true);
                            return (HiddenClass) constructor.newInstance(null);
                        }
                    }
                }
                catch (InstantiationException e) {
                    e.printStackTrace();
                }
                catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
                catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }
}
 
	 
	 
	 
package com.javarush.test.level36.lesson10.bonus01.data.second;

import com.javarush.test.level36.lesson10.bonus01.HiddenClass;

public class HiddenClassImplFirst implements HiddenClass {
}
	 
	 
	 
	 
package com.javarush.test.level36.lesson10.bonus01.data.second;

import com.javarush.test.level36.lesson10.bonus01.HiddenClass;

public class HiddenClassImplSecond implements HiddenClass {
    private HiddenClassImplSecond() {
    }
}
	 
	 
	 
	 
package com.javarush.test.level36.lesson10.bonus01.data.second;

import com.javarush.test.level36.lesson10.bonus01.HiddenClass;

class PackageAccessClass implements HiddenClass {
    PackageAccessClass() {
    }
}
	 
	 
	 
package com.javarush.test.level36.lesson10.bonus01;

public interface HiddenClass {
}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
package com.javarush.test.level37.lesson06.task01;

import java.util.concurrent.ConcurrentSkipListMap;

/* Найти класс по описанию
1. Реализует интерфейс Map
2. Используется при работе с трэдами
3. Неблокирущая версия списка с пропусками, который адаптирован для хеш-таблицы.
Про список с пропусками читать в дополнительном материале к этой лекци
*/
public class Solution {
    public static void main(String[] args) {
        System.out.println(getExpectedClass());
    }

    public static Class getExpectedClass() {

        return ConcurrentSkipListMap.class;
    }
}
















package com.javarush.test.level37.lesson06.task02;

import java.util.HashMap;
import java.util.Map;

/* Фикс бага
В Вашем большом проекте повсеместно используется метод getExpectedMap.
В какой-то момент тестеры обнаружили, что метод getExpectedMap выбрасывает NullPointerException.
Ожидаемое поведение описано в комментарии метода main.
Найдите другую стандартную реализацию интерфейса Map, верните объект этого типа в getExpectedMap вместо TreeMap.
Метод main должен отработать без исключений.
Метод main не менять.
*/
public class Solution {
    public static void main(String[] args) {
        Map expectedMap = getExpectedMap();

        System.out.println("********* Add obj with NULL key *********");
        expectedMap.put(null, "text 1");
        System.out.println(expectedMap.size());
        System.out.println(expectedMap.get(null));

        System.out.println("*********  Add obj with 0 key *********");
        expectedMap.put(0, "text 2");
        System.out.println(expectedMap.size());
        System.out.println(expectedMap.get(null));
        System.out.println(expectedMap.get(0));

        System.out.println("********* Keys *********");
        for (Object o : expectedMap.keySet()) {
            System.out.println(o);
        }
        System.out.println("********* Values *********");
        for (Object o : expectedMap.values()) {
            System.out.println(o);
        }

        /* Expected output
********* Add obj with NULL key *********
1
text 1
*********  Add obj with 0 key *********
2
text 1
text 2
********* Keys *********
0
null
********* Values *********
text 2
text 1
         */
    }

    public static Map getExpectedMap() {
        return new HashMap();  //INSTEAD of  new TreeMap()
    }
}












package com.javarush.test.level37.lesson06.task03;

import java.util.HashMap;
import java.util.Map;

/* Ambiguous behavior for NULL
Измените реализацию метода getExpectedMap, он должен вернуть объект такого класса, для которого будет противоположное
поведение при добавлении ссылки null.
См. пример вывода в методе main.
Остальной код не менять.
*/
public class Solution {
    public static void main(String[] args) {
        Map expectedMap = getExpectedMap();
        System.out.println("****** check the key \"s\" whether it IS NOT in the map");
        checkObject(expectedMap, "s");

        System.out.println("\n****** check the key \"s\" whether it IS in the map");
        expectedMap.put("s", "vvv");
        checkObject(expectedMap, "s");

        System.out.println("\n****** ambiguous behavior for NULL");
        expectedMap.put(null, null);
        checkObject(expectedMap, null);

                /*  expected output for NULL
        ****** ambiguous behavior for NULL
        map contains the value for key = null
        map does NOT contain the value for key = null
                 */
    }

    public static Map getExpectedMap() {
        return new HashMap();               //INSTEAD of   new HashTable();
    }

    public static void checkObject(Map map, Object key) {
        String s1 = map.containsKey(key) ? "map contains the value for key = " + key : "map does NOT contain the value for key = " + key;
        System.out.println(s1);

        //if value is null, it means that the map doesn't contain the value
        Object value = map.get(key);
        String s2 = value != null ? "map contains the value for key = " + key : "map does NOT contain the value for key = " + key;
        System.out.println(s2);
    }
}













Arrays и Collections. Все их методы статические и предназначены для работы с коллекциями и массивами.

Начну с более простого – Arrays. Вот его методы:

Методы и их описание
List<T>asList(T... a)
Возвращает неизменяемый список, заполненный переданными элементами.
int binarySearch(int[] a, int fromIndex, int toIndex, int key)
Ищет элемент (key) в массиве a или подмассиве, начиная с fromIndex и до toIndex.
Массив должен быть отсортирован!
Возвращает номер элемента или fromIndex-1, если элемент не найдет.
int[] copyOf(int[] original, int newLength)
Возвращает под массив original массива, newLength элементов, начиная с нулевого.
int[] copyOfRange(int[] original, int from, int to)
Возвращает под массив original массива, начиная с from и до to.
boolean deepEquals(Object[] a1, Object[] a2)
Глубокое сравнение массивов. Массивы считаются равными, если равны их элементы. Если элементы сами являются массивами, для них тоже выполняется глубокое сравнение.
int deepHashCode(Object a[])
Глубокий хэшкод на основе всех элементов. Если элемент является массивом, для него также вызывается deepHashCode.
String deepToString(Object[] a)
Глубокое преобразование к строке. Для всех элементов вызывается toString(). Если элемент является массивом, для него тоже выполняется глубокое преобразование к строке.
boolean equals(int[] a, int[] a2)
Сравнивает два массив а поэлементно.
void fill(int[] a, int fromIndex, int toIndex, int val)
Заполняет массив (или подмассив) заданным значением.
int hashCode(int a[])
Вычисляет общий hashCode всех элементов массива.
void sort(int[] a, int fromIndex, int toIndex)
Сортирует массив (или подмассив) по возрастанию.
String toString(int[] a)
Преобразовывает массив к строке. Для всех элементов вызывается toString();
- А что, очень полезные методы, многие мне бы пригодились.

- Хочу еще заметить, что я тут привел не все методы. Почти все методы из таблицы дублируются для всех примитивных типов.

 Т.е. если написано String toString(int[] a), 
 
 то так же есть методы String toString(boolean[] a), String toString(byte[] a), String toString(long[] a), 
 String toString(float[] a), String toString(double[] a), String toString(char[] a).









методы класса Collections:

Методы и их описание
boolean addAll(Collection<? super T> c, T... elements)
Добавляет переданные элементы в переданную коллекцию.
Удобно использовать в виде Collections.addList(list, 10,11,12,13,14,15)
Queue<T>asLifoQueue(Deque<T> deque)
Возвращает «обычную очередь», сделанную из «обратной очереди».
int binarySearch(List<? extends T> list, T key, Comparator<? super T> c)
Ищет с помощью двоичного поиска элемент keyв списке list.
Список должен быть отсортирован.
Можно задать компаратор для сравнения элементов.
Collection<E>checkedCollection(Collection<E> c, Class<E> type)
Проверяет, что все элементы коллекции «с» определенного типа «type».
Аналогичные методы существуют для List, Map, Set и SortedSet.
void copy(List<? super T> dest, List<? extends T> src)
Копирует список «src»в список «dest».
boolean disjoint(Collection<?> c1, Collection<?> c2)
Проверяет, что коллекции не содержат общих элементов
void fill(List<? super T> list, T obj)
Заполоняет список list, элементом obj
int frequency(Collection<?> c, Object o)
Подсчитывает сколько раз в коллекции «с» встречается объект «o»
int indexOfSubList(List<?> source, List<?> target)
Определяет индекс, с которого в списокsource входит список target как подпоследовательность.
Принцип аналогичен String.indexOf("somestring")
int lastIndexOfSubList(List<?> source, List<?> target)
Определяет последний индекс, с которого в список source входит список target как подпоследовательность.
Аналогичен String.lastIndexOf("somestring")
T max(Collection<? extends T> coll)
Ищет максимальное число/значение в коллекции.
Как найти максимум из 6-и чисел?
Collections.max(Arrays.asList(51, 42, 33, 24, 15, 6));
T min(Collection<? extends T> coll)
Ищет минимальное значение в коллекции.
List<T>nCopies(int n, To)
Создает фиктивную коллекцию, которая выглядит так, как будто в ней «n» раз встречается элемент «o».
boolean replaceAll(List<T> list, T oldVal, T newVal)
Заменяет в коллекции list все элементы oldVal на newVal
void reverse(List<?> list)
Разворачивает список задом наперед.
void shuffle(List<?> list)
Перемешивает элементы списка случайным образом.
List<T>singletonList(To)
Возвращает неизменяемый список, состоящий из одного переданного элемента.
Аналогичные методы существуют для Map, Set и SortedSet.
void sort(List<T> list)
Сортирует список по возрастанию.
void swap(List<?> list, int i, int j)
Меняет элементы списка местами
Collection<T>synchronizedCollection(Collection<T> c)
Оборачивает данную коллекцию в ее синхронизированный аналог.
Аналогичные методы существуют для List, Map, Set и SortedSet.

















package com.javarush.test.level37.lesson10.task01;

import java.util.Arrays;
import java.util.List;

/* Давно забытый Array
Реализуйте логику метода getData так, чтобы main отработал без исключений
Остальной код не менять
*/
public class Solution {
    public static void main(String[] args) {
        List<Number> numbers = Arrays.<Number>asList(1, 2, 3);
        addDataToList(numbers, getData());
        System.out.println(numbers);
    }

    public static Number[] getData() {

        Number[] numbers = new Number[]{};

        return numbers;
    }

    public static void addDataToList(List<Number> list, Number... data) {
        for (Number number : data) {
            list.add(number);
        }
    }
}










Sparse arrays - аналог в Android

Разработчик Android посчитали, что HashMap не слишком оптимизирован для мобильных устройств и предложили свой вариант в виде специальных массивов. 
Данные классы являются родными для Android, но не являются частью Java. Очень рекомендуют использовать именно Android-классы. Не все программисты знают об этих аналогах,
 а также классический код может встретиться в различных Java-библиотеках. Если вы увидите такой код, то заменить его на нужный. Ниже представлена таблица для замены.

HashMap	Array class
<Integer, Object>	SparseArray
<Integer, Boolean>	SparseBooleanArray
<Integer, Integer>	SparseIntArray
<Integer, Long>	SparseLongArray
<Long, Object>	LongSparseArray



















package com.javarush.test.level20.lesson10.bonus04;

import java.io.*;
import java.util.*;

/* Свой список
Посмотреть, как реализован Solution.
Элементы следуют так: 1->2->3->4  и так 4->3->2->1
По образу и подобию создать Solution.
Элементы должны следовать так:
1->3->7->15
    ->8...
 ->4->9
    ->10
2->5->11
    ->12
 ->6->13
    ->14
Удалили 2 и 9
1->3->7->15
    ->8
 ->4->10
Добавили 16,17,18,19,20 (всегда добавляются на самый последний уровень к тем элементам, которые есть)
1->3->7->15
       ->16
    ->8->17
       ->18
 ->4->10->19
        ->20
Удалили 18 и 20
1->3->7->15
       ->16
    ->8->17
 ->4->10->19
Добавили 21 и 22 (всегда добавляются на самый последний уровень к тем элементам, которые есть.
Последний уровень состоит из 15, 16, 17, 19. 19 последний добавленный элемент, 10 - его родитель.
На данный момент 10 не содержит оба дочерних элемента, поэтому 21 добавился к 10. 22 добавляется в следующий уровень.)
1->3->7->15->22
       ->16
    ->8->17
 ->4->10->19
        ->21

Во внутренней реализации элементы должны добавляться по 2 на каждый уровень
Метод getParent должен возвращать элемент, который на него ссылается.
Например, 3 ссылается на 7 и на 8, т.е.  getParent("8")=="3", а getParent("13")=="6"
Строки могут быть любыми.
При удалении элемента должна удаляться вся ветка. Например, list.remove("5") должен удалить "5", "11", "12"
Итерироваться элементы должны в порядке добавления
Доступ по индексу запрещен, воспользуйтесь при необходимости UnsupportedOperationException
Должно быть наследование AbstractList<String>, List<String>, Cloneable, Serializable
Метод main в тестировании не участвует
*/
public class Solution<S> extends AbstractList<String> implements List<String>, Cloneable, Serializable {
    public static void main(String[] args) {
        List<String> list = new Solution();
        for (int i = 1; i < 16; i++)
        {
            list.add(String.valueOf(i));
        }
        System.out.println("Expected 3, actual is " + ((Solution) list).getParent("8"));
        list.remove("5");
        System.out.println("Expected null, actual is " + ((Solution) list).getParent("11"));
    }

    private ArrayList<Node<String>> heap = new ArrayList<>();
    private int heapSize = 0;

    public Solution() {
        add("0");
    }


    private class Itr implements Iterator {
        /**
         * Index of element to be returned by subsequent call to next.
         */
        int cursor = 1;

        /**
         * Index of element returned by most recent call to next or
         * previous.  Reset to -1 if this element is deleted by a call
         * to remove.
         */
        int lastRet = -1;

        /**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        int expectedModCount = modCount;

        public Itr() {
            while (cursor < heap.size())
                if (heap.get(cursor) == null)
                    cursor++;
                else break;
        }

        @Override
        public boolean hasNext() {
            return cursor != heap.size() && (heapSize > 1);
        }

        @Override
        public Object next() {
            checkForComodification();
            try {
                int i = cursor;
                String next = heap.get(i).item;
                lastRet = i;
                cursor++;
                while (cursor < heap.size() && heap.get(cursor) == null)
                    cursor++;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            } catch (NullPointerException e) {
                System.out.println("NullPointerException:");
                System.out.println("Cursor = " + cursor);
                for (int i = 0; i < heap.size(); i++) {
                    System.out.println(heap.get(i));
                }
                throw e;
            }
        }

        @Override
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                Solution.this.remove(heap.get(lastRet).item);
                if (lastRet == cursor) {
                    while (cursor < heap.size() || heap.get(cursor) == null)
                        cursor++;
                }
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

    @Override
    public Iterator<String> iterator() {
        return new Itr();
    }

    private static class Node<E> implements Serializable{
        E item;
        int arrayListIndex;
        Node<E> nextL;
        Node<E> nextR;
        Node<E> parent;

        Node(Node<E> nextL, Node<E> nextR, E element, Node<E> parent) {
            this.item = element;
            this.nextL = nextL;
            this.nextR = nextR;
            this.parent = parent;
        }

        @Override
        public String toString() {
            return "Value = " + item + ", heapIndex = " + arrayListIndex + ";";
        }
    }

    private Node<String> lastParent() {
        for (int i = (heap.size() - 1) / 2; i < heap.size(); i++) {
            if (heap.get(i) != null && (heap.get(i).nextL == null || heap.get(i).nextR == null ))
                return heap.get(i);
        }
        return null;
    }

    @Override
    public boolean remove(Object o) {
        boolean result = false;
        for (int i = 0; i < heap.size(); i++) {
            if (heap.get(i) != null && heap.get(i).item.equals((String)o)){
                result = removeWithChilds((Node<String>)heap.get(i));
                break;
            }
        }

        //Trim heap by deleting last null elements
        for (int i = heap.size() - 1; i > 0 ; i--) {
            if (heap.get(i) == null)
                heap.remove(i);
            else break;
        }
        return result;
    }

    public boolean removeWithChilds(Node<String> node) {
        if (node.nextR != null)
            removeWithChilds(node.nextR);
        if (node.nextL != null)
            removeWithChilds(node.nextL);
        if (node.arrayListIndex == heap.size() - 1)
            heap.remove(heap.size() - 1);
        Node<String> parent = node.parent;

        if (parent != null) {
            if (parent.nextL == node) {
                parent.nextL = parent.nextR;
                parent.nextR = null;
            }
            if (parent.nextR == node)
                parent.nextR = null;
        }
        if (node.arrayListIndex < heap.size())
            heap.set(node.arrayListIndex, null);
        node = null;
        heapSize--;
        return true;
    }

    /**
     * Appends the specified element to the end of this heap.
     *
     * @param s element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */
    @Override
    public boolean add(String s) {
        final Node<String> p = lastParent();
        final Node<String> newNode = new Node<>(null, null, s, p);
        if (p != null)
            if (p.nextL == null) p.nextL = newNode;
            else p.nextR = newNode;
        newNode.arrayListIndex = heap.size();
        heap.add(newNode);
        heapSize++;
        return true;
    }

    @Override
    public int size() {
        if (heapSize == 0)
            return 0;
        else return heapSize - 1;
    } //don't count root (zero node)

    public String getParent(String value) {
        //have to be implemented
        String parent = null;
        for (int i = 0; i < heap.size(); i++) {
            if (heap.get(i) != null && heap.get(i).item.equals(value)) {
                parent = heap.get(i).parent.item;
            }
        }
        if (parent != null && parent.equals("0")) parent = null;
        return parent;
    }

    @Override
    public ListIterator<String> listIterator(int index) {
        throw new UnsupportedOperationException();
    }

    @Override
    public ListIterator<String> listIterator() {
        return super.listIterator();
    }

    @Override
    public String get(int index) {
        throw new UnsupportedOperationException();
    }

    @Override
    public String set(int index, String element) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void add(int index, String element) {
        throw new UnsupportedOperationException();
    }

    @Override
    public String remove(int index) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int indexOf(Object o) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int lastIndexOf(Object o) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
        Iterator<String> iterator = this.iterator();
        while (iterator.hasNext()) {
            remove(iterator.next());
        }
    }

    @Override
    public boolean addAll(int index, Collection<? extends String> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public List<String> subList(int fromIndex, int toIndex) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean equals(Object o) {
        if (this.size() != ((Solution) o).size())
            return false;
        Iterator<String> iterator1 = this.iterator();
        Iterator<String> iterator2 = ((Solution) o).iterator();
        while (iterator1.hasNext()) {
            if (!iterator1.next().equals(iterator2.next()))
                return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        return super.hashCode();
    }

    @Override
    protected void removeRange(int fromIndex, int toIndex) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean isEmpty() {
        return (this.size() == 0);
    }

    @Override
    public boolean contains(Object o) {
        for (int i = 0; i < heap.size(); i++)
            if (heap.get(i) != null && heap.get(i).item.equals((String)o)){
                return true;
            }
        return false;
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return super.retainAll(c);
    }

    @Override
    public String toString() {
        return super.toString();
    }

    @Override
    public Solution clone() throws CloneNotSupportedException {
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ObjectOutputStream oOS = new ObjectOutputStream(out);
            oOS.writeObject(this);
            ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
            ObjectInputStream oIS = new ObjectInputStream(in);
            return (Solution)oIS.readObject();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }

}












package com.javarush.test.level20.lesson10.bonus03;

import java.util.ArrayList;
import java.util.List;

/* Кроссворд
1. Дан двумерный массив, который содержит буквы английского алфавита в нижнем регистре.
2. Метод detectAllWords должен найти все слова из words в массиве crossword.
3. Элемент(startX, startY) должен соответствовать первой букве слова, элемент(endX, endY) - последней.
text - это само слово, располагается между начальным и конечным элементами
4. Все слова есть в массиве.
5. Слова могут быть расположены горизонтально, вертикально и по диагонали как в нормальном, так и в обратном порядке.
6. Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        int[][] crossword = new int[][]{
                {'f', 'd', 'e', 'r', 'l', 'k'},
                {'u', 's', 'a', 'm', 'e', 'o'},
                {'l', 'n', 'g', 'r', 'o', 'v'},
                {'m', 'l', 'p', 'r', 'r', 'h'},
                {'p', 'o', 'e', 'e', 'j', 'j'}
        };
        List<Word> words = detectAllWords(crossword, "home", "same");

        for(Word w : words){
            System.out.println(w.toString());
        }
            /*
    Ожидаемый результат
    home - (5, 3) - (2, 0)
    same - (1, 1) - (4, 1)
             */
    }

    public static List<Word> detectAllWords(int[][] crossword, String... words) {

        int nosCols = crossword.length;
        int nosRows = crossword[0].length;

        List<Word> expectedWords = new ArrayList<>();

        int[][] searchDirections = new int[][]{
                {0, 1},
                {1, 1},
                {1, 0},
                {1, -1},
                {0, -1},
                {-1, -1},
                {-1, 0},
                {-1, 1},
        };

        for (String word : words) nextWord : {
            for (int i = 0; i < crossword.length; i++) {
                for (int j = 0; j < crossword[i].length; j++) {

                    if (word.charAt(0) == crossword[i][j])
                        for (int directions = 0; directions < searchDirections.length; directions++) {
                            int tmp_i = i;
                            int tmp_j = j;
                            int wordPos = 1;

                            while (wordPos < word.length()) {
                                tmp_i += searchDirections[directions][0];
                                tmp_j += searchDirections[directions][1];
                                if (tmp_i < 0 || tmp_i >= crossword.length || tmp_j < 0 || tmp_j >= crossword[tmp_i].length)
                                    break;
                                if (word.charAt(wordPos) != crossword[tmp_i][tmp_j])
                                    break;
                                else if (wordPos == word.length() - 1) {
                                    Word tWord = new Word(word);
                                    tWord.setStartPoint(j, i);
                                    tWord.setEndPoint(tmp_j, tmp_i);
                                    expectedWords.add(tWord);
                                    break nextWord;
                                }
                                wordPos++;
                            }
                        }
                }
            }
        }

        return expectedWords;

    }

    public static class Word {
        private String text;
        private int startX;
        private int startY;
        private int endX;
        private int endY;

        public Word(String text) {
            this.text = text;
        }

        public void setStartPoint(int i, int j) {
            startX = i;
            startY = j;
        }

        public void setEndPoint(int i, int j) {
            endX = i;
            endY = j;
        }

        @Override
        public String toString() {
            return String.format("%s - (%d, %d) - (%d, %d)", text, startX, startY, endX, endY);
        }
    }
}
















package com.javarush.test.level20.lesson10.bonus01;

import java.util.LinkedList;

/* Алгоритмы-числа
Число S состоит из M чисел, например, S=370 и M(количество цифр)=3
Реализовать логику метода getNumbers, который должен среди натуральных чисел меньше N (long)
находить все числа, удовлетворяющие следующему критерию:
число S равно сумме его цифр, возведенных в M степень
getNumbers должен возвращать все такие числа в порядке возрастания

Пример искомого числа:
370 = 3*3*3 + 7*7*7 + 0*0*0
8208 = 8*8*8*8 + 2*2*2*2 + 0*0*0*0 + 8*8*8*8

На выполнение дается 10 секунд и 50 МБ памяти.
*/
public class Solution {

    public static void main(String[] args) {

        long memoryStart = Runtime.getRuntime().freeMemory();
        Long t0 = System.currentTimeMillis();

        long n = 146511209;
        Integer[] numbers = getNumbers((int) n);

        System.out.println("Armstrong nums:");
        for (int i : numbers) {
            System.out.print(i + " ");
        }

        long memoryEnd = Runtime.getRuntime().freeMemory();
        long memory = (memoryStart - memoryEnd);
        System.out.println();
        System.out.println("Памяти взято:" + memory);
        Long t1 = System.currentTimeMillis();
        System.out.println("Time need to create the arrray = " + (t1 - t0)/1000);
    }

    public static Integer[] getNumbers(int N) {

        int pow = 10;
        LinkedList<Integer> list = new LinkedList<>();
        // initial powers for the number 0-9
        long[] powers = { 0l, 1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l };

        for (long i = 1; i < N; i++) {
            if (i == pow) {
                pow *= 10;
                // calculate i^length
                for (int pi = 1; pi < 10; pi++) {
                    powers[pi] *= pi;
                }
            }
            long s = i;
            long k = 0;
            while (s > 0) {
                int r = (int)(s % 10);
                k += powers[r];
                if (k > i)
                    break;
                s /= 10;
            }

            if (k == i)
                list.add((int) i);
        }

        return list.toArray(new Integer[]{});
    }

}

ВАРИК С МАССИВОМ:

package com.javarush.test.level20.lesson10.bonus01;

import java.util.LinkedList;

/* Алгоритмы-числа
Число S состоит из M чисел, например, S=370 и M(количество цифр)=3
Реализовать логику метода getNumbers, который должен среди натуральных чисел меньше N (long)
находить все числа, удовлетворяющие следующему критерию:
число S равно сумме его цифр, возведенных в M степень
getNumbers должен возвращать все такие числа в порядке возрастания

Пример искомого числа:
370 = 3*3*3 + 7*7*7 + 0*0*0
8208 = 8*8*8*8 + 2*2*2*2 + 0*0*0*0 + 8*8*8*8

На выполнение дается 10 секунд и 50 МБ памяти.
*/
public class Solution {

    public static void main(String[] args) {

        long memoryStart = Runtime.getRuntime().freeMemory();
        Long t0 = System.currentTimeMillis();

        long n = 146511209;
        int[] numbers = getNumbers((int) n);

        System.out.println("Armstrong nums:");
        for (int i : numbers) {
            System.out.print(i + " ");
        }

        long memoryEnd = Runtime.getRuntime().freeMemory();
        long memory = (memoryStart - memoryEnd);
        System.out.println();
        System.out.println("Памяти взято:" + memory);
        Long t1 = System.currentTimeMillis();
        System.out.println("Time need to create the arrray = " + (t1 - t0)/1000);
    }

    public static int[] getNumbers(int N) {

        int pow = 10;
        LinkedList<Integer> list = new LinkedList<>();
        // initial powers for the number 0-9
        long[] powers = { 0l, 1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l };

        for (long i = 1; i < N; i++) {   //проходимся по всем числам от 1 до N
            if (i == pow) {              //добавляем 0 к итерации каждый раз, когда достиграем очередного порога
                pow *= 10;
                // calculate i^length
                for (int pi = 1; pi < 10; pi++) {
                    powers[pi] *= pi;
                }
            }
            long s = i;
            long k = 0;

            while (s > 0) {
                int r = (int)(s % 10);
                k += powers[r];
                if (k > i)
                    break;
                s /= 10;
            }

            if (k == i)
                list.add((int) i);
        }

        int[] arr = new int[list.size()];

        for(int g = 0; g < list.size(); g++){
            arr[g] = list.get(g);
        }

        return arr;
    }

}













package com.javarush.test.level20.lesson10.bonus01;

import java.util.LinkedList;

/* Алгоритмы-числа
Число S состоит из M чисел, например, S=370 и M(количество цифр)=3
Реализовать логику метода getNumbers, который должен среди натуральных чисел меньше N (long)
находить все числа, удовлетворяющие следующему критерию:
число S равно сумме его цифр, возведенных в M степень
getNumbers должен возвращать все такие числа в порядке возрастания

Пример искомого числа:
370 = 3*3*3 + 7*7*7 + 0*0*0
8208 = 8*8*8*8 + 2*2*2*2 + 0*0*0*0 + 8*8*8*8

На выполнение дается 10 секунд и 50 МБ памяти.
*/
public class Solution {

    public static void main(String[] args) {

        long memoryStart = Runtime.getRuntime().freeMemory();
        Long startTime = System.currentTimeMillis();

        long n = 146511209;
        int[] numbers = getNumbers((int) n);

        System.out.println("Armstrong nums:");
        for (int i : numbers) {
            System.out.print(i + " ");
        }

        System.out.println();
        long estimatedTime = System.currentTimeMillis() - startTime;
        long memoryEnd = Runtime.getRuntime().freeMemory();
        long estimatedMemory = memoryStart - memoryEnd;
        System.out.println("Время подсчета: " + (double) estimatedTime / 1000 + " c");
        System.out.println("Использованная память: " + (double)estimatedMemory / 1024 / 1024 + " МБ");
    }

    public static int[] getNumbers(int N) {

        int pow = 10;
        LinkedList<Integer> list = new LinkedList<>();
        // initial powers for the number 0-9
        long[] powers = { 0l, 1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l };

        for (long i = 1; i < N; i++) {   //проходимся по всем числам от 1 до N
            if (i == pow) {              //добавляем 0 к итерации каждый раз, когда достиграем очередного порога
                pow *= 10;
                // calculate i^length
                for (int pi = 1; pi < 10; pi++) {
                    powers[pi] *= pi;
                }
            }
            long s = i;
            long k = 0;

            while (s > 0) {
                int r = (int)(s % 10);    //остаток от деления на 10 одного из вероятных чисел Арсмтронга
                k += powers[r];           //увеличиваем k на во
                if (k > i)
                    break;
                s /= 10;
            }

            if (k == i)
                list.add((int) i);
        }

        int[] arr = new int[list.size()];

        for(int g = 0; g < list.size(); g++){
            arr[g] = list.get(g);
        }

        return arr;
    }

}














package com.javarush.test.level20.lesson10.bonus03;

import java.util.ArrayList;
import java.util.List;

/* Кроссворд
1. Дан двумерный массив, который содержит буквы английского алфавита в нижнем регистре.
2. Метод detectAllWords должен найти все слова из words в массиве crossword.
3. Элемент(startX, startY) должен соответствовать первой букве слова, элемент(endX, endY) - последней.
text - это само слово, располагается между начальным и конечным элементами
4. Все слова есть в массиве.
5. Слова могут быть расположены горизонтально, вертикально и по диагонали как в нормальном, так и в обратном порядке.
6. Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        int[][] crossword = new int[][]{
                {'f', 'd', 'e', 'r', 'l', 'k'},
                {'u', 's', 'a', 'm', 'e', 'o'},
                {'l', 'n', 'g', 'r', 'o', 'v'},
                {'m', 'l', 'p', 'r', 'r', 'h'},
                {'p', 'o', 'e', 'e', 'j', 'j'}
        };
        List<Word> words = detectAllWords(crossword, "home", "same");

        for(Word w : words){
            System.out.println(w.toString());
        }
            /*
    Ожидаемый результат
    home - (5, 3) - (2, 0)
    same - (1, 1) - (4, 1)
             */
    }

    public static List<Word> detectAllWords(int[][] crossword, String... words) {

        int nosCols = crossword.length;
        int nosRows = crossword[0].length;

        List<Word> expectedWords = new ArrayList<>();

        int[][] searchDirections = new int[][]{
                {0, 1},
                {1, 1},
                {1, 0},
                {1, -1},
                {0, -1},
                {-1, -1},
                {-1, 0},
                {-1, 1},
        };

        for (String word : words) nextWord : {
            for (int i = 0; i < crossword.length; i++) {
                for (int j = 0; j < crossword[i].length; j++) {

                    if (word.charAt(0) == crossword[i][j])
                        for (int directions = 0; directions < searchDirections.length; directions++) {
                            int tmp_i = i;
                            int tmp_j = j;
                            int wordPos = 1;

                            while (wordPos < word.length()) {
                                tmp_i += searchDirections[directions][0];
                                tmp_j += searchDirections[directions][1];
                                if (tmp_i < 0 || tmp_i >= crossword.length || tmp_j < 0 || tmp_j >= crossword[tmp_i].length)
                                    break;
                                if (word.charAt(wordPos) != crossword[tmp_i][tmp_j])
                                    break;
                                else if (wordPos == word.length() - 1) {
                                    Word tWord = new Word(word);
                                    tWord.setStartPoint(j, i);
                                    tWord.setEndPoint(tmp_j, tmp_i);
                                    expectedWords.add(tWord);
                                    break nextWord;
                                }
                                wordPos++;
                            }
                        }
                }
            }
        }

        return expectedWords;

    }

    public static class Word {
        private String text;
        private int startX;
        private int startY;
        private int endX;
        private int endY;

        public Word(String text) {
            this.text = text;
        }

        public void setStartPoint(int i, int j) {
            startX = i;
            startY = j;
        }

        public void setEndPoint(int i, int j) {
            endX = i;
            endY = j;
        }

        @Override
        public String toString() {
            return String.format("%s - (%d, %d) - (%d, %d)", text, startX, startY, endX, endY);
        }
    }
}












package com.javarush.test.level38.lesson04.task02;

/* Непроверяемые исключения (unchecked exception)
Напиши реализацию метода methodThrowsClassCastException(). Он должен
всегда кидать непроверяемое исключение ClassCastException.

Напиши реализацию метода methodThrowsNullPointerException(). Он должен
всегда кидать непроверяемое исключение NullPointerException.

Кинуть исключение (throw) явно нельзя.
*/

import java.util.List;

public class VeryComplexClass {

    public void methodThrowsClassCastException() {
        //напишите тут ваш код
        Object i = Integer.valueOf(42);
        String s = (String)i;

    }

    public void methodThrowsNullPointerException() {
        //напишите тут ваш код
        String s = null;

        List<String> list = null;

        list.add(s);
    }
}











package com.javarush.test.level38.lesson04.task01;

/* Проверяемые исключения (checked exception)
Напиши реализацию метода veryComplexMethod().
Он должен всегда кидать какое-нибудь проверяемое исключение.
Кинуть исключение (throw) явно нельзя.
*/

import java.io.BufferedReader;
import java.io.FileReader;

public class VeryComplexClass {
    
    public void veryComplexMethod() throws Exception {
        //напишите тут ваш код

        FileReader s = new FileReader(" ");
        BufferedReader reader = new BufferedReader(s);

        reader.read();
    }
}












package com.javarush.test.level38.lesson04.home01;

/* Исправь ошибки в коде
Исключения NameIsEmptyException и NameIsNullException должны быть checked.
Все типы исключений должны быть обработаны.
Реализацию методов main() и getNumberOfCharacters() не менять.
*/

public class Solution {
    public static void main(String[] args) {
        if (args.length > 0) {
            try {
                System.out.println("Имя содержит " + NameChecker.getNumberOfCharacters(args[0]) + " символов");
            } catch (NameIsNullException e) {
                System.out.println("Ошибка: Имя не задано");
            } catch (NameIsEmptyException e) {
                System.out.println("Ошибка: Имя пустое");
            } catch (Exception e) {
                System.out.println(e.toString());
            }
        }
    }
}

package com.javarush.test.level38.lesson04.home01;

public class NameChecker {
    private static final int MAX_NUMBER_OF_CHARACTERS = 100500;
    public static int getNumberOfCharacters(String name) throws Exception {
        if (name == null)
            throw new NameIsNullException();
        else if (name.isEmpty())
            throw new NameIsEmptyException();

        int length = name.length();
        if (length > MAX_NUMBER_OF_CHARACTERS)
            throw new Exception("Слишком длинное имя");
        return length;
    }
}


package com.javarush.test.level38.lesson04.task01;

/* Проверяемые исключения (checked exception)
Напиши реализацию метода veryComplexMethod().
Он должен всегда кидать какое-нибудь проверяемое исключение.
Кинуть исключение (throw) явно нельзя.
*/

import java.io.BufferedReader;
import java.io.FileReader;

public class VeryComplexClass {

    public void veryComplexMethod() throws Exception {
        //напишите тут ваш код

        FileReader s = new FileReader(" ");
        BufferedReader reader = new BufferedReader(s);

        reader.read();
    }
}




package com.javarush.test.level38.lesson04.home01;

public class NameIsEmptyException extends Exception {
}

package com.javarush.test.level38.lesson04.home01;

public class NameIsNullException extends Exception {
}












package com.javarush.test.level38.lesson06.task01;

/* Улучшения в Java 7 (try-with-resources)
Перепиши реализации методов класса Solution.
Используй нововведения, касающиеся обработки исключений, которые были добавлены в Java 7.
*/

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class Solution {
    public void printFile1() throws IOException {

        try (FileInputStream fileInputStream = new FileInputStream("file.txt")) {

            int data = fileInputStream.read();
            while (data != -1) {
                System.out.println(data);
                data = fileInputStream.read();
            }

            fileInputStream.close();

        }
    }

    public void printFile2() throws IOException {
        try (FileInputStream fileInputStream = new FileInputStream("file.txt");
             BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream)) {
            int data = bufferedInputStream.read();
            while (data != -1) {
                System.out.println(data);
                data = bufferedInputStream.read();
            }
            fileInputStream.close();
            bufferedInputStream.close();
        }
    }
}











package com.javarush.test.level38.lesson06.home02;

/* Улучшения в Java 7 (multiple exceptions)
Перепиши реализации методов класса Solution.
Используй нововведения, касающиеся обработки исключений, которые были добавлены в Java 7.
*/

public class Solution {
    private final Connection connection;

    public Solution() throws SolutionException, ConnectionException, WrongDataException {
        try {
            connection = new ConnectionMock();
            connection.connect();
        }
        catch (WrongDataException | ConnectionException e) {
            throw new SolutionException(e.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }

    public void write(Object data) throws SolutionException, ConnectionException, WrongDataException {
        try {
            connection.write(data);
        }
        catch (WrongDataException | ConnectionException e) {
            throw new SolutionException(e.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }

    public Object read() throws SolutionException, ConnectionException, WrongDataException {
        try {
            return connection.read();
        } catch (WrongDataException | ConnectionException e) {
            throw new SolutionException(e.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }

    public void disconnect() throws SolutionException, WrongDataException, ConnectionException {
        try {
            connection.disconnect();
        }
        catch (WrongDataException | ConnectionException e) {
            throw new SolutionException(e.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }
}









package com.javarush.test.level38.lesson06.home01;

/* Фабрика исключений
Создайте класс - фабрику исключений, который содержит один статический метод, возвращающий нужное исключение.
Этот метод должен принимать один параметр - энум.
Если передан энум:
* ExceptionApplicationMessage, верните исключение Exception
* ExceptionDBMessage, верните исключение RuntimeException
* ExceptionUserMessage, верните Error
иначе верните IllegalArgumentException без сообщения.

В качестве сообщения (message) для каждого возвращаемого объекта используйте элементы энума, в которых все знаки
подчеркивания замените на пробелы. Сообщение должно быть в нижнем регистре за исключением первого символа.
Например, сообщение для ExceptionApplicationMessage.SOCKET_IS_CLOSED - "Socket is closed".

Верните класс созданной фабрики в методе Solution.getFactoryClass.

Энумы не меняйте.
*/

public class Solution {
    public static Class getFactoryClass() {

        return ExceptionFactory.class;
    }
}



package com.javarush.test.level38.lesson06.home01;

/**
 * Created by Кира on 16.12.2016.
 */
public class ExceptionFactory {

    public static Throwable getExnceptionNeeded(Enum e){

        if (e != null) {
            if (e instanceof ExceptionApplicationMessage) {
                return new Exception(e.name().charAt(0) + e.name().substring(1).toLowerCase().replace("_", " "));
            }
            else if (e instanceof ExceptionDBMessage) {
                return new RuntimeException(e.name().charAt(0) + e.name().substring(1).toLowerCase().replace("_", " "));
            }
            else if (e instanceof ExceptionUserMessage) {
                return new Error(e.name().charAt(0) + e.name().substring(1).toLowerCase().replace("_", " "));
            }
        }
        return new IllegalArgumentException();
    }

}





ANNOTATIONS - АННОТАЦИИ

Аннотации можно использовать для генерации XML, определения, устарел метод или нет, отслеживания ошибок и т.п.

Пример аннотаций в коде:

Пример
@CatInfo(manager=Catmanager.class, unique=true)
class Cat
{
 @Name("Murka")
 private String name;

 @SuppressWarnings(value = "unchecked")
 void getUniqueCatName()
 {

 }
}
Как ты видишь, в аннотациях можно хранить данные.

Если аннотация имеет только одно поле value, то его можно опускать:

Пример
@SuppressWarnings("unchecked")
void getUniqueCatName()
{ 

}
Если параметров в скобках нет, скобки тоже можно не писать:

Пример
@Override
void getUniqueCatName()
{ 

}
Создать свою аннотацию очень легко. Объявление аннотации – практически идентично объявлению интерфейса.

Пример
@interface CatManager
{
 Class manager();
 boolean unique();
 String name() default "Unknown Cat";
}



@Deprecated.

Класс или метод можно пометить аннотацией @Deprecated. Тогда компилятор будет выдавать предупреждение (предупреждение - это не ошибка), а Intellij IDEA будет отображать этот метод как перечеркнутый. Примерно так:

Пример
Date date = new Date();
int year = date.getYear();
@Override.

При переопределении метода, хорошим тоном считается добавить ему аннотацию @Override.

- А для чего? Вроде же IDEA и так показывает, переопределен метод или нет?

- Во-первых, то IDEA, а то синтаксис Java.

А во-вторых, гипотетически может быть ситуация, когда метод базового класса переименуют, а метод наследника – нет. И программа будет работать неправильно, но никто этого не заметит. Для предотвращения таких ситуаций и была придумана эта аннотация:

Пример
@Override
void getUniqueCatName()
{

}
@SuppressWarnings.

- Иногда компилятор выводит очень много предупреждений. Или мы знаем о «проблемах» и сознательно пошли на такое использование. С помощью этой аннотации можно скрыть часть из них.

С помощью аннотации @SuppressWarnings, программист может сказать компилятору: не нужно показывать предупреждения, так задумано, это не ошибка. Пример:

Пример
@SuppressWarnings("unchecked")
void getUniqueCatName()
{ 

}








package com.javarush.test.level38.lesson08.task01;

/* Предопределенные типы аннотаций (Predefined Annotation Types)
Расставьте в этом классе, везде где только можно, все возможные предопределенные в Java аннотации.
Не должно быть избыточности.
*/

@Deprecated
public class Solution {

    @Deprecated
    private String[] arguments;

    @Deprecated
    @SafeVarargs
    public Solution(@Deprecated String... arguments) {
        this.arguments = arguments;
    }

    @Deprecated
    @SuppressWarnings("unchecked")
    public void voidMethod() throws Exception {
    }

    @Deprecated
    public static void main(@Deprecated String[] args) throws Exception {

        new Solution().new SubSolution().voidMethod();
    }

    @Deprecated
    class SubSolution extends Solution {

        @Deprecated
        @Override
        public void voidMethod() throws Exception {

            super.voidMethod();
        }
    }
}











package com.javarush.test.level38.lesson08.task02;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.util.ArrayList;
import java.util.List;

/* Неверные аннотации
Исправь неверные аннотации. Код должен компилировался без ошибок и предупреждений.
*/

@Target(ElementType.METHOD)
@interface Main {
}

public class Solution {
    @Main
    public static void main(String[] args) {
        Solution solution = new Solution().new SubSolution();
        solution.overriddenMethod();
    }

    public void overriddenMethod() {
    }

    public class SubSolution extends Solution {
        @Override
        public void overriddenMethod() {
            System.out.println(uncheckedCall());
        }

        @SuppressWarnings("unchecked")
        List uncheckedCall() {
            List list = new ArrayList();
            list.add("hello");
            return list;
        }
    }


}
















package com.javarush.test.level38.lesson10.home01;

/* Annotation + Reflection
Разберитесь в коде и исправьте ошибку.
Ориентируйтесь на ожидаемый вывод.
Сделайте минимально возможные изменения.
*/

public class Solution {
    public static void main(String[] args) throws IllegalAccessException {
        JavaRushBankAccount account = new JavaRushBankAccount("Mr.Smith");
        System.out.println("Проверка №1:");
        ReflectionAnnotationUtil.check(account);

        System.out.println("Проверка №2:");
        account.setAmount(100);
        ReflectionAnnotationUtil.check(account);

        System.out.println("Проверка №3:");
        ReflectionAnnotationUtil.check(new IncorrectAccount());
        /* Ожидаемый вывод:

        Проверка №1:
        Поле amount в классе JavaRushBankAccount имеет аннотацию LongPositive, но его значение не положительное.
        Проверка №2:
        Проверка №3:
        Поле amountString в классе IncorrectAccount имеет аннотацию LongPositive, но его тип String.

        */
    }
}


package com.javarush.test.level38.lesson10.home01;

import java.lang.reflect.Field;

public final class ReflectionAnnotationUtil {
    public static void check(Object someObject) throws IllegalAccessException {

        Class<?> testedClass = someObject.getClass();
        for (Field field : testedClass.getDeclaredFields()) {
            if (field.isAnnotationPresent(LongPositive.class)) {
                processLongPositiveAnnotationField(someObject, testedClass, field);
            }
        }
    }

    private static void processLongPositiveAnnotationField(Object someObject, Class<?> testedClass, Field field) throws
            IllegalAccessException
    {
        field.setAccessible(true);
        Class<?> fieldType = field.getType();

        //assert type is long
        if (!fieldType.equals(long.class)) {
            String msg = String.format("Поле %s в классе %s имеет аннотацию LongPositive, но его тип %s.",
                    field.getName(), testedClass.getSimpleName(), fieldType.getSimpleName());
            System.out.println(msg);
            return;
        }

        //assert value is positive
        long value = (long) field.get(someObject);
        if (value <= 0) {
            String msg = String.format("Поле %s в классе %s имеет аннотацию LongPositive, но его значение не положительное.",
                    field.getName(), testedClass.getSimpleName());
            System.out.println(msg);
        }
    }
}


package com.javarush.test.level38.lesson10.home01;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(value = ElementType.FIELD)
@Retention(value = RetentionPolicy.RUNTIME)
public @interface LongPositive {

}












package com.javarush.test.level38.lesson08.task01;

/* Предопределенные типы аннотаций (Predefined Annotation Types)
Расставьте в этом классе, везде где только можно, все возможные предопределенные в Java аннотации.
Не должно быть избыточности.
*/

@Deprecated
public class Solution {

    @Deprecated
    private String[] arguments;

    @Deprecated
    @SafeVarargs
    public Solution(@Deprecated String... arguments) {
        this.arguments = arguments;
    }

    @Deprecated
    @SuppressWarnings("unchecked")
    public void voidMethod() throws Exception {
    }

    @Deprecated
    public static void main(@Deprecated String[] args) throws Exception {

        new Solution().new SubSolution().voidMethod();
    }

    @Deprecated
    class SubSolution extends Solution {

        @Deprecated
        @Override
        public void voidMethod() throws Exception {

            super.voidMethod();
        }
    }
}











package com.javarush.test.level38.lesson10.home02;

/* Реализуй аннотации
Проект должен компилироваться и выводить аннотацию класса Solution.
Класс Solution и его аннотацию не менять.
Аннотация Changelog должна быть видна во время выполнения.
*/

@Changelog({
        @Revision(
                revision = 4089,
                date = @Date(year = 2011, month = 5, day = 30, hour = 18, minute = 35, second = 18),
                comment = "Новый файл добавлен"),
        @Revision(
                revision = 6018,
                date = @Date(year = 2013, month = 1, day = 1, hour = 0, minute = 0, second = 1),
                authors = {@Author(value = "Серега", position = Position.MIDDLE)},
                comment = "Фикс багов"),
        @Revision(
                revision = 10135,
                date = @Date(year = 2014, month = 12, day = 31, hour = 23, minute = 59, second = 59),
                authors = {@Author(value = "Диана", position = Position.OTHER),
                        @Author("Игорь"),
                        @Author(value = "Витек", position = Position.SENIOR)})
})
public class Solution {
    public static void main(String[] args) {
        System.out.println(Solution.class.getAnnotation(Changelog.class).toString());
    }
}


package com.javarush.test.level38.lesson10.home02;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(value = RetentionPolicy.RUNTIME)
public @interface Changelog {
    Revision [] value();
}




package com.javarush.test.level38.lesson10.home02;

public @interface Revision {
    int revision();
    Date date();
    Author[] authors() default {};
    String comment() default "";
}




package com.javarush.test.level38.lesson10.home02;

public @interface Date {
    int year();
    int month();
    int day();
    int hour();
    int minute();
    int second();
}


package com.javarush.test.level38.lesson10.home02;


public @interface Author {
    String value() default "NoName";
    Position position() default Position.OTHER;
}
package com.javarush.test.level38.lesson10.home02;


public enum Position {
    JUNIOR,
    MIDDLE,
    SENIOR,
    OTHER
}

















package com.javarush.test.level20.lesson10.bonus02;

/* Алгоритмы-прямоугольники
1. Дан двумерный массив N*N, который содержит несколько прямоугольников.
2. Различные прямоугольники не соприкасаются и не накладываются.
3. Внутри прямоугольник весь заполнен 1.
4. В массиве:
4.1) a[i, j] = 1, если элемент (i, j) принадлежит какому-либо прямоугольнику
4.2) a[i, j] = 0, в противном случае
5. getRectangleCount должен возвращать количество прямоугольников.
6. Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        byte[][] a = new byte[][]{
                {0, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 0}
        };

        byte[][]b = new byte[][]{
                {1, 0, 0, 0},
                {1, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 1}
        };

        byte[][]c = new byte[][]{
                {0, 0, 1, 0},
                {1, 0, 1, 0},
                {1, 0, 0, 0},
                {0, 0, 0, 1}
        };

        byte[][]d = new byte[][]{
                {0, 0, 1, 0},
                {1, 0, 1, 1},
                {1, 0, 0, 0},
                {0, 1, 0, 1}
        };


        int countA = getRectangleCount(a);
        int countB = getRectangleCount(b);
        int countC = getRectangleCount(c);
        int countD = getRectangleCount(d);
        System.out.println("count = " + countA + ". Должно быть 0");
        System.out.println("count = " + countB + ". Должно быть 2");
        System.out.println("count = " + countC + ". Должно быть 3");
        System.out.println("count = " + countD + ". Должно быть 5");
    }

    public static int getRectangleCount(byte[][] a) {

        int numOfRect = 0;

        int height = a.length;
        int width = a[0].length;

        int left = width + 1;
        int right = 0;
        int top = height + 1;
        int bottom = 0;
        int count = 0;

        for (int x = 1; x < width; x++) {
            for (int y = 1; y < height; y++) {

                if (a[x][y] == firstJ(a)) {
                    left = Math.min(left, x);
                    right = Math.max(right, x);
                    top = Math.min(top, x);
                    bottom = Math.max(bottom, x);
                    count++;
                }
                if(count == (right-left+1)*(bottom-top+1)){
                    numOfRect++;
                }
            }
        }
        return numOfRect;
    }

    private static int firstJ (byte[][] b){
        for (int j=0; j<b.length; j++){
            for (int i=0; i<b.length; i++){
                if (b [j][i]==1){
                    return j;
                }
            }
        }
        return -1;
    }
}









package com.javarush.test.level20.lesson10.bonus02;

/* Алгоритмы-прямоугольники
1. Дан двумерный массив N*N, который содержит несколько прямоугольников.
2. Различные прямоугольники не соприкасаются и не накладываются.
3. Внутри прямоугольник весь заполнен 1.
4. В массиве:
4.1) a[i, j] = 1, если элемент (i, j) принадлежит какому-либо прямоугольнику
4.2) a[i, j] = 0, в противном случае
5. getRectangleCount должен возвращать количество прямоугольников.
6. Метод main не участвует в тестировании
*/
public class Solution {
    public static void main(String[] args) {
        byte[][] a = new byte[][]{
                {0, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 0}
        };

        byte[][] b = new byte[][]{
                {1, 0, 0, 0},
                {1, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 1}
        };

        byte[][] c = new byte[][]{
                {0, 0, 1, 0},
                {1, 0, 1, 0},
                {1, 0, 0, 0},
                {0, 0, 0, 1}
        };

        byte[][] d = new byte[][]{
                {0, 0, 1, 0},
                {1, 0, 1, 1},
                {1, 0, 0, 0},
                {0, 1, 0, 1}
        };


        int countA = getRectangleCount(a);
        int countB = getRectangleCount(b);
        int countC = getRectangleCount(c);
        int countD = getRectangleCount(d);
        System.out.println("count = " + countA + ". Должно быть 0");
        System.out.println("count = " + countB + ". Должно быть 2");
        System.out.println("count = " + countC + ". Должно быть 3");
        System.out.println("count = " + countD + ". Должно быть 5");
    }

    public static int getRectangleCount(byte[][] a) {
        byte[][] b = a.clone();
        for (int i = 0; i < a.length; i++) {
            b[i] = a[i].clone();
        }

        int rectCount = 0;
        for (int i = 0; i < b.length; i++) {
            for (int j = 0; j < b.length; j++) {
                if (b[i][j] == 1) {
                    rectCount++;
                    for (int k = i; k < b.length; k++) {
                        if (b[k][j] == 0)
                            break;
                        for (int l = j; l < b.length; l++) {
                            if (b[k][l] == 1)
                                b[k][l] = 0;
                            else
                                break;
                        }
                    }
                }
            }
            System.out.println();
        }
        return rectCount;
    }
}











/* Прайсы
CrUD для таблицы внутри файла
Считать с консоли имя файла для операций CrUD
Программа запускается со следующим набором параметров:
-c productName price quantity
Значения параметров:
где id - 8 символов
productName - название товара, 30 chars (60 bytes)
price - цена, 8 символов
quantity - количество, 4 символа
-с  - добавляет товар с заданными параметрами в конец файла, генерирует id самостоятельно, инкрементируя максимальный id
В файле данные хранятся в следующей последовательности (без разделяющих пробелов):
id productName price quantity
Данные дополнены пробелами до их длины
Пример:
19846   Шорты пляжные синие           159.00  12
198478  Шорты пляжные черные с рисунко173.00  17
19847983Куртка для сноубордистов, разм10173.991234
*/

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;

public class Solution {
    public static void main(String[] args) throws Exception {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String fileName = bufferedReader.readLine();
        bufferedReader.close();
        String productName = "";

        for (int i = 1; i < args.length-2; i++)
            productName = productName + args[i] + " ";
        String trueProductName = setSpaces(productName, 30);

        String truePrice = setSpaces(args[args.length-2], 8);
        String trueQuantity = setSpaces(args[args.length-1], 4);

        String id = getId(fileName);
        id = setSpaces(id, 8);
        PrintWriter printWriter = new PrintWriter(new BufferedWriter(new FileWriter(fileName, true)));
        printWriter.println(id + trueProductName + truePrice + trueQuantity);
        printWriter.close();

    }

    public static String getId (String fileName) throws IOException {
        ArrayList<Long> allIds = new ArrayList<Long>();
        BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
        String line;
        Long currentId;
        while ((line=bufferedReader.readLine()) != null) {
            line = line.substring(0, 8).replaceAll("\\s", "");
            currentId = Long.parseLong(line);
            allIds.add(currentId);
        }
        bufferedReader.close();
        Long maxId = Collections.max(allIds);
        Long MyId = maxId+1;
        return MyId.toString();
    }


    public static String setSpaces (String previousName, int count) {
        String trueName;
        if (previousName.length()>count)
            trueName = previousName.substring(0, count);
        else
        {
            String s="";
            for (int i = 0; i < (count  - previousName.length()); i++)
                s = s+ " ";
            trueName = previousName+s;
        }
        return trueName;
    }
}







/* Прайсы 2
CrUD для таблицы внутри файла
Считать с консоли имя файла для операций CrUD
Программа запускается с одним из следующих наборов параметров:
-u id productName price quantity
-d id
Значения параметров:
где id - 8 символов
productName - название товара, 30 chars (60 bytes)
price - цена, 8 символов
quantity - количество, 4 символа
-u  - обновляет данные товара с заданным id
-d  - производит физическое удаление товара с заданным id (все данные, которые относятся к переданному id)
В файле данные хранятся в следующей последовательности (без разделяющих пробелов):
id productName price quantity
Данные дополнены пробелами до их длины
Пример:
19846   Шорты пляжные синие           159.00  12
198478  Шорты пляжные черные с рисунко173.00  17
19847983Куртка для сноубордистов, разм10173.991234
*/

import java.io.*;
import java.util.ArrayList;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String fileName = bufferedReader.readLine();
        bufferedReader.close();
        String productName = "";

        ArrayList<String> list = getStringList(fileName);
        ArrayList<Long> idList = getIdList(fileName);
        PrintWriter printWriter;
        int index = idList.indexOf(Long.parseLong(args[1]));

        if (args[0].equals("-u"))
        {
            for (int i = 2; i < args.length - 2; i++)
                productName = productName + args[i] + " ";

            String trueProductName = setSpaces(productName, 30);
            String truePrice = setSpaces(args[args.length - 2], 8);
            String trueQuantity = setSpaces(args[args.length - 1], 4);
            String id = setSpaces(args[1], 8);
            String ourString = id + trueProductName + truePrice + trueQuantity;

            if (!idList.contains(Long.parseLong(args[1])))
            {
                printWriter = new PrintWriter(new BufferedWriter(new FileWriter(fileName, true)));
                printWriter.println(ourString);
            } else {
                list.set(index, ourString);
                printWriter = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
                for (String aString : list)
                    printWriter.println(aString);
            }
            printWriter.close();
        } else if (args[0].equals("-d")) {
            list.remove(index);
            printWriter = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
            for (String aString : list)
                printWriter.println(aString);
            printWriter.close();
        }
    }

    public static ArrayList<String> getStringList (String fileName) throws IOException {
        ArrayList<String> allList = new ArrayList<String>();
        BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
        String line;
        while ((line=bufferedReader.readLine()) != null) {
            allList.add(line);
        }
        bufferedReader.close();
      return allList;
    }

    public static ArrayList<Long> getIdList (String fileName) throws IOException {
        ArrayList<Long> allIds = new ArrayList<Long>();
        BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
        String line;
        Long currentId;
        while ((line=bufferedReader.readLine()) != null) {
            line = line.substring(0, 8).replaceAll("\\s", "");
            currentId = Long.parseLong(line);
            allIds.add(currentId);
        }
        bufferedReader.close();
        return allIds;
    }


    public static String setSpaces (String previousName, int count) {
        String trueName;
        if (previousName.length()>count)
            trueName = previousName.substring(0, count);
        else
        {
            String s="";
            for (int i = 0; i < (count  - previousName.length()); i++)
                s = s+ " ";
            trueName = previousName+s;
        }
        return trueName;
    }
}




